#![doc = "//! Auto generated profile messages from FIT SDK Release: 21.158.00"]
#![allow(unused_variables)]
#![allow(clippy::if_same_then_else, clippy::too_many_arguments)]
use super::field_types::*;
use super::{calculate_cumulative_value, data_field_with_info, extract_component, unknown_field};
use crate::de::DecodeOption;
use crate::error::Result;
use crate::{FitDataField, Value};
use std::collections::{HashMap, HashSet, VecDeque};
use std::convert::TryInto;
#[doc = "FIT SDK version used to generate profile decoder"]
pub const VERSION: &str = "21.158.00";
#[doc = "Must be first message in file."]
#[doc = " * time_created: Only set for files that are can be created/erased."]
#[doc = " * number: Only set for files that are not created/erased."]
#[doc = " * product_name: Optional free form string to indicate the devices name or model"]
fn file_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(file_id_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(file_id_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(file_id_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            3u8 => {
                fields.push(file_id_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(file_id_message_time_created_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(file_id_message_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(file_id_message_product_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn file_id_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "type",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        2u8,
        None,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        2u8,
        None,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_time_created_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "time_created",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "number",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_product_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "product_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "file_creator message definition"]
fn file_creator_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(file_creator_message_software_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(file_creator_message_hardware_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn file_creator_message_software_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "software_version",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_creator_message_hardware_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "hardware_version",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "timestamp_correlation message definition"]
#[doc = " * fractional_timestamp: Fractional part of the UTC timestamp at the time the system timestamp was recorded."]
#[doc = " * system_timestamp: Whole second part of the system timestamp"]
#[doc = " * fractional_system_timestamp: Fractional part of the system timestamp"]
#[doc = " * local_timestamp: timestamp epoch expressed in local time used to convert timestamps to local time"]
#[doc = " * timestamp_ms: Millisecond part of the UTC timestamp at the time the system timestamp was recorded."]
#[doc = " * system_timestamp_ms: Millisecond part of the system timestamp"]
#[doc = " * timestamp: Whole second part of UTC timestamp at the time the system timestamp was recorded."]
fn timestamp_correlation_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(timestamp_correlation_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(timestamp_correlation_message_system_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(
                    timestamp_correlation_message_fractional_system_timestamp_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        32768f64,
                        0f64,
                        "s",
                        value,
                    )?,
                );
            }
            3u8 => {
                fields.push(timestamp_correlation_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(timestamp_correlation_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            5u8 => {
                fields.push(timestamp_correlation_message_system_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            253u8 => {
                fields.push(timestamp_correlation_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn timestamp_correlation_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_system_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "system_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_fractional_system_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "fractional_system_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_system_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "system_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "software message definition"]
fn software_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            3u8 => {
                fields.push(software_message_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(software_message_part_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(software_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn software_message_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "version",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn software_message_part_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "part_number",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn software_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "slave_device message definition"]
fn slave_device_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(slave_device_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(slave_device_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn slave_device_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn slave_device_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn slave_device_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn slave_device_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "capabilities message definition"]
#[doc = " * languages: Use language_bits_x types where x is index of array."]
#[doc = " * sports: Use sport_bits_x types where x is index of array."]
fn capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(capabilities_message_languages_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(capabilities_message_sports_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            21u8 => {
                fields.push(capabilities_message_workouts_supported_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            23u8 => {
                fields.push(capabilities_message_connectivity_supported_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn capabilities_message_languages_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "languages",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn capabilities_message_sports_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sports",
        FieldDataType::SportBits0,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn capabilities_message_workouts_supported_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "workouts_supported",
        FieldDataType::WorkoutCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn capabilities_message_connectivity_supported_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        None,
        "connectivity_supported",
        FieldDataType::ConnectivityCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "file_capabilities message definition"]
fn file_capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(file_capabilities_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(file_capabilities_message_flags_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(file_capabilities_message_directory_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(file_capabilities_message_max_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(file_capabilities_message_max_size_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bytes",
                    value,
                )?);
            }
            254u8 => {
                fields.push(file_capabilities_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn file_capabilities_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "type",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_flags_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "flags",
        FieldDataType::FileFlags,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_directory_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "directory",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_max_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "max_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_max_size_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "max_size",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "mesg_capabilities message definition"]
fn mesg_capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(mesg_capabilities_message_file_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(mesg_capabilities_message_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(mesg_capabilities_message_count_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                if MesgCount::NumPerFile.as_i64()
                    == data_map
                        .get(&2u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(mesg_capabilities_message_num_per_file_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if MesgCount::MaxPerFile.as_i64()
                    == data_map
                        .get(&2u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(mesg_capabilities_message_max_per_file_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if MesgCount::MaxPerFileType.as_i64()
                    == data_map
                        .get(&2u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(mesg_capabilities_message_max_per_file_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(mesg_capabilities_message_count_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            254u8 => {
                fields.push(mesg_capabilities_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn mesg_capabilities_message_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "file",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_count_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "count_type",
        FieldDataType::MesgCount,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_num_per_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "count"
    } else {
        "num_per_file"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_max_per_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "count"
    } else {
        "max_per_file"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_max_per_file_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "count"
    } else {
        "max_per_file_type"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "field_capabilities message definition"]
fn field_capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(field_capabilities_message_file_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(field_capabilities_message_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(field_capabilities_message_field_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(field_capabilities_message_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(field_capabilities_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn field_capabilities_message_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "file",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_field_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "field_num",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "device_settings message definition"]
#[doc = " * active_time_zone: Index into time zone arrays."]
#[doc = " * utc_offset: Offset from system time. Required to convert timestamp from system time to UTC."]
#[doc = " * time_offset: Offset from system time."]
#[doc = " * time_mode: Display mode for the time"]
#[doc = " * time_zone_offset: timezone offset in 1/4 hour increments"]
#[doc = " * backlight_mode: Mode for backlight"]
#[doc = " * activity_tracker_enabled: Enabled state of the activity tracker functionality"]
#[doc = " * clock_time: UTC timestamp used to set the devices clock and date"]
#[doc = " * pages_enabled: Bitfield to configure enabled screens for each supported loop"]
#[doc = " * move_alert_enabled: Enabled state of the move alert"]
#[doc = " * date_mode: Display mode for the date"]
#[doc = " * default_page: Bitfield to indicate one page as default for each supported loop"]
#[doc = " * autosync_min_steps: Minimum steps before an autosync can occur"]
#[doc = " * autosync_min_time: Minimum minutes before an autosync can occur"]
#[doc = " * lactate_threshold_autodetect_enabled: Enable auto-detect setting for the lactate threshold feature."]
#[doc = " * ble_auto_upload_enabled: Automatically upload using BLE"]
#[doc = " * auto_sync_frequency: Helps to conserve battery by changing modes"]
#[doc = " * auto_activity_detect: Allows setting specific activities auto-activity detect enabled/disabled settings"]
#[doc = " * number_of_screens: Number of screens configured to display"]
#[doc = " * smart_notification_display_orientation: Smart Notification display orientation"]
#[doc = " * tap_sensitivity: Used to hold the tap threshold setting"]
fn device_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(device_settings_message_active_time_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(device_settings_message_utc_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(device_settings_message_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(device_settings_message_time_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(device_settings_message_time_zone_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    4f64,
                    0f64,
                    "hr",
                    value,
                )?);
            }
            12u8 => {
                fields.push(device_settings_message_backlight_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            36u8 => {
                fields.push(device_settings_message_activity_tracker_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            39u8 => {
                fields.push(device_settings_message_clock_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            40u8 => {
                fields.push(device_settings_message_pages_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            46u8 => {
                fields.push(device_settings_message_move_alert_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            47u8 => {
                fields.push(device_settings_message_date_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            55u8 => {
                fields.push(device_settings_message_display_orientation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            56u8 => {
                fields.push(device_settings_message_mounting_side_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            57u8 => {
                fields.push(device_settings_message_default_page_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            58u8 => {
                fields.push(device_settings_message_autosync_min_steps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "steps",
                    value,
                )?);
            }
            59u8 => {
                fields.push(device_settings_message_autosync_min_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "minutes",
                    value,
                )?);
            }
            80u8 => {
                fields.push(
                    device_settings_message_lactate_threshold_autodetect_enabled_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?,
                );
            }
            86u8 => {
                fields.push(device_settings_message_ble_auto_upload_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            89u8 => {
                fields.push(device_settings_message_auto_sync_frequency_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            90u8 => {
                fields.push(device_settings_message_auto_activity_detect_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            94u8 => {
                fields.push(device_settings_message_number_of_screens_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            95u8 => {
                fields.push(
                    device_settings_message_smart_notification_display_orientation_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?,
                );
            }
            134u8 => {
                fields.push(device_settings_message_tap_interface_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            174u8 => {
                fields.push(device_settings_message_tap_sensitivity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn device_settings_message_active_time_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "active_time_zone",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_utc_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "utc_offset",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "time_offset",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_time_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "time_mode",
        FieldDataType::TimeMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_time_zone_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "time_zone_offset",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_backlight_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "backlight_mode",
        FieldDataType::BacklightMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_activity_tracker_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 36u8, value)?
    } else {
        value
    };
    data_field_with_info(
        36u8,
        None,
        "activity_tracker_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_clock_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        None,
        "clock_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_pages_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40u8, value)?
    } else {
        value
    };
    data_field_with_info(
        40u8,
        None,
        "pages_enabled",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_move_alert_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46u8, value)?
    } else {
        value
    };
    data_field_with_info(
        46u8,
        None,
        "move_alert_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_date_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        None,
        "date_mode",
        FieldDataType::DateMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_display_orientation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55u8, value)?
    } else {
        value
    };
    data_field_with_info(
        55u8,
        None,
        "display_orientation",
        FieldDataType::DisplayOrientation,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_mounting_side_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56u8, value)?
    } else {
        value
    };
    data_field_with_info(
        56u8,
        None,
        "mounting_side",
        FieldDataType::Side,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_default_page_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57u8, value)?
    } else {
        value
    };
    data_field_with_info(
        57u8,
        None,
        "default_page",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_autosync_min_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58u8, value)?
    } else {
        value
    };
    data_field_with_info(
        58u8,
        None,
        "autosync_min_steps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_autosync_min_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59u8, value)?
    } else {
        value
    };
    data_field_with_info(
        59u8,
        None,
        "autosync_min_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_lactate_threshold_autodetect_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 80u8, value)?
    } else {
        value
    };
    data_field_with_info(
        80u8,
        None,
        "lactate_threshold_autodetect_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_ble_auto_upload_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86u8, value)?
    } else {
        value
    };
    data_field_with_info(
        86u8,
        None,
        "ble_auto_upload_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_auto_sync_frequency_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89u8, value)?
    } else {
        value
    };
    data_field_with_info(
        89u8,
        None,
        "auto_sync_frequency",
        FieldDataType::AutoSyncFrequency,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_auto_activity_detect_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 90u8, value)?
    } else {
        value
    };
    data_field_with_info(
        90u8,
        None,
        "auto_activity_detect",
        FieldDataType::AutoActivityDetect,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_number_of_screens_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94u8, value)?
    } else {
        value
    };
    data_field_with_info(
        94u8,
        None,
        "number_of_screens",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_smart_notification_display_orientation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95u8, value)?
    } else {
        value
    };
    data_field_with_info(
        95u8,
        None,
        "smart_notification_display_orientation",
        FieldDataType::DisplayOrientation,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_tap_interface_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 134u8, value)?
    } else {
        value
    };
    data_field_with_info(
        134u8,
        None,
        "tap_interface",
        FieldDataType::Switch,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_tap_sensitivity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 174u8, value)?
    } else {
        value
    };
    data_field_with_info(
        174u8,
        None,
        "tap_sensitivity",
        FieldDataType::TapSensitivity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "user_profile message definition"]
#[doc = " * friendly_name: Used for Morning Report greeting"]
#[doc = " * wake_time: Typical wake time"]
#[doc = " * sleep_time: Typical bed time"]
#[doc = " * user_running_step_length: User defined running step length set to 0 for auto length"]
#[doc = " * user_walking_step_length: User defined walking step length set to 0 for auto length"]
fn user_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(user_profile_message_friendly_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(user_profile_message_gender_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(user_profile_message_age_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "years",
                    value,
                )?);
            }
            3u8 => {
                fields.push(user_profile_message_height_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(user_profile_message_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            5u8 => {
                fields.push(user_profile_message_language_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(user_profile_message_elev_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(user_profile_message_weight_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(user_profile_message_resting_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            9u8 => {
                fields.push(user_profile_message_default_max_running_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            10u8 => {
                fields.push(user_profile_message_default_max_biking_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            11u8 => {
                fields.push(user_profile_message_default_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            12u8 => {
                fields.push(user_profile_message_hr_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(user_profile_message_speed_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(user_profile_message_dist_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            16u8 => {
                fields.push(user_profile_message_power_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            17u8 => {
                fields.push(user_profile_message_activity_class_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            18u8 => {
                fields.push(user_profile_message_position_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            21u8 => {
                fields.push(user_profile_message_temperature_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            22u8 => {
                fields.push(user_profile_message_local_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            23u8 => {
                fields.push(user_profile_message_global_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            28u8 => {
                fields.push(user_profile_message_wake_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            29u8 => {
                fields.push(user_profile_message_sleep_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            30u8 => {
                fields.push(user_profile_message_height_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            31u8 => {
                fields.push(user_profile_message_user_running_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            32u8 => {
                fields.push(user_profile_message_user_walking_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            47u8 => {
                fields.push(user_profile_message_depth_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            49u8 => {
                fields.push(user_profile_message_dive_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(user_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn user_profile_message_friendly_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "friendly_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_gender_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "gender",
        FieldDataType::Gender,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_age_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "age",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_height_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "height",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_language_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "language",
        FieldDataType::Language,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_elev_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "elev_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_weight_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "weight_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_resting_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "resting_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_default_max_running_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "default_max_running_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_default_max_biking_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "default_max_biking_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_default_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "default_max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_hr_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "hr_setting",
        FieldDataType::DisplayHeart,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_speed_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "speed_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_dist_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "dist_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_power_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        None,
        "power_setting",
        FieldDataType::DisplayPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_activity_class_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        None,
        "activity_class",
        FieldDataType::ActivityClass,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_position_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        None,
        "position_setting",
        FieldDataType::DisplayPosition,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_temperature_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "temperature_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_local_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "local_id",
        FieldDataType::UserLocalId,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_global_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        None,
        "global_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_wake_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        None,
        "wake_time",
        FieldDataType::LocaltimeIntoDay,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_sleep_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        None,
        "sleep_time",
        FieldDataType::LocaltimeIntoDay,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_height_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        None,
        "height_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_user_running_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31u8, value)?
    } else {
        value
    };
    data_field_with_info(
        31u8,
        None,
        "user_running_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_user_walking_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        None,
        "user_walking_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_depth_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        None,
        "depth_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_dive_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49u8, value)?
    } else {
        value
    };
    data_field_with_info(
        49u8,
        None,
        "dive_count",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "hrm_profile message definition"]
fn hrm_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hrm_profile_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hrm_profile_message_hrm_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hrm_profile_message_log_hrv_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(hrm_profile_message_hrm_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(hrm_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hrm_profile_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_hrm_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "hrm_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_log_hrv_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "log_hrv",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_hrm_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "hrm_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "sdm_profile message definition"]
#[doc = " * speed_source: Use footpod for speed source instead of GPS"]
#[doc = " * odometer_rollover: Rollover counter that can be used to extend the odometer"]
fn sdm_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(sdm_profile_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(sdm_profile_message_sdm_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(sdm_profile_message_sdm_cal_factor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            3u8 => {
                fields.push(sdm_profile_message_odometer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(sdm_profile_message_speed_source_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(sdm_profile_message_sdm_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(sdm_profile_message_odometer_rollover_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(sdm_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn sdm_profile_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_sdm_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sdm_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_sdm_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "sdm_cal_factor",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_odometer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "odometer",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_speed_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "speed_source",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_sdm_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "sdm_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_odometer_rollover_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "odometer_rollover",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "bike_profile message definition"]
#[doc = " * odometer_rollover: Rollover counter that can be used to extend the odometer"]
#[doc = " * front_gear_num: Number of front gears"]
#[doc = " * front_gear: Number of teeth on each gear 0 is innermost"]
#[doc = " * rear_gear_num: Number of rear gears"]
#[doc = " * rear_gear: Number of teeth on each gear 0 is innermost"]
fn bike_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(bike_profile_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(bike_profile_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(bike_profile_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(bike_profile_message_odometer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(bike_profile_message_bike_spd_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(bike_profile_message_bike_cad_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(bike_profile_message_bike_spdcad_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(bike_profile_message_bike_power_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(bike_profile_message_custom_wheelsize_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            9u8 => {
                fields.push(bike_profile_message_auto_wheelsize_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            10u8 => {
                fields.push(bike_profile_message_bike_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            11u8 => {
                fields.push(bike_profile_message_power_cal_factor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            12u8 => {
                fields.push(bike_profile_message_auto_wheel_cal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(bike_profile_message_auto_power_zero_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(bike_profile_message_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                fields.push(bike_profile_message_spd_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            16u8 => {
                fields.push(bike_profile_message_cad_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            17u8 => {
                fields.push(bike_profile_message_spdcad_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            18u8 => {
                fields.push(bike_profile_message_power_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            19u8 => {
                fields.push(bike_profile_message_crank_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            20u8 => {
                fields.push(bike_profile_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            21u8 => {
                fields.push(bike_profile_message_bike_spd_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            22u8 => {
                fields.push(bike_profile_message_bike_cad_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            23u8 => {
                fields.push(bike_profile_message_bike_spdcad_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            24u8 => {
                fields.push(bike_profile_message_bike_power_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            37u8 => {
                fields.push(bike_profile_message_odometer_rollover_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            38u8 => {
                fields.push(bike_profile_message_front_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            39u8 => {
                fields.push(bike_profile_message_front_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            40u8 => {
                fields.push(bike_profile_message_rear_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            41u8 => {
                fields.push(bike_profile_message_rear_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            44u8 => {
                fields.push(bike_profile_message_shimano_di2_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(bike_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn bike_profile_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_odometer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "odometer",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spd_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "bike_spd_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_cad_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "bike_cad_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spdcad_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "bike_spdcad_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_power_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "bike_power_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_custom_wheelsize_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "custom_wheelsize",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_auto_wheelsize_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "auto_wheelsize",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "bike_weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_power_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "power_cal_factor",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_auto_wheel_cal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "auto_wheel_cal",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_auto_power_zero_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "auto_power_zero",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "id",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_spd_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "spd_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_cad_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        None,
        "cad_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_spdcad_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        None,
        "spdcad_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_power_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        None,
        "power_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_crank_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        None,
        "crank_length",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        None,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spd_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "bike_spd_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_cad_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "bike_cad_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spdcad_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        None,
        "bike_spdcad_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_power_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        None,
        "bike_power_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_odometer_rollover_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37u8, value)?
    } else {
        value
    };
    data_field_with_info(
        37u8,
        None,
        "odometer_rollover",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_front_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 38u8, value)?
    } else {
        value
    };
    data_field_with_info(
        38u8,
        None,
        "front_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_front_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        None,
        "front_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_rear_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40u8, value)?
    } else {
        value
    };
    data_field_with_info(
        40u8,
        None,
        "rear_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_rear_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41u8, value)?
    } else {
        value
    };
    data_field_with_info(
        41u8,
        None,
        "rear_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_shimano_di2_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44u8, value)?
    } else {
        value
    };
    data_field_with_info(
        44u8,
        None,
        "shimano_di2_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "connectivity message definition"]
#[doc = " * bluetooth_enabled: Use Bluetooth for connectivity features"]
#[doc = " * bluetooth_le_enabled: Use Bluetooth Low Energy for connectivity features"]
#[doc = " * ant_enabled: Use ANT for connectivity features"]
fn connectivity_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(connectivity_message_bluetooth_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(connectivity_message_bluetooth_le_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(connectivity_message_ant_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(connectivity_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(connectivity_message_live_tracking_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(connectivity_message_weather_conditions_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(connectivity_message_weather_alerts_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(connectivity_message_auto_activity_upload_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(connectivity_message_course_download_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(connectivity_message_workout_download_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(connectivity_message_gps_ephemeris_download_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(connectivity_message_incident_detection_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(connectivity_message_grouptrack_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn connectivity_message_bluetooth_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "bluetooth_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_bluetooth_le_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "bluetooth_le_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_ant_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "ant_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_live_tracking_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "live_tracking_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_weather_conditions_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "weather_conditions_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_weather_alerts_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "weather_alerts_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_auto_activity_upload_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "auto_activity_upload_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_course_download_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "course_download_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_workout_download_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "workout_download_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_gps_ephemeris_download_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "gps_ephemeris_download_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_incident_detection_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "incident_detection_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_grouptrack_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "grouptrack_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "watchface_settings message definition"]
fn watchface_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(watchface_settings_message_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if WatchfaceMode::Digital.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(watchface_settings_message_digital_layout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WatchfaceMode::Analog.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(watchface_settings_message_analog_layout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(watchface_settings_message_layout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            254u8 => {
                fields.push(watchface_settings_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn watchface_settings_message_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "mode",
        FieldDataType::WatchfaceMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "layout",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_digital_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "layout"
    } else {
        "digital_layout"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::DigitalWatchfaceLayout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_analog_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "layout"
    } else {
        "analog_layout"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::AnalogWatchfaceLayout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "ohr_settings message definition"]
fn ohr_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(ohr_settings_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(ohr_settings_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ohr_settings_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "enabled",
        FieldDataType::Switch,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ohr_settings_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "time_in_zone message definition"]
fn time_in_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(time_in_zone_message_reference_mesg_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(time_in_zone_message_reference_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(time_in_zone_message_time_in_hr_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            3u8 => {
                fields.push(time_in_zone_message_time_in_speed_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(time_in_zone_message_time_in_cadence_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(time_in_zone_message_time_in_power_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            6u8 => {
                fields.push(time_in_zone_message_hr_zone_high_boundary_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            7u8 => {
                fields.push(time_in_zone_message_speed_zone_high_boundary_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            8u8 => {
                fields.push(time_in_zone_message_cadence_zone_high_bondary_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            9u8 => {
                fields.push(time_in_zone_message_power_zone_high_boundary_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            10u8 => {
                fields.push(time_in_zone_message_hr_calc_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(time_in_zone_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(time_in_zone_message_resting_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(time_in_zone_message_threshold_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(time_in_zone_message_pwr_calc_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                fields.push(time_in_zone_message_functional_threshold_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(time_in_zone_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn time_in_zone_message_reference_mesg_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "reference_mesg",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_reference_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "reference_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_time_in_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "time_in_hr_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_time_in_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "time_in_speed_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_time_in_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "time_in_cadence_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_time_in_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "time_in_power_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_hr_zone_high_boundary_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "hr_zone_high_boundary",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_speed_zone_high_boundary_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "speed_zone_high_boundary",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_cadence_zone_high_bondary_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "cadence_zone_high_bondary",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_power_zone_high_boundary_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "power_zone_high_boundary",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_hr_calc_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "hr_calc_type",
        FieldDataType::HrZoneCalc,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_resting_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "resting_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_threshold_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "threshold_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_pwr_calc_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "pwr_calc_type",
        FieldDataType::PwrZoneCalc,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_functional_threshold_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "functional_threshold_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "zones_target message definition"]
fn zones_target_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            1u8 => {
                fields.push(zones_target_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(zones_target_message_threshold_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(zones_target_message_functional_threshold_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(zones_target_message_hr_calc_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(zones_target_message_pwr_calc_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn zones_target_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_threshold_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "threshold_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_functional_threshold_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "functional_threshold_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_hr_calc_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "hr_calc_type",
        FieldDataType::HrZoneCalc,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_pwr_calc_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "pwr_calc_type",
        FieldDataType::PwrZoneCalc,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "sport message definition"]
fn sport_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(sport_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(sport_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(sport_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn sport_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sport_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sport_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "hr_zone message definition"]
fn hr_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            1u8 => {
                fields.push(hr_zone_message_high_bpm_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hr_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(hr_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hr_zone_message_high_bpm_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "high_bpm",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "speed_zone message definition"]
fn speed_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(speed_zone_message_high_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(speed_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(speed_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn speed_zone_message_high_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "high_value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn speed_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn speed_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "cadence_zone message definition"]
fn cadence_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(cadence_zone_message_high_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            1u8 => {
                fields.push(cadence_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(cadence_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn cadence_zone_message_high_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "high_value",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn cadence_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn cadence_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "power_zone message definition"]
fn power_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            1u8 => {
                fields.push(power_zone_message_high_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            2u8 => {
                fields.push(power_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(power_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn power_zone_message_high_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "high_value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn power_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn power_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "met_zone message definition"]
fn met_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            1u8 => {
                fields.push(met_zone_message_high_bpm_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(met_zone_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "kcal / min",
                    value,
                )?);
            }
            3u8 => {
                fields.push(met_zone_message_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "kcal / min",
                    value,
                )?);
            }
            254u8 => {
                fields.push(met_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn met_zone_message_high_bpm_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "high_bpm",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn met_zone_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn met_zone_message_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "fat_calories",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn met_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "dive_settings message definition"]
#[doc = " * water_density: Fresh water is usually 1000; salt water is usually 1025"]
#[doc = " * po2_warn: Typically 1.40"]
#[doc = " * po2_critical: Typically 1.60"]
#[doc = " * repeat_dive_interval: Time between surfacing and ending the activity"]
#[doc = " * safety_stop_time: Time at safety stop (if enabled)"]
#[doc = " * travel_gas: Index of travel dive_gas message"]
#[doc = " * ccr_low_setpoint_switch_mode: If low PO2 should be switched to automatically"]
#[doc = " * ccr_low_setpoint: Target PO2 when using low setpoint"]
#[doc = " * ccr_low_setpoint_depth: Depth to switch to low setpoint in automatic mode"]
#[doc = " * ccr_high_setpoint_switch_mode: If high PO2 should be switched to automatically"]
#[doc = " * ccr_high_setpoint: Target PO2 when using high setpoint"]
#[doc = " * ccr_high_setpoint_depth: Depth to switch to high setpoint in automatic mode"]
#[doc = " * gas_consumption_display: Type of gas consumption rate to display. Some values are only valid if tank volume is known."]
#[doc = " * up_key_enabled: Indicates whether the up key is enabled during dives"]
#[doc = " * dive_sounds: Sounds and vibration enabled or disabled in-dive"]
#[doc = " * last_stop_multiple: Usually 1.0/1.5/2.0 representing 3/4.5/6m or 10/15/20ft"]
#[doc = " * no_fly_time_mode: Indicates which guidelines to use for no-fly surface interval."]
fn dive_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(dive_settings_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(dive_settings_message_model_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(dive_settings_message_gf_low_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            3u8 => {
                fields.push(dive_settings_message_gf_high_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            4u8 => {
                fields.push(dive_settings_message_water_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(dive_settings_message_water_density_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kg/m^3",
                    value,
                )?);
            }
            6u8 => {
                fields.push(dive_settings_message_po2_warn_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            7u8 => {
                fields.push(dive_settings_message_po2_critical_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            8u8 => {
                fields.push(dive_settings_message_po2_deco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            9u8 => {
                fields.push(dive_settings_message_safety_stop_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(dive_settings_message_bottom_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(dive_settings_message_bottom_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(dive_settings_message_apnea_countdown_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(dive_settings_message_apnea_countdown_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(dive_settings_message_backlight_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                fields.push(dive_settings_message_backlight_brightness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            16u8 => {
                fields.push(dive_settings_message_backlight_timeout_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            17u8 => {
                fields.push(dive_settings_message_repeat_dive_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            18u8 => {
                fields.push(dive_settings_message_safety_stop_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            19u8 => {
                fields.push(dive_settings_message_heart_rate_source_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            20u8 => {
                if SourceType::Antplus.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(dive_settings_message_heart_rate_antplus_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if SourceType::Local.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(dive_settings_message_heart_rate_local_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(dive_settings_message_heart_rate_source_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            21u8 => {
                fields.push(dive_settings_message_travel_gas_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            22u8 => {
                fields.push(dive_settings_message_ccr_low_setpoint_switch_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            23u8 => {
                fields.push(dive_settings_message_ccr_low_setpoint_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            24u8 => {
                fields.push(dive_settings_message_ccr_low_setpoint_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            25u8 => {
                fields.push(dive_settings_message_ccr_high_setpoint_switch_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            26u8 => {
                fields.push(dive_settings_message_ccr_high_setpoint_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            27u8 => {
                fields.push(dive_settings_message_ccr_high_setpoint_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            29u8 => {
                fields.push(dive_settings_message_gas_consumption_display_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            30u8 => {
                fields.push(dive_settings_message_up_key_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            35u8 => {
                fields.push(dive_settings_message_dive_sounds_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            36u8 => {
                fields.push(dive_settings_message_last_stop_multiple_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            37u8 => {
                fields.push(dive_settings_message_no_fly_time_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(dive_settings_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(dive_settings_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_settings_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_model_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "model",
        FieldDataType::TissueModelType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_gf_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "gf_low",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_gf_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "gf_high",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_water_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "water_type",
        FieldDataType::WaterType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_water_density_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "water_density",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_po2_warn_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "po2_warn",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_po2_critical_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "po2_critical",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_po2_deco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "po2_deco",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_safety_stop_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "safety_stop_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_bottom_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "bottom_depth",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_bottom_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "bottom_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_apnea_countdown_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "apnea_countdown_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_apnea_countdown_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "apnea_countdown_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_backlight_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "backlight_mode",
        FieldDataType::DiveBacklightMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_backlight_brightness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "backlight_brightness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_backlight_timeout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        None,
        "backlight_timeout",
        FieldDataType::BacklightTimeout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_repeat_dive_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        None,
        "repeat_dive_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_safety_stop_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        None,
        "safety_stop_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_source_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        None,
        "heart_rate_source_type",
        FieldDataType::SourceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        None,
        "heart_rate_source",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_antplus_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "heart_rate_source"
    } else {
        "heart_rate_antplus_device_type"
    };
    data_field_with_info(
        20u8,
        None,
        name,
        FieldDataType::AntplusDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_local_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "heart_rate_source"
    } else {
        "heart_rate_local_device_type"
    };
    data_field_with_info(
        20u8,
        None,
        name,
        FieldDataType::LocalDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_travel_gas_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "travel_gas",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_low_setpoint_switch_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "ccr_low_setpoint_switch_mode",
        FieldDataType::CcrSetpointSwitchMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_low_setpoint_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        None,
        "ccr_low_setpoint",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_low_setpoint_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        None,
        "ccr_low_setpoint_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_high_setpoint_switch_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        None,
        "ccr_high_setpoint_switch_mode",
        FieldDataType::CcrSetpointSwitchMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_high_setpoint_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        None,
        "ccr_high_setpoint",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_high_setpoint_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        None,
        "ccr_high_setpoint_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_gas_consumption_display_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        None,
        "gas_consumption_display",
        FieldDataType::GasConsumptionRateType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_up_key_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        None,
        "up_key_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_dive_sounds_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 35u8, value)?
    } else {
        value
    };
    data_field_with_info(
        35u8,
        None,
        "dive_sounds",
        FieldDataType::Tone,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_last_stop_multiple_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 36u8, value)?
    } else {
        value
    };
    data_field_with_info(
        36u8,
        None,
        "last_stop_multiple",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_no_fly_time_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37u8, value)?
    } else {
        value
    };
    data_field_with_info(
        37u8,
        None,
        "no_fly_time_mode",
        FieldDataType::NoFlyTimeMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "dive_alarm message definition"]
#[doc = " * depth: Depth setting (m) for depth type alarms"]
#[doc = " * time: Time setting (s) for time type alarms"]
#[doc = " * enabled: Enablement flag"]
#[doc = " * alarm_type: Alarm type setting"]
#[doc = " * sound: Tone and Vibe setting for the alarm"]
#[doc = " * dive_types: Dive types the alarm will trigger on"]
#[doc = " * id: Alarm ID"]
#[doc = " * popup_enabled: Show a visible pop-up for this alarm"]
#[doc = " * trigger_on_descent: Trigger the alarm on descent"]
#[doc = " * trigger_on_ascent: Trigger the alarm on ascent"]
#[doc = " * repeating: Repeat alarm each time threshold is crossed?"]
#[doc = " * speed: Ascent/descent rate (mps) setting for speed type alarms"]
#[doc = " * message_index: Index of the alarm"]
fn dive_alarm_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(dive_alarm_message_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            1u8 => {
                fields.push(dive_alarm_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(dive_alarm_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(dive_alarm_message_alarm_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(dive_alarm_message_sound_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(dive_alarm_message_dive_types_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(dive_alarm_message_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(dive_alarm_message_popup_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(dive_alarm_message_trigger_on_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(dive_alarm_message_trigger_on_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(dive_alarm_message_repeating_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(dive_alarm_message_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "mps",
                    value,
                )?);
            }
            254u8 => {
                fields.push(dive_alarm_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_alarm_message_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "time",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_alarm_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "alarm_type",
        FieldDataType::DiveAlarmType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_sound_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "sound",
        FieldDataType::Tone,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_dive_types_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "dive_types",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_popup_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "popup_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_trigger_on_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "trigger_on_descent",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_trigger_on_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "trigger_on_ascent",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_repeating_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "repeating",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "speed",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "dive_apnea_alarm message definition"]
#[doc = " * depth: Depth setting (m) for depth type alarms"]
#[doc = " * time: Time setting (s) for time type alarms"]
#[doc = " * enabled: Enablement flag"]
#[doc = " * alarm_type: Alarm type setting"]
#[doc = " * sound: Tone and Vibe setting for the alarm."]
#[doc = " * dive_types: Dive types the alarm will trigger on"]
#[doc = " * id: Alarm ID"]
#[doc = " * popup_enabled: Show a visible pop-up for this alarm"]
#[doc = " * trigger_on_descent: Trigger the alarm on descent"]
#[doc = " * trigger_on_ascent: Trigger the alarm on ascent"]
#[doc = " * repeating: Repeat alarm each time threshold is crossed?"]
#[doc = " * speed: Ascent/descent rate (mps) setting for speed type alarms"]
#[doc = " * message_index: Index of the alarm"]
fn dive_apnea_alarm_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(dive_apnea_alarm_message_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            1u8 => {
                fields.push(dive_apnea_alarm_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(dive_apnea_alarm_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(dive_apnea_alarm_message_alarm_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(dive_apnea_alarm_message_sound_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(dive_apnea_alarm_message_dive_types_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(dive_apnea_alarm_message_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(dive_apnea_alarm_message_popup_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(dive_apnea_alarm_message_trigger_on_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(dive_apnea_alarm_message_trigger_on_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(dive_apnea_alarm_message_repeating_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(dive_apnea_alarm_message_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "mps",
                    value,
                )?);
            }
            254u8 => {
                fields.push(dive_apnea_alarm_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_apnea_alarm_message_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "time",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_alarm_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "alarm_type",
        FieldDataType::DiveAlarmType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_sound_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "sound",
        FieldDataType::Tone,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_dive_types_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "dive_types",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_popup_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "popup_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_trigger_on_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "trigger_on_descent",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_trigger_on_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "trigger_on_ascent",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_repeating_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "repeating",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "speed",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "dive_gas message definition"]
fn dive_gas_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(dive_gas_message_helium_content_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            1u8 => {
                fields.push(dive_gas_message_oxygen_content_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            2u8 => {
                fields.push(dive_gas_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(dive_gas_message_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(dive_gas_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_gas_message_helium_content_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "helium_content",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message_oxygen_content_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "oxygen_content",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "status",
        FieldDataType::DiveGasStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "mode",
        FieldDataType::DiveGasMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "goal message definition"]
fn goal_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(goal_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(goal_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(goal_message_start_date_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(goal_message_end_date_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(goal_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(goal_message_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(goal_message_repeat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(goal_message_target_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(goal_message_recurrence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(goal_message_recurrence_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(goal_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(goal_message_source_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(goal_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn goal_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_start_date_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "start_date",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_end_date_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "end_date",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "type",
        FieldDataType::Goal,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_repeat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "repeat",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_target_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "target_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_recurrence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "recurrence",
        FieldDataType::GoalRecurrence,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_recurrence_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "recurrence_value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "source",
        FieldDataType::GoalSource,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "activity message definition"]
#[doc = " * total_timer_time: Exclude pauses"]
#[doc = " * local_timestamp: timestamp epoch expressed in local time, used to convert activity timestamps to local time"]
fn activity_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(activity_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(activity_message_num_sessions_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(activity_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(activity_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(activity_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(activity_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(activity_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(activity_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn activity_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_num_sessions_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "num_sessions",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "type",
        FieldDataType::Activity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "session message definition"]
#[doc = " * event: session"]
#[doc = " * event_type: stop"]
#[doc = " * total_elapsed_time: Time (includes pauses)"]
#[doc = " * total_timer_time: Timer Time (excludes pauses)"]
#[doc = " * avg_speed: total_distance / total_timer_time"]
#[doc = " * avg_heart_rate: average heart rate (excludes pause time)"]
#[doc = " * avg_cadence: total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time"]
#[doc = " * avg_power: total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time"]
#[doc = " * nec_lat: North east corner latitude"]
#[doc = " * nec_long: North east corner longitude"]
#[doc = " * swc_lat: South west corner latitude"]
#[doc = " * swc_long: South west corner longitude"]
#[doc = " * num_lengths: # of lengths of swim pool"]
#[doc = " * num_active_lengths: # of active lengths of swim pool"]
#[doc = " * stroke_count: stroke_type enum used as the index"]
#[doc = " * zone_count: zone number used as the index"]
#[doc = " * avg_fractional_cadence: fractional part of the avg_cadence"]
#[doc = " * max_fractional_cadence: fractional part of the max_cadence"]
#[doc = " * total_fractional_cycles: fractional part of the total_cycles"]
#[doc = " * avg_total_hemoglobin_conc: Avg saturated and unsaturated hemoglobin"]
#[doc = " * min_total_hemoglobin_conc: Min saturated and unsaturated hemoglobin"]
#[doc = " * max_total_hemoglobin_conc: Max saturated and unsaturated hemoglobin"]
#[doc = " * avg_saturated_hemoglobin_percent: Avg percentage of hemoglobin saturated with oxygen"]
#[doc = " * min_saturated_hemoglobin_percent: Min percentage of hemoglobin saturated with oxygen"]
#[doc = " * max_saturated_hemoglobin_percent: Max percentage of hemoglobin saturated with oxygen"]
#[doc = " * sport_profile_name: Sport name from associated sport mesg"]
#[doc = " * time_standing: Total time spend in the standing position"]
#[doc = " * stand_count: Number of transitions to the standing state"]
#[doc = " * avg_left_pco: Average platform center offset Left"]
#[doc = " * avg_right_pco: Average platform center offset Right"]
#[doc = " * avg_left_power_phase: Average left power phase angles. Indexes defined by power_phase_type."]
#[doc = " * avg_left_power_phase_peak: Average left power phase peak angles. Data value indexes defined by power_phase_type."]
#[doc = " * avg_right_power_phase: Average right power phase angles. Data value indexes defined by power_phase_type."]
#[doc = " * avg_right_power_phase_peak: Average right power phase peak angles data value indexes defined by power_phase_type."]
#[doc = " * avg_power_position: Average power by position. Data value indexes defined by rider_position_type."]
#[doc = " * max_power_position: Maximum power by position. Data value indexes defined by rider_position_type."]
#[doc = " * avg_cadence_position: Average cadence by position. Data value indexes defined by rider_position_type."]
#[doc = " * max_cadence_position: Maximum cadence by position. Data value indexes defined by rider_position_type."]
#[doc = " * enhanced_avg_speed: total_distance / total_timer_time"]
#[doc = " * avg_lev_motor_power: lev average motor power during session"]
#[doc = " * max_lev_motor_power: lev maximum motor power during session"]
#[doc = " * lev_battery_consumption: lev battery consumption during session"]
#[doc = " * avg_depth: 0 if above water"]
#[doc = " * max_depth: 0 if above water"]
#[doc = " * surface_interval: Time since end of last dive"]
#[doc = " * total_grit: The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes."]
#[doc = " * total_flow: The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals."]
#[doc = " * avg_grit: The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes."]
#[doc = " * avg_flow: The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals."]
#[doc = " * workout_feel: A 0-100 scale representing how a user felt while performing a workout. Low values are considered feeling bad, while high values are good."]
#[doc = " * workout_rpe: Common Borg CR10 / 0-10 RPE scale, multiplied 10x.. Aggregate score for all workouts in a single session."]
#[doc = " * avg_spo2: Average SPO2 for the monitoring session"]
#[doc = " * avg_stress: Average stress for the monitoring session"]
#[doc = " * sdrr_hrv: Standard deviation of R-R interval (SDRR) - Heart rate variability measure most useful for wellness users."]
#[doc = " * rmssd_hrv: Root mean square successive difference (RMSSD) - Heart rate variability measure most useful for athletes"]
#[doc = " * total_fractional_ascent: fractional part of total_ascent"]
#[doc = " * total_fractional_descent: fractional part of total_descent"]
#[doc = " * timestamp: Sesson end time."]
#[doc = " * message_index: Selected bit is set for the current session."]
fn session_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(session_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(session_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(session_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(session_message_start_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            4u8 => {
                fields.push(session_message_start_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            5u8 => {
                fields.push(session_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(session_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(session_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            8u8 => {
                fields.push(session_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            9u8 => {
                fields.push(session_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            10u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides",
                        value,
                    )?);
                } else if Sport::Walking.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides",
                        value,
                    )?);
                } else if Sport::Cycling.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Swimming.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Rowing.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::StandUpPaddleboarding.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(session_message_total_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "cycles",
                        value,
                    )?);
                }
            }
            11u8 => {
                fields.push(session_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            13u8 => {
                fields.push(session_message_total_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            14u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_avg_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(124u8, enhanced_avg_speed.clone());
                fields.push(session_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_avg_speed,
                )?);
            }
            15u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_max_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(125u8, enhanced_max_speed.clone());
                fields.push(session_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_max_speed,
                )?);
            }
            16u8 => {
                fields.push(session_message_avg_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            17u8 => {
                fields.push(session_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            18u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_avg_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(session_message_avg_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                }
            }
            19u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_max_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(session_message_max_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                }
            }
            20u8 => {
                fields.push(session_message_avg_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            21u8 => {
                fields.push(session_message_max_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            22u8 => {
                fields.push(session_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            23u8 => {
                fields.push(session_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            24u8 => {
                fields.push(session_message_total_training_effect_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            25u8 => {
                fields.push(session_message_first_lap_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            26u8 => {
                fields.push(session_message_num_laps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            27u8 => {
                fields.push(session_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            28u8 => {
                fields.push(session_message_trigger_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            29u8 => {
                fields.push(session_message_nec_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            30u8 => {
                fields.push(session_message_nec_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            31u8 => {
                fields.push(session_message_swc_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            32u8 => {
                fields.push(session_message_swc_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            33u8 => {
                fields.push(session_message_num_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "lengths",
                    value,
                )?);
            }
            34u8 => {
                fields.push(session_message_normalized_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            35u8 => {
                fields.push(session_message_training_stress_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "tss",
                    value,
                )?);
            }
            36u8 => {
                fields.push(session_message_intensity_factor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "if",
                    value,
                )?);
            }
            37u8 => {
                fields.push(session_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            38u8 => {
                fields.push(session_message_end_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            39u8 => {
                fields.push(session_message_end_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            41u8 => {
                fields.push(session_message_avg_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "strokes/lap",
                    value,
                )?);
            }
            42u8 => {
                fields.push(session_message_avg_stroke_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            43u8 => {
                fields.push(session_message_swim_stroke_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "swim_stroke",
                    value,
                )?);
            }
            44u8 => {
                fields.push(session_message_pool_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            45u8 => {
                fields.push(session_message_threshold_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            46u8 => {
                fields.push(session_message_pool_length_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            47u8 => {
                fields.push(session_message_num_active_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "lengths",
                    value,
                )?);
            }
            48u8 => {
                fields.push(session_message_total_work_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "J",
                    value,
                )?);
            }
            49u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_avg_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(126u8, enhanced_avg_altitude.clone());
                fields.push(session_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_avg_altitude,
                )?);
            }
            50u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_max_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(128u8, enhanced_max_altitude.clone());
                fields.push(session_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_max_altitude,
                )?);
            }
            51u8 => {
                fields.push(session_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            52u8 => {
                fields.push(session_message_avg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            53u8 => {
                fields.push(session_message_avg_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            54u8 => {
                fields.push(session_message_avg_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            55u8 => {
                fields.push(session_message_max_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            56u8 => {
                fields.push(session_message_max_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            57u8 => {
                fields.push(session_message_avg_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            58u8 => {
                fields.push(session_message_max_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            59u8 => {
                fields.push(session_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            60u8 => {
                fields.push(session_message_avg_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            61u8 => {
                fields.push(session_message_avg_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            62u8 => {
                fields.push(session_message_max_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            63u8 => {
                fields.push(session_message_max_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            64u8 => {
                fields.push(session_message_min_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            65u8 => {
                fields.push(session_message_time_in_hr_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            66u8 => {
                fields.push(session_message_time_in_speed_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            67u8 => {
                fields.push(session_message_time_in_cadence_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            68u8 => {
                fields.push(session_message_time_in_power_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            69u8 => {
                fields.push(session_message_avg_lap_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            70u8 => {
                fields.push(session_message_best_lap_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            71u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_min_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_min_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(127u8, enhanced_min_altitude.clone());
                fields.push(session_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_min_altitude,
                )?);
            }
            82u8 => {
                fields.push(session_message_player_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            83u8 => {
                fields.push(session_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            84u8 => {
                fields.push(session_message_opponent_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            85u8 => {
                fields.push(session_message_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            86u8 => {
                fields.push(session_message_zone_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            87u8 => {
                fields.push(session_message_max_ball_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            88u8 => {
                fields.push(session_message_avg_ball_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            89u8 => {
                fields.push(session_message_avg_vertical_oscillation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            90u8 => {
                fields.push(session_message_avg_stance_time_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            91u8 => {
                fields.push(session_message_avg_stance_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            92u8 => {
                fields.push(session_message_avg_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            93u8 => {
                fields.push(session_message_max_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            94u8 => {
                fields.push(session_message_total_fractional_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "cycles",
                    value,
                )?);
            }
            95u8 => {
                fields.push(session_message_avg_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            96u8 => {
                fields.push(session_message_min_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            97u8 => {
                fields.push(session_message_max_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            98u8 => {
                fields.push(session_message_avg_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            99u8 => {
                fields.push(session_message_min_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            100u8 => {
                fields.push(session_message_max_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            101u8 => {
                fields.push(session_message_avg_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            102u8 => {
                fields.push(session_message_avg_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            103u8 => {
                fields.push(session_message_avg_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            104u8 => {
                fields.push(session_message_avg_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            105u8 => {
                fields.push(session_message_avg_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            110u8 => {
                fields.push(session_message_sport_profile_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            111u8 => {
                fields.push(session_message_sport_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            112u8 => {
                fields.push(session_message_time_standing_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            113u8 => {
                fields.push(session_message_stand_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            114u8 => {
                fields.push(session_message_avg_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            115u8 => {
                fields.push(session_message_avg_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            116u8 => {
                fields.push(session_message_avg_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            117u8 => {
                fields.push(session_message_avg_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            118u8 => {
                fields.push(session_message_avg_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            119u8 => {
                fields.push(session_message_avg_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            120u8 => {
                fields.push(session_message_avg_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            121u8 => {
                fields.push(session_message_max_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            122u8 => {
                fields.push(session_message_avg_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            123u8 => {
                fields.push(session_message_max_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            124u8 => {
                fields.push(session_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            125u8 => {
                fields.push(session_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            126u8 => {
                fields.push(session_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            127u8 => {
                fields.push(session_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            128u8 => {
                fields.push(session_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            129u8 => {
                fields.push(session_message_avg_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            130u8 => {
                fields.push(session_message_max_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            131u8 => {
                fields.push(session_message_lev_battery_consumption_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            132u8 => {
                fields.push(session_message_avg_vertical_ratio_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            133u8 => {
                fields.push(session_message_avg_stance_time_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            134u8 => {
                fields.push(session_message_avg_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            137u8 => {
                fields.push(session_message_total_anaerobic_training_effect_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            139u8 => {
                fields.push(session_message_avg_vam_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            140u8 => {
                fields.push(session_message_avg_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            141u8 => {
                fields.push(session_message_max_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            142u8 => {
                fields.push(session_message_surface_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            143u8 => {
                fields.push(session_message_start_cns_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            144u8 => {
                fields.push(session_message_end_cns_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            145u8 => {
                fields.push(session_message_start_n2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            146u8 => {
                fields.push(session_message_end_n2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            147u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_avg_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(169u8, enhanced_avg_respiration_rate.clone());
                fields.push(session_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_avg_respiration_rate,
                )?);
            }
            148u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_max_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(170u8, enhanced_max_respiration_rate.clone());
                fields.push(session_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_max_respiration_rate,
                )?);
            }
            149u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_min_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_min_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(180u8, enhanced_min_respiration_rate.clone());
                fields.push(session_message_enhanced_min_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_min_respiration_rate,
                )?);
            }
            150u8 => {
                fields.push(session_message_min_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            155u8 => {
                fields.push(session_message_o2_toxicity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "OTUs",
                    value,
                )?);
            }
            156u8 => {
                fields.push(session_message_dive_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            168u8 => {
                fields.push(session_message_training_load_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    65536f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            169u8 => {
                fields.push(session_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            170u8 => {
                fields.push(session_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            180u8 => {
                fields.push(session_message_enhanced_min_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            181u8 => {
                fields.push(session_message_total_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            182u8 => {
                fields.push(session_message_total_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            183u8 => {
                fields.push(session_message_jump_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            186u8 => {
                fields.push(session_message_avg_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            187u8 => {
                fields.push(session_message_avg_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            192u8 => {
                fields.push(session_message_workout_feel_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            193u8 => {
                fields.push(session_message_workout_rpe_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            194u8 => {
                fields.push(session_message_avg_spo2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            195u8 => {
                fields.push(session_message_avg_stress_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            197u8 => {
                fields.push(session_message_sdrr_hrv_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mS",
                    value,
                )?);
            }
            198u8 => {
                fields.push(session_message_rmssd_hrv_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mS",
                    value,
                )?);
            }
            199u8 => {
                fields.push(session_message_total_fractional_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            200u8 => {
                fields.push(session_message_total_fractional_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            208u8 => {
                fields.push(session_message_avg_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            209u8 => {
                fields.push(session_message_min_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            210u8 => {
                fields.push(session_message_max_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            253u8 => {
                fields.push(session_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(session_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn session_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "start_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "start_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_strides_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strides"
    };
    data_field_with_info(
        10u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strokes"
    };
    data_field_with_info(
        10u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "total_fat_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "max_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        None,
        "avg_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        None,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        None,
        "avg_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "avg_cadence"
    } else {
        "avg_running_cadence"
    };
    data_field_with_info(
        18u8,
        None,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        None,
        "max_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "max_cadence"
    } else {
        "max_running_cadence"
    };
    data_field_with_info(
        19u8,
        None,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        None,
        "avg_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "max_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        None,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_training_effect_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        None,
        "total_training_effect",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_first_lap_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        None,
        "first_lap_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_num_laps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        None,
        "num_laps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        None,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_trigger_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        None,
        "trigger",
        FieldDataType::SessionTrigger,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_nec_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        None,
        "nec_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_nec_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        None,
        "nec_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_swc_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31u8, value)?
    } else {
        value
    };
    data_field_with_info(
        31u8,
        None,
        "swc_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_swc_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        None,
        "swc_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_num_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33u8, value)?
    } else {
        value
    };
    data_field_with_info(
        33u8,
        None,
        "num_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_normalized_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34u8, value)?
    } else {
        value
    };
    data_field_with_info(
        34u8,
        None,
        "normalized_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_training_stress_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 35u8, value)?
    } else {
        value
    };
    data_field_with_info(
        35u8,
        None,
        "training_stress_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_intensity_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 36u8, value)?
    } else {
        value
    };
    data_field_with_info(
        36u8,
        None,
        "intensity_factor",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37u8, value)?
    } else {
        value
    };
    data_field_with_info(
        37u8,
        None,
        "left_right_balance",
        FieldDataType::LeftRightBalance100,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_end_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 38u8, value)?
    } else {
        value
    };
    data_field_with_info(
        38u8,
        None,
        "end_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_end_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        None,
        "end_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41u8, value)?
    } else {
        value
    };
    data_field_with_info(
        41u8,
        None,
        "avg_stroke_count",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stroke_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42u8, value)?
    } else {
        value
    };
    data_field_with_info(
        42u8,
        None,
        "avg_stroke_distance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_swim_stroke_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43u8, value)?
    } else {
        value
    };
    data_field_with_info(
        43u8,
        None,
        "swim_stroke",
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_pool_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44u8, value)?
    } else {
        value
    };
    data_field_with_info(
        44u8,
        None,
        "pool_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_threshold_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45u8, value)?
    } else {
        value
    };
    data_field_with_info(
        45u8,
        None,
        "threshold_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_pool_length_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46u8, value)?
    } else {
        value
    };
    data_field_with_info(
        46u8,
        None,
        "pool_length_unit",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_num_active_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        None,
        "num_active_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_work_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48u8, value)?
    } else {
        value
    };
    data_field_with_info(
        48u8,
        None,
        "total_work",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49u8, value)?
    } else {
        value
    };
    data_field_with_info(
        49u8,
        None,
        "avg_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50u8, value)?
    } else {
        value
    };
    data_field_with_info(
        50u8,
        None,
        "max_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51u8, value)?
    } else {
        value
    };
    data_field_with_info(
        51u8,
        None,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52u8, value)?
    } else {
        value
    };
    data_field_with_info(
        52u8,
        None,
        "avg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53u8, value)?
    } else {
        value
    };
    data_field_with_info(
        53u8,
        None,
        "avg_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54u8, value)?
    } else {
        value
    };
    data_field_with_info(
        54u8,
        None,
        "avg_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55u8, value)?
    } else {
        value
    };
    data_field_with_info(
        55u8,
        None,
        "max_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56u8, value)?
    } else {
        value
    };
    data_field_with_info(
        56u8,
        None,
        "max_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57u8, value)?
    } else {
        value
    };
    data_field_with_info(
        57u8,
        None,
        "avg_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58u8, value)?
    } else {
        value
    };
    data_field_with_info(
        58u8,
        None,
        "max_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59u8, value)?
    } else {
        value
    };
    data_field_with_info(
        59u8,
        None,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 60u8, value)?
    } else {
        value
    };
    data_field_with_info(
        60u8,
        None,
        "avg_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 61u8, value)?
    } else {
        value
    };
    data_field_with_info(
        61u8,
        None,
        "avg_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62u8, value)?
    } else {
        value
    };
    data_field_with_info(
        62u8,
        None,
        "max_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 63u8, value)?
    } else {
        value
    };
    data_field_with_info(
        63u8,
        None,
        "max_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 64u8, value)?
    } else {
        value
    };
    data_field_with_info(
        64u8,
        None,
        "min_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 65u8, value)?
    } else {
        value
    };
    data_field_with_info(
        65u8,
        None,
        "time_in_hr_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 66u8, value)?
    } else {
        value
    };
    data_field_with_info(
        66u8,
        None,
        "time_in_speed_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 67u8, value)?
    } else {
        value
    };
    data_field_with_info(
        67u8,
        None,
        "time_in_cadence_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 68u8, value)?
    } else {
        value
    };
    data_field_with_info(
        68u8,
        None,
        "time_in_power_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_lap_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 69u8, value)?
    } else {
        value
    };
    data_field_with_info(
        69u8,
        None,
        "avg_lap_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_best_lap_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 70u8, value)?
    } else {
        value
    };
    data_field_with_info(
        70u8,
        None,
        "best_lap_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71u8, value)?
    } else {
        value
    };
    data_field_with_info(
        71u8,
        None,
        "min_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_player_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82u8, value)?
    } else {
        value
    };
    data_field_with_info(
        82u8,
        None,
        "player_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83u8, value)?
    } else {
        value
    };
    data_field_with_info(
        83u8,
        None,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_opponent_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84u8, value)?
    } else {
        value
    };
    data_field_with_info(
        84u8,
        None,
        "opponent_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85u8, value)?
    } else {
        value
    };
    data_field_with_info(
        85u8,
        None,
        "stroke_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_zone_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86u8, value)?
    } else {
        value
    };
    data_field_with_info(
        86u8,
        None,
        "zone_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_ball_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 87u8, value)?
    } else {
        value
    };
    data_field_with_info(
        87u8,
        None,
        "max_ball_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_ball_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 88u8, value)?
    } else {
        value
    };
    data_field_with_info(
        88u8,
        None,
        "avg_ball_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_vertical_oscillation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89u8, value)?
    } else {
        value
    };
    data_field_with_info(
        89u8,
        None,
        "avg_vertical_oscillation",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stance_time_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 90u8, value)?
    } else {
        value
    };
    data_field_with_info(
        90u8,
        None,
        "avg_stance_time_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stance_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 91u8, value)?
    } else {
        value
    };
    data_field_with_info(
        91u8,
        None,
        "avg_stance_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 92u8, value)?
    } else {
        value
    };
    data_field_with_info(
        92u8,
        None,
        "avg_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 93u8, value)?
    } else {
        value
    };
    data_field_with_info(
        93u8,
        None,
        "max_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fractional_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94u8, value)?
    } else {
        value
    };
    data_field_with_info(
        94u8,
        None,
        "total_fractional_cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95u8, value)?
    } else {
        value
    };
    data_field_with_info(
        95u8,
        None,
        "avg_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 96u8, value)?
    } else {
        value
    };
    data_field_with_info(
        96u8,
        None,
        "min_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 97u8, value)?
    } else {
        value
    };
    data_field_with_info(
        97u8,
        None,
        "max_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 98u8, value)?
    } else {
        value
    };
    data_field_with_info(
        98u8,
        None,
        "avg_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 99u8, value)?
    } else {
        value
    };
    data_field_with_info(
        99u8,
        None,
        "min_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 100u8, value)?
    } else {
        value
    };
    data_field_with_info(
        100u8,
        None,
        "max_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 101u8, value)?
    } else {
        value
    };
    data_field_with_info(
        101u8,
        None,
        "avg_left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 102u8, value)?
    } else {
        value
    };
    data_field_with_info(
        102u8,
        None,
        "avg_right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 103u8, value)?
    } else {
        value
    };
    data_field_with_info(
        103u8,
        None,
        "avg_left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 104u8, value)?
    } else {
        value
    };
    data_field_with_info(
        104u8,
        None,
        "avg_right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 105u8, value)?
    } else {
        value
    };
    data_field_with_info(
        105u8,
        None,
        "avg_combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sport_profile_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 110u8, value)?
    } else {
        value
    };
    data_field_with_info(
        110u8,
        None,
        "sport_profile_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sport_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 111u8, value)?
    } else {
        value
    };
    data_field_with_info(
        111u8,
        None,
        "sport_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_standing_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 112u8, value)?
    } else {
        value
    };
    data_field_with_info(
        112u8,
        None,
        "time_standing",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_stand_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 113u8, value)?
    } else {
        value
    };
    data_field_with_info(
        113u8,
        None,
        "stand_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 114u8, value)?
    } else {
        value
    };
    data_field_with_info(
        114u8,
        None,
        "avg_left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 115u8, value)?
    } else {
        value
    };
    data_field_with_info(
        115u8,
        None,
        "avg_right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 116u8, value)?
    } else {
        value
    };
    data_field_with_info(
        116u8,
        None,
        "avg_left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 117u8, value)?
    } else {
        value
    };
    data_field_with_info(
        117u8,
        None,
        "avg_left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 118u8, value)?
    } else {
        value
    };
    data_field_with_info(
        118u8,
        None,
        "avg_right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 119u8, value)?
    } else {
        value
    };
    data_field_with_info(
        119u8,
        None,
        "avg_right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 120u8, value)?
    } else {
        value
    };
    data_field_with_info(
        120u8,
        None,
        "avg_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 121u8, value)?
    } else {
        value
    };
    data_field_with_info(
        121u8,
        None,
        "max_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 122u8, value)?
    } else {
        value
    };
    data_field_with_info(
        122u8,
        None,
        "avg_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 123u8, value)?
    } else {
        value
    };
    data_field_with_info(
        123u8,
        None,
        "max_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 124u8, value)?
    } else {
        value
    };
    data_field_with_info(
        124u8,
        None,
        "enhanced_avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 125u8, value)?
    } else {
        value
    };
    data_field_with_info(
        125u8,
        None,
        "enhanced_max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 126u8, value)?
    } else {
        value
    };
    data_field_with_info(
        126u8,
        None,
        "enhanced_avg_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 127u8, value)?
    } else {
        value
    };
    data_field_with_info(
        127u8,
        None,
        "enhanced_min_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 128u8, value)?
    } else {
        value
    };
    data_field_with_info(
        128u8,
        None,
        "enhanced_max_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 129u8, value)?
    } else {
        value
    };
    data_field_with_info(
        129u8,
        None,
        "avg_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 130u8, value)?
    } else {
        value
    };
    data_field_with_info(
        130u8,
        None,
        "max_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_lev_battery_consumption_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 131u8, value)?
    } else {
        value
    };
    data_field_with_info(
        131u8,
        None,
        "lev_battery_consumption",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_vertical_ratio_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 132u8, value)?
    } else {
        value
    };
    data_field_with_info(
        132u8,
        None,
        "avg_vertical_ratio",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stance_time_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 133u8, value)?
    } else {
        value
    };
    data_field_with_info(
        133u8,
        None,
        "avg_stance_time_balance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 134u8, value)?
    } else {
        value
    };
    data_field_with_info(
        134u8,
        None,
        "avg_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_anaerobic_training_effect_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 137u8, value)?
    } else {
        value
    };
    data_field_with_info(
        137u8,
        None,
        "total_anaerobic_training_effect",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_vam_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 139u8, value)?
    } else {
        value
    };
    data_field_with_info(
        139u8,
        None,
        "avg_vam",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 140u8, value)?
    } else {
        value
    };
    data_field_with_info(
        140u8,
        None,
        "avg_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 141u8, value)?
    } else {
        value
    };
    data_field_with_info(
        141u8,
        None,
        "max_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_surface_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 142u8, value)?
    } else {
        value
    };
    data_field_with_info(
        142u8,
        None,
        "surface_interval",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_cns_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 143u8, value)?
    } else {
        value
    };
    data_field_with_info(
        143u8,
        None,
        "start_cns",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_end_cns_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 144u8, value)?
    } else {
        value
    };
    data_field_with_info(
        144u8,
        None,
        "end_cns",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_n2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 145u8, value)?
    } else {
        value
    };
    data_field_with_info(
        145u8,
        None,
        "start_n2",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_end_n2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 146u8, value)?
    } else {
        value
    };
    data_field_with_info(
        146u8,
        None,
        "end_n2",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 147u8, value)?
    } else {
        value
    };
    data_field_with_info(
        147u8,
        None,
        "avg_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 148u8, value)?
    } else {
        value
    };
    data_field_with_info(
        148u8,
        None,
        "max_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 149u8, value)?
    } else {
        value
    };
    data_field_with_info(
        149u8,
        None,
        "min_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 150u8, value)?
    } else {
        value
    };
    data_field_with_info(
        150u8,
        None,
        "min_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_o2_toxicity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 155u8, value)?
    } else {
        value
    };
    data_field_with_info(
        155u8,
        None,
        "o2_toxicity",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_dive_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 156u8, value)?
    } else {
        value
    };
    data_field_with_info(
        156u8,
        None,
        "dive_number",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_training_load_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 168u8, value)?
    } else {
        value
    };
    data_field_with_info(
        168u8,
        None,
        "training_load_peak",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 169u8, value)?
    } else {
        value
    };
    data_field_with_info(
        169u8,
        None,
        "enhanced_avg_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 170u8, value)?
    } else {
        value
    };
    data_field_with_info(
        170u8,
        None,
        "enhanced_max_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_min_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 180u8, value)?
    } else {
        value
    };
    data_field_with_info(
        180u8,
        None,
        "enhanced_min_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 181u8, value)?
    } else {
        value
    };
    data_field_with_info(
        181u8,
        None,
        "total_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 182u8, value)?
    } else {
        value
    };
    data_field_with_info(
        182u8,
        None,
        "total_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_jump_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 183u8, value)?
    } else {
        value
    };
    data_field_with_info(
        183u8,
        None,
        "jump_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 186u8, value)?
    } else {
        value
    };
    data_field_with_info(
        186u8,
        None,
        "avg_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 187u8, value)?
    } else {
        value
    };
    data_field_with_info(
        187u8,
        None,
        "avg_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_workout_feel_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 192u8, value)?
    } else {
        value
    };
    data_field_with_info(
        192u8,
        None,
        "workout_feel",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_workout_rpe_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 193u8, value)?
    } else {
        value
    };
    data_field_with_info(
        193u8,
        None,
        "workout_rpe",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_spo2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 194u8, value)?
    } else {
        value
    };
    data_field_with_info(
        194u8,
        None,
        "avg_spo2",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stress_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 195u8, value)?
    } else {
        value
    };
    data_field_with_info(
        195u8,
        None,
        "avg_stress",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sdrr_hrv_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 197u8, value)?
    } else {
        value
    };
    data_field_with_info(
        197u8,
        None,
        "sdrr_hrv",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_rmssd_hrv_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 198u8, value)?
    } else {
        value
    };
    data_field_with_info(
        198u8,
        None,
        "rmssd_hrv",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fractional_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 199u8, value)?
    } else {
        value
    };
    data_field_with_info(
        199u8,
        None,
        "total_fractional_ascent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fractional_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 200u8, value)?
    } else {
        value
    };
    data_field_with_info(
        200u8,
        None,
        "total_fractional_descent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 208u8, value)?
    } else {
        value
    };
    data_field_with_info(
        208u8,
        None,
        "avg_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 209u8, value)?
    } else {
        value
    };
    data_field_with_info(
        209u8,
        None,
        "min_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 210u8, value)?
    } else {
        value
    };
    data_field_with_info(
        210u8,
        None,
        "max_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "lap message definition"]
#[doc = " * total_elapsed_time: Time (includes pauses)"]
#[doc = " * total_timer_time: Timer Time (excludes pauses)"]
#[doc = " * total_fat_calories: If New Leaf"]
#[doc = " * avg_cadence: total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time"]
#[doc = " * avg_power: total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time"]
#[doc = " * num_lengths: # of lengths of swim pool"]
#[doc = " * num_active_lengths: # of active lengths of swim pool"]
#[doc = " * stroke_count: stroke_type enum used as the index"]
#[doc = " * zone_count: zone number used as the index"]
#[doc = " * avg_fractional_cadence: fractional part of the avg_cadence"]
#[doc = " * max_fractional_cadence: fractional part of the max_cadence"]
#[doc = " * total_fractional_cycles: fractional part of the total_cycles"]
#[doc = " * avg_total_hemoglobin_conc: Avg saturated and unsaturated hemoglobin"]
#[doc = " * min_total_hemoglobin_conc: Min saturated and unsaturated hemoglobin"]
#[doc = " * max_total_hemoglobin_conc: Max saturated and unsaturated hemoglobin"]
#[doc = " * avg_saturated_hemoglobin_percent: Avg percentage of hemoglobin saturated with oxygen"]
#[doc = " * min_saturated_hemoglobin_percent: Min percentage of hemoglobin saturated with oxygen"]
#[doc = " * max_saturated_hemoglobin_percent: Max percentage of hemoglobin saturated with oxygen"]
#[doc = " * time_standing: Total time spent in the standing position"]
#[doc = " * stand_count: Number of transitions to the standing state"]
#[doc = " * avg_left_pco: Average left platform center offset"]
#[doc = " * avg_right_pco: Average right platform center offset"]
#[doc = " * avg_left_power_phase: Average left power phase angles. Data value indexes defined by power_phase_type."]
#[doc = " * avg_left_power_phase_peak: Average left power phase peak angles. Data value indexes defined by power_phase_type."]
#[doc = " * avg_right_power_phase: Average right power phase angles. Data value indexes defined by power_phase_type."]
#[doc = " * avg_right_power_phase_peak: Average right power phase peak angles. Data value indexes defined by power_phase_type."]
#[doc = " * avg_power_position: Average power by position. Data value indexes defined by rider_position_type."]
#[doc = " * max_power_position: Maximum power by position. Data value indexes defined by rider_position_type."]
#[doc = " * avg_cadence_position: Average cadence by position. Data value indexes defined by rider_position_type."]
#[doc = " * max_cadence_position: Maximum cadence by position. Data value indexes defined by rider_position_type."]
#[doc = " * avg_lev_motor_power: lev average motor power during lap"]
#[doc = " * max_lev_motor_power: lev maximum motor power during lap"]
#[doc = " * lev_battery_consumption: lev battery consumption during lap"]
#[doc = " * avg_depth: 0 if above water"]
#[doc = " * max_depth: 0 if above water"]
#[doc = " * total_grit: The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes."]
#[doc = " * total_flow: The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals."]
#[doc = " * avg_grit: The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes."]
#[doc = " * avg_flow: The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals."]
#[doc = " * total_fractional_ascent: fractional part of total_ascent"]
#[doc = " * total_fractional_descent: fractional part of total_descent"]
#[doc = " * timestamp: Lap end time."]
fn lap_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(lap_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(lap_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(lap_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(lap_message_start_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            4u8 => {
                fields.push(lap_message_start_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            5u8 => {
                fields.push(lap_message_end_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            6u8 => {
                fields.push(lap_message_end_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            7u8 => {
                fields.push(lap_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            8u8 => {
                fields.push(lap_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            9u8 => {
                fields.push(lap_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            10u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides",
                        value,
                    )?);
                } else if Sport::Walking.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides",
                        value,
                    )?);
                } else if Sport::Cycling.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Swimming.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Rowing.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::StandUpPaddleboarding.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(lap_message_total_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "cycles",
                        value,
                    )?);
                }
            }
            11u8 => {
                fields.push(lap_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            12u8 => {
                fields.push(lap_message_total_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            13u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_avg_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(110u8, enhanced_avg_speed.clone());
                fields.push(lap_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_avg_speed,
                )?);
            }
            14u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_max_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(111u8, enhanced_max_speed.clone());
                fields.push(lap_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_max_speed,
                )?);
            }
            15u8 => {
                fields.push(lap_message_avg_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            16u8 => {
                fields.push(lap_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            17u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_avg_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(lap_message_avg_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                }
            }
            18u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_max_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(lap_message_max_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                }
            }
            19u8 => {
                fields.push(lap_message_avg_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            20u8 => {
                fields.push(lap_message_max_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            21u8 => {
                fields.push(lap_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            22u8 => {
                fields.push(lap_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            23u8 => {
                fields.push(lap_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            24u8 => {
                fields.push(lap_message_lap_trigger_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            25u8 => {
                fields.push(lap_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            26u8 => {
                fields.push(lap_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            32u8 => {
                fields.push(lap_message_num_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "lengths",
                    value,
                )?);
            }
            33u8 => {
                fields.push(lap_message_normalized_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            34u8 => {
                fields.push(lap_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            35u8 => {
                fields.push(lap_message_first_length_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            37u8 => {
                fields.push(lap_message_avg_stroke_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            38u8 => {
                fields.push(lap_message_swim_stroke_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            39u8 => {
                fields.push(lap_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            40u8 => {
                fields.push(lap_message_num_active_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "lengths",
                    value,
                )?);
            }
            41u8 => {
                fields.push(lap_message_total_work_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "J",
                    value,
                )?);
            }
            42u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_avg_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(112u8, enhanced_avg_altitude.clone());
                fields.push(lap_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_avg_altitude,
                )?);
            }
            43u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_max_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(114u8, enhanced_max_altitude.clone());
                fields.push(lap_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_max_altitude,
                )?);
            }
            44u8 => {
                fields.push(lap_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            45u8 => {
                fields.push(lap_message_avg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            46u8 => {
                fields.push(lap_message_avg_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            47u8 => {
                fields.push(lap_message_avg_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            48u8 => {
                fields.push(lap_message_max_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            49u8 => {
                fields.push(lap_message_max_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            50u8 => {
                fields.push(lap_message_avg_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            51u8 => {
                fields.push(lap_message_max_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            52u8 => {
                fields.push(lap_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            53u8 => {
                fields.push(lap_message_avg_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            54u8 => {
                fields.push(lap_message_avg_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            55u8 => {
                fields.push(lap_message_max_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            56u8 => {
                fields.push(lap_message_max_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            57u8 => {
                fields.push(lap_message_time_in_hr_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            58u8 => {
                fields.push(lap_message_time_in_speed_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            59u8 => {
                fields.push(lap_message_time_in_cadence_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            60u8 => {
                fields.push(lap_message_time_in_power_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            61u8 => {
                fields.push(lap_message_repetition_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            62u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_min_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_min_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(113u8, enhanced_min_altitude.clone());
                fields.push(lap_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_min_altitude,
                )?);
            }
            63u8 => {
                fields.push(lap_message_min_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            71u8 => {
                fields.push(lap_message_wkt_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            74u8 => {
                fields.push(lap_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            75u8 => {
                fields.push(lap_message_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            76u8 => {
                fields.push(lap_message_zone_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            77u8 => {
                fields.push(lap_message_avg_vertical_oscillation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            78u8 => {
                fields.push(lap_message_avg_stance_time_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            79u8 => {
                fields.push(lap_message_avg_stance_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            80u8 => {
                fields.push(lap_message_avg_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            81u8 => {
                fields.push(lap_message_max_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            82u8 => {
                fields.push(lap_message_total_fractional_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "cycles",
                    value,
                )?);
            }
            83u8 => {
                fields.push(lap_message_player_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            84u8 => {
                fields.push(lap_message_avg_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            85u8 => {
                fields.push(lap_message_min_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            86u8 => {
                fields.push(lap_message_max_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            87u8 => {
                fields.push(lap_message_avg_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            88u8 => {
                fields.push(lap_message_min_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            89u8 => {
                fields.push(lap_message_max_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            91u8 => {
                fields.push(lap_message_avg_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            92u8 => {
                fields.push(lap_message_avg_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            93u8 => {
                fields.push(lap_message_avg_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            94u8 => {
                fields.push(lap_message_avg_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            95u8 => {
                fields.push(lap_message_avg_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            98u8 => {
                fields.push(lap_message_time_standing_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            99u8 => {
                fields.push(lap_message_stand_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            100u8 => {
                fields.push(lap_message_avg_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            101u8 => {
                fields.push(lap_message_avg_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            102u8 => {
                fields.push(lap_message_avg_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            103u8 => {
                fields.push(lap_message_avg_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            104u8 => {
                fields.push(lap_message_avg_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            105u8 => {
                fields.push(lap_message_avg_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            106u8 => {
                fields.push(lap_message_avg_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            107u8 => {
                fields.push(lap_message_max_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            108u8 => {
                fields.push(lap_message_avg_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            109u8 => {
                fields.push(lap_message_max_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            110u8 => {
                fields.push(lap_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            111u8 => {
                fields.push(lap_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            112u8 => {
                fields.push(lap_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            113u8 => {
                fields.push(lap_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            114u8 => {
                fields.push(lap_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            115u8 => {
                fields.push(lap_message_avg_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            116u8 => {
                fields.push(lap_message_max_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            117u8 => {
                fields.push(lap_message_lev_battery_consumption_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            118u8 => {
                fields.push(lap_message_avg_vertical_ratio_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            119u8 => {
                fields.push(lap_message_avg_stance_time_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            120u8 => {
                fields.push(lap_message_avg_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            121u8 => {
                fields.push(lap_message_avg_vam_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            122u8 => {
                fields.push(lap_message_avg_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            123u8 => {
                fields.push(lap_message_max_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            124u8 => {
                fields.push(lap_message_min_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            136u8 => {
                fields.push(lap_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            137u8 => {
                fields.push(lap_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            147u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_avg_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(136u8, enhanced_avg_respiration_rate.clone());
                fields.push(lap_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_avg_respiration_rate,
                )?);
            }
            148u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_max_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(137u8, enhanced_max_respiration_rate.clone());
                fields.push(lap_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_max_respiration_rate,
                )?);
            }
            149u8 => {
                fields.push(lap_message_total_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            150u8 => {
                fields.push(lap_message_total_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            151u8 => {
                fields.push(lap_message_jump_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            153u8 => {
                fields.push(lap_message_avg_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            154u8 => {
                fields.push(lap_message_avg_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            156u8 => {
                fields.push(lap_message_total_fractional_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            157u8 => {
                fields.push(lap_message_total_fractional_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            158u8 => {
                fields.push(lap_message_avg_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            159u8 => {
                fields.push(lap_message_min_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            160u8 => {
                fields.push(lap_message_max_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            253u8 => {
                fields.push(lap_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(lap_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn lap_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_start_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "start_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_start_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "start_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_end_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "end_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_end_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "end_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_strides_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strides"
    };
    data_field_with_info(
        10u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strokes"
    };
    data_field_with_info(
        10u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "total_fat_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "max_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "avg_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        None,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        None,
        "avg_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "avg_cadence"
    } else {
        "avg_running_cadence"
    };
    data_field_with_info(
        17u8,
        None,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        None,
        "max_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "max_cadence"
    } else {
        "max_running_cadence"
    };
    data_field_with_info(
        18u8,
        None,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        None,
        "avg_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        None,
        "max_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        None,
        "intensity",
        FieldDataType::Intensity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_lap_trigger_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        None,
        "lap_trigger",
        FieldDataType::LapTrigger,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        None,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_num_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        None,
        "num_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_normalized_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33u8, value)?
    } else {
        value
    };
    data_field_with_info(
        33u8,
        None,
        "normalized_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34u8, value)?
    } else {
        value
    };
    data_field_with_info(
        34u8,
        None,
        "left_right_balance",
        FieldDataType::LeftRightBalance100,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_first_length_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 35u8, value)?
    } else {
        value
    };
    data_field_with_info(
        35u8,
        None,
        "first_length_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stroke_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37u8, value)?
    } else {
        value
    };
    data_field_with_info(
        37u8,
        None,
        "avg_stroke_distance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_swim_stroke_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 38u8, value)?
    } else {
        value
    };
    data_field_with_info(
        38u8,
        None,
        "swim_stroke",
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        None,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_num_active_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40u8, value)?
    } else {
        value
    };
    data_field_with_info(
        40u8,
        None,
        "num_active_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_work_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41u8, value)?
    } else {
        value
    };
    data_field_with_info(
        41u8,
        None,
        "total_work",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42u8, value)?
    } else {
        value
    };
    data_field_with_info(
        42u8,
        None,
        "avg_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43u8, value)?
    } else {
        value
    };
    data_field_with_info(
        43u8,
        None,
        "max_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44u8, value)?
    } else {
        value
    };
    data_field_with_info(
        44u8,
        None,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45u8, value)?
    } else {
        value
    };
    data_field_with_info(
        45u8,
        None,
        "avg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46u8, value)?
    } else {
        value
    };
    data_field_with_info(
        46u8,
        None,
        "avg_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        None,
        "avg_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48u8, value)?
    } else {
        value
    };
    data_field_with_info(
        48u8,
        None,
        "max_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49u8, value)?
    } else {
        value
    };
    data_field_with_info(
        49u8,
        None,
        "max_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50u8, value)?
    } else {
        value
    };
    data_field_with_info(
        50u8,
        None,
        "avg_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51u8, value)?
    } else {
        value
    };
    data_field_with_info(
        51u8,
        None,
        "max_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52u8, value)?
    } else {
        value
    };
    data_field_with_info(
        52u8,
        None,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53u8, value)?
    } else {
        value
    };
    data_field_with_info(
        53u8,
        None,
        "avg_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54u8, value)?
    } else {
        value
    };
    data_field_with_info(
        54u8,
        None,
        "avg_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55u8, value)?
    } else {
        value
    };
    data_field_with_info(
        55u8,
        None,
        "max_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56u8, value)?
    } else {
        value
    };
    data_field_with_info(
        56u8,
        None,
        "max_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57u8, value)?
    } else {
        value
    };
    data_field_with_info(
        57u8,
        None,
        "time_in_hr_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58u8, value)?
    } else {
        value
    };
    data_field_with_info(
        58u8,
        None,
        "time_in_speed_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59u8, value)?
    } else {
        value
    };
    data_field_with_info(
        59u8,
        None,
        "time_in_cadence_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 60u8, value)?
    } else {
        value
    };
    data_field_with_info(
        60u8,
        None,
        "time_in_power_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_repetition_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 61u8, value)?
    } else {
        value
    };
    data_field_with_info(
        61u8,
        None,
        "repetition_num",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62u8, value)?
    } else {
        value
    };
    data_field_with_info(
        62u8,
        None,
        "min_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 63u8, value)?
    } else {
        value
    };
    data_field_with_info(
        63u8,
        None,
        "min_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_wkt_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71u8, value)?
    } else {
        value
    };
    data_field_with_info(
        71u8,
        None,
        "wkt_step_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 74u8, value)?
    } else {
        value
    };
    data_field_with_info(
        74u8,
        None,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 75u8, value)?
    } else {
        value
    };
    data_field_with_info(
        75u8,
        None,
        "stroke_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_zone_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 76u8, value)?
    } else {
        value
    };
    data_field_with_info(
        76u8,
        None,
        "zone_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_vertical_oscillation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 77u8, value)?
    } else {
        value
    };
    data_field_with_info(
        77u8,
        None,
        "avg_vertical_oscillation",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stance_time_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 78u8, value)?
    } else {
        value
    };
    data_field_with_info(
        78u8,
        None,
        "avg_stance_time_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stance_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 79u8, value)?
    } else {
        value
    };
    data_field_with_info(
        79u8,
        None,
        "avg_stance_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 80u8, value)?
    } else {
        value
    };
    data_field_with_info(
        80u8,
        None,
        "avg_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 81u8, value)?
    } else {
        value
    };
    data_field_with_info(
        81u8,
        None,
        "max_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fractional_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82u8, value)?
    } else {
        value
    };
    data_field_with_info(
        82u8,
        None,
        "total_fractional_cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_player_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83u8, value)?
    } else {
        value
    };
    data_field_with_info(
        83u8,
        None,
        "player_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84u8, value)?
    } else {
        value
    };
    data_field_with_info(
        84u8,
        None,
        "avg_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85u8, value)?
    } else {
        value
    };
    data_field_with_info(
        85u8,
        None,
        "min_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86u8, value)?
    } else {
        value
    };
    data_field_with_info(
        86u8,
        None,
        "max_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 87u8, value)?
    } else {
        value
    };
    data_field_with_info(
        87u8,
        None,
        "avg_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 88u8, value)?
    } else {
        value
    };
    data_field_with_info(
        88u8,
        None,
        "min_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89u8, value)?
    } else {
        value
    };
    data_field_with_info(
        89u8,
        None,
        "max_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 91u8, value)?
    } else {
        value
    };
    data_field_with_info(
        91u8,
        None,
        "avg_left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 92u8, value)?
    } else {
        value
    };
    data_field_with_info(
        92u8,
        None,
        "avg_right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 93u8, value)?
    } else {
        value
    };
    data_field_with_info(
        93u8,
        None,
        "avg_left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94u8, value)?
    } else {
        value
    };
    data_field_with_info(
        94u8,
        None,
        "avg_right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95u8, value)?
    } else {
        value
    };
    data_field_with_info(
        95u8,
        None,
        "avg_combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_standing_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 98u8, value)?
    } else {
        value
    };
    data_field_with_info(
        98u8,
        None,
        "time_standing",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_stand_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 99u8, value)?
    } else {
        value
    };
    data_field_with_info(
        99u8,
        None,
        "stand_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 100u8, value)?
    } else {
        value
    };
    data_field_with_info(
        100u8,
        None,
        "avg_left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 101u8, value)?
    } else {
        value
    };
    data_field_with_info(
        101u8,
        None,
        "avg_right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 102u8, value)?
    } else {
        value
    };
    data_field_with_info(
        102u8,
        None,
        "avg_left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 103u8, value)?
    } else {
        value
    };
    data_field_with_info(
        103u8,
        None,
        "avg_left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 104u8, value)?
    } else {
        value
    };
    data_field_with_info(
        104u8,
        None,
        "avg_right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 105u8, value)?
    } else {
        value
    };
    data_field_with_info(
        105u8,
        None,
        "avg_right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 106u8, value)?
    } else {
        value
    };
    data_field_with_info(
        106u8,
        None,
        "avg_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 107u8, value)?
    } else {
        value
    };
    data_field_with_info(
        107u8,
        None,
        "max_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 108u8, value)?
    } else {
        value
    };
    data_field_with_info(
        108u8,
        None,
        "avg_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 109u8, value)?
    } else {
        value
    };
    data_field_with_info(
        109u8,
        None,
        "max_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 110u8, value)?
    } else {
        value
    };
    data_field_with_info(
        110u8,
        None,
        "enhanced_avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 111u8, value)?
    } else {
        value
    };
    data_field_with_info(
        111u8,
        None,
        "enhanced_max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 112u8, value)?
    } else {
        value
    };
    data_field_with_info(
        112u8,
        None,
        "enhanced_avg_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 113u8, value)?
    } else {
        value
    };
    data_field_with_info(
        113u8,
        None,
        "enhanced_min_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 114u8, value)?
    } else {
        value
    };
    data_field_with_info(
        114u8,
        None,
        "enhanced_max_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 115u8, value)?
    } else {
        value
    };
    data_field_with_info(
        115u8,
        None,
        "avg_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 116u8, value)?
    } else {
        value
    };
    data_field_with_info(
        116u8,
        None,
        "max_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_lev_battery_consumption_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 117u8, value)?
    } else {
        value
    };
    data_field_with_info(
        117u8,
        None,
        "lev_battery_consumption",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_vertical_ratio_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 118u8, value)?
    } else {
        value
    };
    data_field_with_info(
        118u8,
        None,
        "avg_vertical_ratio",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stance_time_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 119u8, value)?
    } else {
        value
    };
    data_field_with_info(
        119u8,
        None,
        "avg_stance_time_balance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 120u8, value)?
    } else {
        value
    };
    data_field_with_info(
        120u8,
        None,
        "avg_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_vam_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 121u8, value)?
    } else {
        value
    };
    data_field_with_info(
        121u8,
        None,
        "avg_vam",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 122u8, value)?
    } else {
        value
    };
    data_field_with_info(
        122u8,
        None,
        "avg_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 123u8, value)?
    } else {
        value
    };
    data_field_with_info(
        123u8,
        None,
        "max_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 124u8, value)?
    } else {
        value
    };
    data_field_with_info(
        124u8,
        None,
        "min_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 136u8, value)?
    } else {
        value
    };
    data_field_with_info(
        136u8,
        None,
        "enhanced_avg_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 137u8, value)?
    } else {
        value
    };
    data_field_with_info(
        137u8,
        None,
        "enhanced_max_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 147u8, value)?
    } else {
        value
    };
    data_field_with_info(
        147u8,
        None,
        "avg_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 148u8, value)?
    } else {
        value
    };
    data_field_with_info(
        148u8,
        None,
        "max_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 149u8, value)?
    } else {
        value
    };
    data_field_with_info(
        149u8,
        None,
        "total_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 150u8, value)?
    } else {
        value
    };
    data_field_with_info(
        150u8,
        None,
        "total_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_jump_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 151u8, value)?
    } else {
        value
    };
    data_field_with_info(
        151u8,
        None,
        "jump_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 153u8, value)?
    } else {
        value
    };
    data_field_with_info(
        153u8,
        None,
        "avg_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 154u8, value)?
    } else {
        value
    };
    data_field_with_info(
        154u8,
        None,
        "avg_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fractional_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 156u8, value)?
    } else {
        value
    };
    data_field_with_info(
        156u8,
        None,
        "total_fractional_ascent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fractional_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 157u8, value)?
    } else {
        value
    };
    data_field_with_info(
        157u8,
        None,
        "total_fractional_descent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 158u8, value)?
    } else {
        value
    };
    data_field_with_info(
        158u8,
        None,
        "avg_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 159u8, value)?
    } else {
        value
    };
    data_field_with_info(
        159u8,
        None,
        "min_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 160u8, value)?
    } else {
        value
    };
    data_field_with_info(
        160u8,
        None,
        "max_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "length message definition"]
#[doc = " * stroke_count: stroke_type enum used as the index"]
#[doc = " * zone_count: zone number used as the index"]
fn length_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(length_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(length_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(length_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(length_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(length_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(length_message_total_strokes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "strokes",
                    value,
                )?);
            }
            6u8 => {
                fields.push(length_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            7u8 => {
                fields.push(length_message_swim_stroke_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "swim_stroke",
                    value,
                )?);
            }
            9u8 => {
                fields.push(length_message_avg_swimming_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "strokes/min",
                    value,
                )?);
            }
            10u8 => {
                fields.push(length_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(length_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            12u8 => {
                fields.push(length_message_length_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            18u8 => {
                fields.push(length_message_player_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            19u8 => {
                fields.push(length_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            20u8 => {
                fields.push(length_message_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            21u8 => {
                fields.push(length_message_zone_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            22u8 => {
                fields.push(length_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            23u8 => {
                fields.push(length_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            24u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(length_message_avg_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(22u8, enhanced_avg_respiration_rate.clone());
                fields.push(length_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_avg_respiration_rate,
                )?);
            }
            25u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(length_message_max_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(23u8, enhanced_max_respiration_rate.clone());
                fields.push(length_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_max_respiration_rate,
                )?);
            }
            253u8 => {
                fields.push(length_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(length_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn length_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "total_strokes",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_swim_stroke_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "swim_stroke",
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_avg_swimming_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "avg_swimming_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_length_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "length_type",
        FieldDataType::LengthType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_player_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        None,
        "player_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        None,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        None,
        "stroke_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_zone_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "zone_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_enhanced_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "enhanced_avg_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_enhanced_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        None,
        "enhanced_max_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        None,
        "avg_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        None,
        "max_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "record message definition"]
#[doc = " * resistance: Relative. 0 is none 254 is Max."]
#[doc = " * speed_1s: Speed at 1s intervals. Timestamp field indicates time of last array element."]
#[doc = " * cadence256: Log cadence and fractional cadence for backwards compatability"]
#[doc = " * total_hemoglobin_conc: Total saturated and unsaturated hemoglobin"]
#[doc = " * total_hemoglobin_conc_min: Min saturated and unsaturated hemoglobin"]
#[doc = " * total_hemoglobin_conc_max: Max saturated and unsaturated hemoglobin"]
#[doc = " * saturated_hemoglobin_percent: Percentage of hemoglobin saturated with oxygen"]
#[doc = " * saturated_hemoglobin_percent_min: Min percentage of hemoglobin saturated with oxygen"]
#[doc = " * saturated_hemoglobin_percent_max: Max percentage of hemoglobin saturated with oxygen"]
#[doc = " * left_pco: Left platform center offset"]
#[doc = " * right_pco: Right platform center offset"]
#[doc = " * left_power_phase: Left power phase angles. Data value indexes defined by power_phase_type."]
#[doc = " * left_power_phase_peak: Left power phase peak angles. Data value indexes defined by power_phase_type."]
#[doc = " * right_power_phase: Right power phase angles. Data value indexes defined by power_phase_type."]
#[doc = " * right_power_phase_peak: Right power phase peak angles. Data value indexes defined by power_phase_type."]
#[doc = " * battery_soc: lev battery state of charge"]
#[doc = " * motor_power: lev motor power"]
#[doc = " * cycle_length16: Supports larger cycle sizes needed for paddlesports. Max cycle size: 655.35"]
#[doc = " * absolute_pressure: Includes atmospheric pressure"]
#[doc = " * depth: 0 if above water"]
#[doc = " * next_stop_depth: 0 if above water"]
#[doc = " * grit: The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes."]
#[doc = " * flow: The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals."]
#[doc = " * current_stress: Current Stress value"]
#[doc = " * pressure_sac: Pressure-based surface air consumption"]
#[doc = " * volume_sac: Volumetric surface air consumption"]
#[doc = " * rmv: Respiratory minute volume"]
#[doc = " * po2: Current partial pressure of oxygen"]
fn record_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(record_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            1u8 => {
                fields.push(record_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            2u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_altitude) = extract_component(&input, 0usize, 16);
                data_map.insert(78u8, enhanced_altitude.clone());
                fields.push(record_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_altitude,
                )?);
            }
            3u8 => {
                fields.push(record_message_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            4u8 => {
                fields.push(record_message_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            5u8 => {
                fields.push(record_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            6u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(73u8, enhanced_speed.clone());
                fields.push(record_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_speed,
                )?);
            }
            7u8 => {
                fields.push(record_message_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            8u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_compressed_speed_distance_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "m/s,m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), speed) = extract_component(&input, 0usize, 12);
                let ((input, offset), distance) = extract_component(input, offset, 12);
                data_map.insert(6u8, speed.clone());
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100f64,
                        0f64,
                        "m/s",
                        speed.clone(),
                    )?);
                }
                let input = speed.to_ne_bytes();
                let ((input, offset), enhanced_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(73u8, enhanced_speed.clone());
                fields.push(record_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s",
                    enhanced_speed,
                )?);
                data_map.insert(5u8, distance.clone());
                fields.push(record_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    16f64,
                    0f64,
                    "m",
                    distance,
                )?);
            }
            9u8 => {
                fields.push(record_message_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            10u8 => {
                fields.push(record_message_resistance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(record_message_time_from_course_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            12u8 => {
                fields.push(record_message_cycle_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            13u8 => {
                fields.push(record_message_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            17u8 => {
                fields.push(record_message_speed_1s_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    16f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            18u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        true,
                        1f64,
                        0f64,
                        "cycles",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), total_cycles) = extract_component(&input, 0usize, 8);
                data_map.insert(19u8, total_cycles.clone());
                fields.push(record_message_total_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    1f64,
                    0f64,
                    "cycles",
                    total_cycles,
                )?);
            }
            19u8 => {
                fields.push(record_message_total_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "cycles",
                    value,
                )?);
            }
            28u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_compressed_accumulated_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        true,
                        1f64,
                        0f64,
                        "watts",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), accumulated_power) = extract_component(&input, 0usize, 16);
                data_map.insert(29u8, accumulated_power.clone());
                fields.push(record_message_accumulated_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    1f64,
                    0f64,
                    "watts",
                    accumulated_power,
                )?);
            }
            29u8 => {
                fields.push(record_message_accumulated_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            30u8 => {
                fields.push(record_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            31u8 => {
                fields.push(record_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            32u8 => {
                fields.push(record_message_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            33u8 => {
                fields.push(record_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            39u8 => {
                fields.push(record_message_vertical_oscillation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            40u8 => {
                fields.push(record_message_stance_time_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            41u8 => {
                fields.push(record_message_stance_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            42u8 => {
                fields.push(record_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            43u8 => {
                fields.push(record_message_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            44u8 => {
                fields.push(record_message_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            45u8 => {
                fields.push(record_message_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            46u8 => {
                fields.push(record_message_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            47u8 => {
                fields.push(record_message_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            48u8 => {
                fields.push(record_message_time128_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            49u8 => {
                fields.push(record_message_stroke_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            50u8 => {
                fields.push(record_message_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            51u8 => {
                fields.push(record_message_ball_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            52u8 => {
                fields.push(record_message_cadence256_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            53u8 => {
                fields.push(record_message_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            54u8 => {
                fields.push(record_message_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            55u8 => {
                fields.push(record_message_total_hemoglobin_conc_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            56u8 => {
                fields.push(record_message_total_hemoglobin_conc_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            57u8 => {
                fields.push(record_message_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            58u8 => {
                fields.push(record_message_saturated_hemoglobin_percent_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            59u8 => {
                fields.push(record_message_saturated_hemoglobin_percent_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            62u8 => {
                fields.push(record_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            67u8 => {
                fields.push(record_message_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            68u8 => {
                fields.push(record_message_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            69u8 => {
                fields.push(record_message_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            70u8 => {
                fields.push(record_message_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            71u8 => {
                fields.push(record_message_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            72u8 => {
                fields.push(record_message_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            73u8 => {
                fields.push(record_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            78u8 => {
                fields.push(record_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            81u8 => {
                fields.push(record_message_battery_soc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            82u8 => {
                fields.push(record_message_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            83u8 => {
                fields.push(record_message_vertical_ratio_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            84u8 => {
                fields.push(record_message_stance_time_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            85u8 => {
                fields.push(record_message_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            87u8 => {
                fields.push(record_message_cycle_length16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            91u8 => {
                fields.push(record_message_absolute_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Pa",
                    value,
                )?);
            }
            92u8 => {
                fields.push(record_message_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            93u8 => {
                fields.push(record_message_next_stop_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            94u8 => {
                fields.push(record_message_next_stop_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            95u8 => {
                fields.push(record_message_time_to_surface_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            96u8 => {
                fields.push(record_message_ndl_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            97u8 => {
                fields.push(record_message_cns_load_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            98u8 => {
                fields.push(record_message_n2_load_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            99u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(108u8, enhanced_respiration_rate.clone());
                fields.push(record_message_enhanced_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    enhanced_respiration_rate,
                )?);
            }
            108u8 => {
                fields.push(record_message_enhanced_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            114u8 => {
                fields.push(record_message_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            115u8 => {
                fields.push(record_message_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            116u8 => {
                fields.push(record_message_current_stress_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            117u8 => {
                fields.push(record_message_ebike_travel_range_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "km",
                    value,
                )?);
            }
            118u8 => {
                fields.push(record_message_ebike_battery_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            119u8 => {
                fields.push(record_message_ebike_assist_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "depends on sensor",
                    value,
                )?);
            }
            120u8 => {
                fields.push(record_message_ebike_assist_level_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            123u8 => {
                fields.push(record_message_air_time_remaining_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            124u8 => {
                fields.push(record_message_pressure_sac_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "bar/min",
                    value,
                )?);
            }
            125u8 => {
                fields.push(record_message_volume_sac_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "L/min",
                    value,
                )?);
            }
            126u8 => {
                fields.push(record_message_rmv_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "L/min",
                    value,
                )?);
            }
            127u8 => {
                fields.push(record_message_ascent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            129u8 => {
                fields.push(record_message_po2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            139u8 => {
                fields.push(record_message_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            253u8 => {
                fields.push(record_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn record_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_compressed_speed_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "compressed_speed_distance",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_resistance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "resistance",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_time_from_course_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "time_from_course",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cycle_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "cycle_length",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_speed_1s_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        None,
        "speed_1s",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        None,
        "cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        None,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_compressed_accumulated_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        None,
        "compressed_accumulated_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_accumulated_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        None,
        "accumulated_power",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        None,
        "left_right_balance",
        FieldDataType::LeftRightBalance,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31u8, value)?
    } else {
        value
    };
    data_field_with_info(
        31u8,
        None,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        None,
        "vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33u8, value)?
    } else {
        value
    };
    data_field_with_info(
        33u8,
        None,
        "calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_vertical_oscillation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        None,
        "vertical_oscillation",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stance_time_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40u8, value)?
    } else {
        value
    };
    data_field_with_info(
        40u8,
        None,
        "stance_time_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stance_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41u8, value)?
    } else {
        value
    };
    data_field_with_info(
        41u8,
        None,
        "stance_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_activity_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42u8, value)?
    } else {
        value
    };
    data_field_with_info(
        42u8,
        None,
        "activity_type",
        FieldDataType::ActivityType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43u8, value)?
    } else {
        value
    };
    data_field_with_info(
        43u8,
        None,
        "left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44u8, value)?
    } else {
        value
    };
    data_field_with_info(
        44u8,
        None,
        "right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45u8, value)?
    } else {
        value
    };
    data_field_with_info(
        45u8,
        None,
        "left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46u8, value)?
    } else {
        value
    };
    data_field_with_info(
        46u8,
        None,
        "right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        None,
        "combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_time128_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48u8, value)?
    } else {
        value
    };
    data_field_with_info(
        48u8,
        None,
        "time128",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stroke_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49u8, value)?
    } else {
        value
    };
    data_field_with_info(
        49u8,
        None,
        "stroke_type",
        FieldDataType::StrokeType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50u8, value)?
    } else {
        value
    };
    data_field_with_info(
        50u8,
        None,
        "zone",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ball_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51u8, value)?
    } else {
        value
    };
    data_field_with_info(
        51u8,
        None,
        "ball_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cadence256_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52u8, value)?
    } else {
        value
    };
    data_field_with_info(
        52u8,
        None,
        "cadence256",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53u8, value)?
    } else {
        value
    };
    data_field_with_info(
        53u8,
        None,
        "fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54u8, value)?
    } else {
        value
    };
    data_field_with_info(
        54u8,
        None,
        "total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_hemoglobin_conc_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55u8, value)?
    } else {
        value
    };
    data_field_with_info(
        55u8,
        None,
        "total_hemoglobin_conc_min",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_hemoglobin_conc_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56u8, value)?
    } else {
        value
    };
    data_field_with_info(
        56u8,
        None,
        "total_hemoglobin_conc_max",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57u8, value)?
    } else {
        value
    };
    data_field_with_info(
        57u8,
        None,
        "saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_saturated_hemoglobin_percent_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58u8, value)?
    } else {
        value
    };
    data_field_with_info(
        58u8,
        None,
        "saturated_hemoglobin_percent_min",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_saturated_hemoglobin_percent_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59u8, value)?
    } else {
        value
    };
    data_field_with_info(
        59u8,
        None,
        "saturated_hemoglobin_percent_max",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62u8, value)?
    } else {
        value
    };
    data_field_with_info(
        62u8,
        None,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 67u8, value)?
    } else {
        value
    };
    data_field_with_info(
        67u8,
        None,
        "left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 68u8, value)?
    } else {
        value
    };
    data_field_with_info(
        68u8,
        None,
        "right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 69u8, value)?
    } else {
        value
    };
    data_field_with_info(
        69u8,
        None,
        "left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 70u8, value)?
    } else {
        value
    };
    data_field_with_info(
        70u8,
        None,
        "left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71u8, value)?
    } else {
        value
    };
    data_field_with_info(
        71u8,
        None,
        "right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 72u8, value)?
    } else {
        value
    };
    data_field_with_info(
        72u8,
        None,
        "right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_enhanced_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 73u8, value)?
    } else {
        value
    };
    data_field_with_info(
        73u8,
        None,
        "enhanced_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_enhanced_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 78u8, value)?
    } else {
        value
    };
    data_field_with_info(
        78u8,
        None,
        "enhanced_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_battery_soc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 81u8, value)?
    } else {
        value
    };
    data_field_with_info(
        81u8,
        None,
        "battery_soc",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82u8, value)?
    } else {
        value
    };
    data_field_with_info(
        82u8,
        None,
        "motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_vertical_ratio_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83u8, value)?
    } else {
        value
    };
    data_field_with_info(
        83u8,
        None,
        "vertical_ratio",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stance_time_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84u8, value)?
    } else {
        value
    };
    data_field_with_info(
        84u8,
        None,
        "stance_time_balance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85u8, value)?
    } else {
        value
    };
    data_field_with_info(
        85u8,
        None,
        "step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cycle_length16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 87u8, value)?
    } else {
        value
    };
    data_field_with_info(
        87u8,
        None,
        "cycle_length16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_absolute_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 91u8, value)?
    } else {
        value
    };
    data_field_with_info(
        91u8,
        None,
        "absolute_pressure",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 92u8, value)?
    } else {
        value
    };
    data_field_with_info(
        92u8,
        None,
        "depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_next_stop_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 93u8, value)?
    } else {
        value
    };
    data_field_with_info(
        93u8,
        None,
        "next_stop_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_next_stop_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94u8, value)?
    } else {
        value
    };
    data_field_with_info(
        94u8,
        None,
        "next_stop_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_time_to_surface_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95u8, value)?
    } else {
        value
    };
    data_field_with_info(
        95u8,
        None,
        "time_to_surface",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ndl_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 96u8, value)?
    } else {
        value
    };
    data_field_with_info(
        96u8,
        None,
        "ndl_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cns_load_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 97u8, value)?
    } else {
        value
    };
    data_field_with_info(
        97u8,
        None,
        "cns_load",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_n2_load_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 98u8, value)?
    } else {
        value
    };
    data_field_with_info(
        98u8,
        None,
        "n2_load",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 99u8, value)?
    } else {
        value
    };
    data_field_with_info(
        99u8,
        None,
        "respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_enhanced_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 108u8, value)?
    } else {
        value
    };
    data_field_with_info(
        108u8,
        None,
        "enhanced_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 114u8, value)?
    } else {
        value
    };
    data_field_with_info(
        114u8,
        None,
        "grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 115u8, value)?
    } else {
        value
    };
    data_field_with_info(
        115u8,
        None,
        "flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_current_stress_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 116u8, value)?
    } else {
        value
    };
    data_field_with_info(
        116u8,
        None,
        "current_stress",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_travel_range_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 117u8, value)?
    } else {
        value
    };
    data_field_with_info(
        117u8,
        None,
        "ebike_travel_range",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_battery_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 118u8, value)?
    } else {
        value
    };
    data_field_with_info(
        118u8,
        None,
        "ebike_battery_level",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_assist_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 119u8, value)?
    } else {
        value
    };
    data_field_with_info(
        119u8,
        None,
        "ebike_assist_mode",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_assist_level_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 120u8, value)?
    } else {
        value
    };
    data_field_with_info(
        120u8,
        None,
        "ebike_assist_level_percent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_air_time_remaining_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 123u8, value)?
    } else {
        value
    };
    data_field_with_info(
        123u8,
        None,
        "air_time_remaining",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_pressure_sac_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 124u8, value)?
    } else {
        value
    };
    data_field_with_info(
        124u8,
        None,
        "pressure_sac",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_volume_sac_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 125u8, value)?
    } else {
        value
    };
    data_field_with_info(
        125u8,
        None,
        "volume_sac",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_rmv_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 126u8, value)?
    } else {
        value
    };
    data_field_with_info(
        126u8,
        None,
        "rmv",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ascent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 127u8, value)?
    } else {
        value
    };
    data_field_with_info(
        127u8,
        None,
        "ascent_rate",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_po2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 129u8, value)?
    } else {
        value
    };
    data_field_with_info(
        129u8,
        None,
        "po2",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 139u8, value)?
    } else {
        value
    };
    data_field_with_info(
        139u8,
        None,
        "core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "event message definition"]
#[doc = " * rider_position: Indicates the rider position value."]
#[doc = " * radar_threat_alert: The first byte is the radar_threat_level_max, the second byte is the radar_threat_count, third bytes is the average approach speed, and the 4th byte is the max approach speed"]
#[doc = " * score: Do not populate directly. Autogenerated by decoder for sport_point subfield components"]
#[doc = " * opponent_score: Do not populate directly. Autogenerated by decoder for sport_point subfield components"]
#[doc = " * front_gear_num: Do not populate directly. Autogenerated by decoder for gear_change subfield components. Front gear number. 1 is innermost."]
#[doc = " * front_gear: Do not populate directly. Autogenerated by decoder for gear_change subfield components. Number of front teeth."]
#[doc = " * rear_gear_num: Do not populate directly. Autogenerated by decoder for gear_change subfield components. Rear gear number. 1 is innermost."]
#[doc = " * rear_gear: Do not populate directly. Autogenerated by decoder for gear_change subfield components. Number of rear teeth."]
#[doc = " * activity_type: Activity Type associated with an auto_activity_detect event"]
#[doc = " * start_timestamp: Timestamp of when the event started"]
#[doc = " * auto_activity_detect_start_timestamp: Auto Activity Detect Start Timestamp."]
#[doc = " * radar_threat_level_max: Do not populate directly. Autogenerated by decoder for threat_alert subfield components."]
#[doc = " * radar_threat_count: Do not populate directly. Autogenerated by decoder for threat_alert subfield components."]
#[doc = " * radar_threat_avg_approach_speed: Do not populate directly. Autogenerated by decoder for radar_threat_alert subfield components"]
#[doc = " * radar_threat_max_approach_speed: Do not populate directly. Autogenerated by decoder for radar_threat_alert subfield components"]
fn event_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(event_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(event_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(event_message_data16_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), data) = extract_component(&input, 0usize, 16);
                data_map.insert(3u8, data.clone());
                if Event::Timer.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_timer_trigger_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::CoursePoint.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_course_point_index_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::Battery.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_battery_level_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "V",
                        data,
                    )?);
                } else if Event::VirtualPartnerPace.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_virtual_partner_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        data,
                    )?);
                } else if Event::HrHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "bpm",
                        data,
                    )?);
                } else if Event::HrLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "bpm",
                        data,
                    )?);
                } else if Event::SpeedHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        data,
                    )?);
                } else if Event::SpeedLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        data,
                    )?);
                } else if Event::CadHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        data,
                    )?);
                } else if Event::CadLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        data,
                    )?);
                } else if Event::PowerHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "watts",
                        data,
                    )?);
                } else if Event::PowerLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "watts",
                        data,
                    )?);
                } else if Event::TimeDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_time_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "s",
                        data,
                    )?);
                } else if Event::DistanceDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_distance_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100f64,
                        0f64,
                        "m",
                        data,
                    )?);
                } else if Event::CalorieDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_calorie_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "calories",
                        data,
                    )?);
                } else if Event::FitnessEquipment.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_fitness_equipment_state_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::SportPoint.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_sport_point_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::FrontGearChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::RearGearChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::RiderPositionChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_rider_position_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::CommTimeout.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_comm_timeout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::DiveAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_dive_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::AutoActivityDetect.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_auto_activity_detect_duration_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "min",
                        data,
                    )?);
                } else if Event::RadarThreatAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_radar_threat_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else {
                    fields.push(event_message_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                }
            }
            3u8 => {
                if Event::Timer.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_timer_trigger_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::CoursePoint.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_course_point_index_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::Battery.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_battery_level_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "V",
                        value,
                    )?);
                } else if Event::VirtualPartnerPace.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_virtual_partner_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value,
                    )?);
                } else if Event::HrHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "bpm",
                        value,
                    )?);
                } else if Event::HrLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "bpm",
                        value,
                    )?);
                } else if Event::SpeedHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value,
                    )?);
                } else if Event::SpeedLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value,
                    )?);
                } else if Event::CadHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                } else if Event::CadLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                } else if Event::PowerHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "watts",
                        value,
                    )?);
                } else if Event::PowerLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "watts",
                        value,
                    )?);
                } else if Event::TimeDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_time_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "s",
                        value,
                    )?);
                } else if Event::DistanceDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_distance_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100f64,
                        0f64,
                        "m",
                        value,
                    )?);
                } else if Event::CalorieDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_calorie_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "calories",
                        value,
                    )?);
                } else if Event::FitnessEquipment.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_fitness_equipment_state_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::SportPoint.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_sport_point_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::FrontGearChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::RearGearChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::RiderPositionChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_rider_position_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::CommTimeout.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_comm_timeout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::DiveAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_dive_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::AutoActivityDetect.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_auto_activity_detect_duration_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "min",
                        value,
                    )?);
                } else if Event::RadarThreatAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_radar_threat_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(event_message_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            4u8 => {
                fields.push(event_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(event_message_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(event_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(event_message_front_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(event_message_front_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(event_message_rear_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(event_message_rear_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(event_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(event_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                if Event::AutoActivityDetect.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_auto_activity_detect_start_timestamp_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "s",
                        value,
                    )?);
                } else {
                    fields.push(event_message_start_timestamp_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "s",
                        value,
                    )?);
                }
            }
            21u8 => {
                fields.push(event_message_radar_threat_level_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            22u8 => {
                fields.push(event_message_radar_threat_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            23u8 => {
                fields.push(event_message_radar_threat_avg_approach_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            24u8 => {
                fields.push(event_message_radar_threat_max_approach_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(event_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn event_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_data16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "data16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "data",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_timer_trigger_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "timer_trigger"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::TimerTrigger,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_course_point_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "course_point_index"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_battery_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "battery_level"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_virtual_partner_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "virtual_partner_speed"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_hr_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "hr_high_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_hr_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "hr_low_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_speed_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "speed_high_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_speed_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "speed_low_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_cad_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "cad_high_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_cad_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "cad_low_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_power_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "power_high_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_power_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "power_low_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_time_duration_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "time_duration_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_distance_duration_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "distance_duration_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_calorie_duration_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "calorie_duration_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_fitness_equipment_state_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "fitness_equipment_state"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::FitnessEquipmentState,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_sport_point_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "sport_point"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_gear_change_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "gear_change_data"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_rider_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "rider_position"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::RiderPositionType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_comm_timeout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "comm_timeout"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::CommTimeoutType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_dive_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "dive_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::DiveAlert,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_auto_activity_detect_duration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "auto_activity_detect_duration"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "radar_threat_alert"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_front_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "front_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_front_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "front_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_rear_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "rear_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_rear_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "rear_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_activity_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "activity_type",
        FieldDataType::ActivityType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_start_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "start_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_auto_activity_detect_start_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "start_timestamp"
    } else {
        "auto_activity_detect_start_timestamp"
    };
    data_field_with_info(
        15u8,
        None,
        name,
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_level_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "radar_threat_level_max",
        FieldDataType::RadarThreatLevelType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "radar_threat_count",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_avg_approach_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        None,
        "radar_threat_avg_approach_speed",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_max_approach_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        None,
        "radar_threat_max_approach_speed",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "device_info message definition"]
#[doc = " * cum_operating_time: Reset by new battery or charge."]
#[doc = " * sensor_position: Indicates the location of the sensor"]
#[doc = " * descriptor: Used to describe the sensor or location"]
#[doc = " * product_name: Optional free form string to indicate the devices name or model"]
fn device_info_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(device_info_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if SourceType::BluetoothLowEnergy.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_ble_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if SourceType::Antplus.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_antplus_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if SourceType::Ant.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_ant_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if SourceType::Local.as_i64()
                    == data_map
                        .get(&25u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_local_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(device_info_message_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            2u8 => {
                fields.push(device_info_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(device_info_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&2u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&2u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&2u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&2u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&2u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(device_info_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            5u8 => {
                fields.push(device_info_message_software_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(device_info_message_hardware_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(device_info_message_cum_operating_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            10u8 => {
                fields.push(device_info_message_battery_voltage_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256f64,
                    0f64,
                    "V",
                    value,
                )?);
            }
            11u8 => {
                fields.push(device_info_message_battery_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            18u8 => {
                fields.push(device_info_message_sensor_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            19u8 => {
                fields.push(device_info_message_descriptor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            20u8 => {
                fields.push(device_info_message_ant_transmission_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            21u8 => {
                fields.push(device_info_message_ant_device_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            22u8 => {
                fields.push(device_info_message_ant_network_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            25u8 => {
                fields.push(device_info_message_source_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            27u8 => {
                fields.push(device_info_message_product_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            32u8 => {
                fields.push(device_info_message_battery_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            253u8 => {
                fields.push(device_info_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn device_info_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "device_type",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ble_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "device_type"
    } else {
        "ble_device_type"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::BleDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_antplus_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "device_type"
    } else {
        "antplus_device_type"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::AntplusDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "device_type"
    } else {
        "ant_device_type"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_local_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "device_type"
    } else {
        "local_device_type"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::LocalDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_software_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "software_version",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_hardware_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "hardware_version",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_cum_operating_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "cum_operating_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_battery_voltage_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "battery_voltage",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_battery_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "battery_status",
        FieldDataType::BatteryStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_sensor_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        None,
        "sensor_position",
        FieldDataType::BodyLocation,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_descriptor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        None,
        "descriptor",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_transmission_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        None,
        "ant_transmission_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_device_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "ant_device_number",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_network_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "ant_network",
        FieldDataType::AntNetwork,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_source_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        None,
        "source_type",
        FieldDataType::SourceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_product_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        None,
        "product_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_battery_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        None,
        "battery_level",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "device_aux_battery_info message definition"]
fn device_aux_battery_info_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(device_aux_battery_info_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(device_aux_battery_info_message_battery_voltage_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256f64,
                    0f64,
                    "V",
                    value,
                )?);
            }
            2u8 => {
                fields.push(device_aux_battery_info_message_battery_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(device_aux_battery_info_message_battery_identifier_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(device_aux_battery_info_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn device_aux_battery_info_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_battery_voltage_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "battery_voltage",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_battery_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "battery_status",
        FieldDataType::BatteryStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_battery_identifier_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "battery_identifier",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Corresponds to file_id of workout or course."]
fn training_file_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(training_file_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(training_file_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(training_file_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            3u8 => {
                fields.push(training_file_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(training_file_message_time_created_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(training_file_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn training_file_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "type",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        2u8,
        None,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        2u8,
        None,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_time_created_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "time_created",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "weather_conditions message definition"]
#[doc = " * weather_report: Current or forecast"]
#[doc = " * condition: Corresponds to GSC Response weatherIcon field"]
#[doc = " * precipitation_probability: range 0-100"]
#[doc = " * temperature_feels_like: Heat Index if GCS heatIdx above or equal to 90F or wind chill if GCS windChill below or equal to 32F"]
#[doc = " * location: string corresponding to GCS response location string"]
#[doc = " * timestamp: time of update for current conditions, else forecast time"]
fn weather_conditions_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(weather_conditions_message_weather_report_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(weather_conditions_message_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            2u8 => {
                fields.push(weather_conditions_message_condition_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(weather_conditions_message_wind_direction_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            4u8 => {
                fields.push(weather_conditions_message_wind_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(weather_conditions_message_precipitation_probability_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(weather_conditions_message_temperature_feels_like_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            7u8 => {
                fields.push(weather_conditions_message_relative_humidity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(weather_conditions_message_location_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(weather_conditions_message_observed_at_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(weather_conditions_message_observed_location_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            11u8 => {
                fields.push(weather_conditions_message_observed_location_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            12u8 => {
                fields.push(weather_conditions_message_day_of_week_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(weather_conditions_message_high_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            14u8 => {
                fields.push(weather_conditions_message_low_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            253u8 => {
                fields.push(weather_conditions_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn weather_conditions_message_weather_report_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "weather_report",
        FieldDataType::WeatherReport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_condition_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "condition",
        FieldDataType::WeatherStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_wind_direction_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "wind_direction",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_wind_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "wind_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_precipitation_probability_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "precipitation_probability",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_temperature_feels_like_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "temperature_feels_like",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_relative_humidity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "relative_humidity",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_location_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "location",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_observed_at_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "observed_at_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_observed_location_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "observed_location_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_observed_location_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "observed_location_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_day_of_week_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "day_of_week",
        FieldDataType::DayOfWeek,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_high_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "high_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_low_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "low_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "weather_alert message definition"]
#[doc = " * report_id: Unique identifier from GCS report ID string, length is 12"]
#[doc = " * issue_time: Time alert was issued"]
#[doc = " * expire_time: Time alert expires"]
#[doc = " * severity: Warning, Watch, Advisory, Statement"]
#[doc = " * type: Tornado, Severe Thunderstorm, etc."]
fn weather_alert_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(weather_alert_message_report_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(weather_alert_message_issue_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(weather_alert_message_expire_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(weather_alert_message_severity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(weather_alert_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(weather_alert_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn weather_alert_message_report_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "report_id",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_issue_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "issue_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_expire_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "expire_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_severity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "severity",
        FieldDataType::WeatherSeverity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "type",
        FieldDataType::WeatherSevereType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "gps_metadata message definition"]
#[doc = " * timestamp_ms: Millisecond part of the timestamp."]
#[doc = " * utc_timestamp: Used to correlate UTC to system time if the timestamp of the message is in system time. This UTC time is derived from the GPS data."]
#[doc = " * velocity: velocity[0] is lon velocity. Velocity[1] is lat velocity. Velocity[2] is altitude velocity."]
#[doc = " * timestamp: Whole second part of the timestamp."]
fn gps_metadata_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(gps_metadata_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(gps_metadata_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            2u8 => {
                fields.push(gps_metadata_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            3u8 => {
                fields.push(gps_metadata_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(gps_metadata_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(gps_metadata_message_heading_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            6u8 => {
                fields.push(gps_metadata_message_utc_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            7u8 => {
                fields.push(gps_metadata_message_velocity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(gps_metadata_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn gps_metadata_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_enhanced_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "enhanced_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_enhanced_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "enhanced_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_heading_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "heading",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_utc_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "utc_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_velocity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "velocity",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "camera_event message definition"]
#[doc = " * timestamp_ms: Millisecond part of the timestamp."]
#[doc = " * timestamp: Whole second part of the timestamp."]
fn camera_event_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(camera_event_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(camera_event_message_camera_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(camera_event_message_camera_file_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(camera_event_message_camera_orientation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(camera_event_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn camera_event_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_camera_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "camera_event_type",
        FieldDataType::CameraEventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_camera_file_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "camera_file_uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_camera_orientation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "camera_orientation",
        FieldDataType::CameraOrientationType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "gyroscope_data message definition"]
#[doc = " * timestamp_ms: Millisecond part of the timestamp."]
#[doc = " * sample_time_offset: Each time in the array describes the time at which the gyro sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in gyro_x and gyro_y and gyro_z"]
#[doc = " * gyro_x: These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read."]
#[doc = " * gyro_y: These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read."]
#[doc = " * gyro_z: These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read."]
#[doc = " * calibrated_gyro_x: Calibrated gyro reading"]
#[doc = " * calibrated_gyro_y: Calibrated gyro reading"]
#[doc = " * calibrated_gyro_z: Calibrated gyro reading"]
#[doc = " * timestamp: Whole second part of the timestamp"]
fn gyroscope_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(gyroscope_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(gyroscope_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(gyroscope_data_message_gyro_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            3u8 => {
                fields.push(gyroscope_data_message_gyro_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            4u8 => {
                fields.push(gyroscope_data_message_gyro_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            5u8 => {
                fields.push(gyroscope_data_message_calibrated_gyro_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            6u8 => {
                fields.push(gyroscope_data_message_calibrated_gyro_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            7u8 => {
                fields.push(gyroscope_data_message_calibrated_gyro_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(gyroscope_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn gyroscope_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_gyro_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "gyro_x",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_gyro_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "gyro_y",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_gyro_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "gyro_z",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_calibrated_gyro_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "calibrated_gyro_x",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_calibrated_gyro_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "calibrated_gyro_y",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_calibrated_gyro_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "calibrated_gyro_z",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "accelerometer_data message definition"]
#[doc = " * timestamp_ms: Millisecond part of the timestamp."]
#[doc = " * sample_time_offset: Each time in the array describes the time at which the accelerometer sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in accel_x and accel_y and accel_z"]
#[doc = " * accel_x: These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read."]
#[doc = " * accel_y: These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read."]
#[doc = " * accel_z: These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read."]
#[doc = " * calibrated_accel_x: Calibrated accel reading"]
#[doc = " * calibrated_accel_y: Calibrated accel reading"]
#[doc = " * calibrated_accel_z: Calibrated accel reading"]
#[doc = " * compressed_calibrated_accel_x: Calibrated accel reading"]
#[doc = " * compressed_calibrated_accel_y: Calibrated accel reading"]
#[doc = " * compressed_calibrated_accel_z: Calibrated accel reading"]
#[doc = " * timestamp: Whole second part of the timestamp"]
fn accelerometer_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(accelerometer_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(accelerometer_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(accelerometer_data_message_accel_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            3u8 => {
                fields.push(accelerometer_data_message_accel_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            4u8 => {
                fields.push(accelerometer_data_message_accel_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            5u8 => {
                fields.push(accelerometer_data_message_calibrated_accel_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "g",
                    value,
                )?);
            }
            6u8 => {
                fields.push(accelerometer_data_message_calibrated_accel_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "g",
                    value,
                )?);
            }
            7u8 => {
                fields.push(accelerometer_data_message_calibrated_accel_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "g",
                    value,
                )?);
            }
            8u8 => {
                fields.push(
                    accelerometer_data_message_compressed_calibrated_accel_x_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "mG",
                        value,
                    )?,
                );
            }
            9u8 => {
                fields.push(
                    accelerometer_data_message_compressed_calibrated_accel_y_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "mG",
                        value,
                    )?,
                );
            }
            10u8 => {
                fields.push(
                    accelerometer_data_message_compressed_calibrated_accel_z_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "mG",
                        value,
                    )?,
                );
            }
            253u8 => {
                fields.push(accelerometer_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn accelerometer_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_accel_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "accel_x",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_accel_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "accel_y",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_accel_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "accel_z",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_calibrated_accel_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "calibrated_accel_x",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_calibrated_accel_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "calibrated_accel_y",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_calibrated_accel_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "calibrated_accel_z",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_compressed_calibrated_accel_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "compressed_calibrated_accel_x",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_compressed_calibrated_accel_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "compressed_calibrated_accel_y",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_compressed_calibrated_accel_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "compressed_calibrated_accel_z",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "magnetometer_data message definition"]
#[doc = " * timestamp_ms: Millisecond part of the timestamp."]
#[doc = " * sample_time_offset: Each time in the array describes the time at which the compass sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in cmps_x and cmps_y and cmps_z"]
#[doc = " * mag_x: These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read."]
#[doc = " * mag_y: These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read."]
#[doc = " * mag_z: These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read."]
#[doc = " * calibrated_mag_x: Calibrated Magnetometer reading"]
#[doc = " * calibrated_mag_y: Calibrated Magnetometer reading"]
#[doc = " * calibrated_mag_z: Calibrated Magnetometer reading"]
#[doc = " * timestamp: Whole second part of the timestamp"]
fn magnetometer_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(magnetometer_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(magnetometer_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(magnetometer_data_message_mag_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            3u8 => {
                fields.push(magnetometer_data_message_mag_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            4u8 => {
                fields.push(magnetometer_data_message_mag_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            5u8 => {
                fields.push(magnetometer_data_message_calibrated_mag_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "G",
                    value,
                )?);
            }
            6u8 => {
                fields.push(magnetometer_data_message_calibrated_mag_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "G",
                    value,
                )?);
            }
            7u8 => {
                fields.push(magnetometer_data_message_calibrated_mag_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "G",
                    value,
                )?);
            }
            253u8 => {
                fields.push(magnetometer_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn magnetometer_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_mag_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "mag_x",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_mag_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "mag_y",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_mag_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "mag_z",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_calibrated_mag_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "calibrated_mag_x",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_calibrated_mag_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "calibrated_mag_y",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_calibrated_mag_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "calibrated_mag_z",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "barometer_data message definition"]
#[doc = " * timestamp_ms: Millisecond part of the timestamp."]
#[doc = " * sample_time_offset: Each time in the array describes the time at which the barometer sample with the corrosponding index was taken. The samples may span across seconds. Array size must match the number of samples in baro_cal"]
#[doc = " * baro_pres: These are the raw ADC reading. The samples may span across seconds. A conversion will need to be done on this data once read."]
#[doc = " * timestamp: Whole second part of the timestamp"]
fn barometer_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(barometer_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(barometer_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(barometer_data_message_baro_pres_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Pa",
                    value,
                )?);
            }
            253u8 => {
                fields.push(barometer_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn barometer_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn barometer_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn barometer_data_message_baro_pres_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "baro_pres",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn barometer_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "three_d_sensor_calibration message definition"]
#[doc = " * sensor_type: Indicates which sensor the calibration is for"]
#[doc = " * calibration_factor: Calibration factor used to convert from raw ADC value to degrees, g, etc."]
#[doc = " * accel_cal_factor: Accelerometer calibration factor"]
#[doc = " * gyro_cal_factor: Gyro calibration factor"]
#[doc = " * calibration_divisor: Calibration factor divisor"]
#[doc = " * level_shift: Level shift value used to shift the ADC value back into range"]
#[doc = " * offset_cal: Internal calibration factors, one for each: xy, yx, zx"]
#[doc = " * orientation_matrix: 3 x 3 rotation matrix (row major)"]
#[doc = " * timestamp: Whole second part of the timestamp"]
fn three_d_sensor_calibration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(three_d_sensor_calibration_message_sensor_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if SensorType::Accelerometer.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(three_d_sensor_calibration_message_accel_cal_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "g",
                        value,
                    )?);
                } else if SensorType::Gyroscope.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(three_d_sensor_calibration_message_gyro_cal_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "deg/s",
                        value,
                    )?);
                } else {
                    fields.push(three_d_sensor_calibration_message_calibration_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            2u8 => {
                fields.push(
                    three_d_sensor_calibration_message_calibration_divisor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "counts",
                        value,
                    )?,
                );
            }
            3u8 => {
                fields.push(three_d_sensor_calibration_message_level_shift_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(three_d_sensor_calibration_message_offset_cal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(three_d_sensor_calibration_message_orientation_matrix_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    65535f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(three_d_sensor_calibration_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn three_d_sensor_calibration_message_sensor_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "sensor_type",
        FieldDataType::SensorType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_calibration_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "calibration_factor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_accel_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "calibration_factor"
    } else {
        "accel_cal_factor"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_gyro_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "calibration_factor"
    } else {
        "gyro_cal_factor"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_calibration_divisor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "calibration_divisor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_level_shift_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "level_shift",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_offset_cal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "offset_cal",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_orientation_matrix_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "orientation_matrix",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "one_d_sensor_calibration message definition"]
#[doc = " * sensor_type: Indicates which sensor the calibration is for"]
#[doc = " * calibration_factor: Calibration factor used to convert from raw ADC value to degrees, g, etc."]
#[doc = " * baro_cal_factor: Barometer calibration factor"]
#[doc = " * calibration_divisor: Calibration factor divisor"]
#[doc = " * level_shift: Level shift value used to shift the ADC value back into range"]
#[doc = " * offset_cal: Internal Calibration factor"]
#[doc = " * timestamp: Whole second part of the timestamp"]
fn one_d_sensor_calibration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(one_d_sensor_calibration_message_sensor_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if SensorType::Barometer.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(one_d_sensor_calibration_message_baro_cal_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "Pa",
                        value,
                    )?);
                } else {
                    fields.push(one_d_sensor_calibration_message_calibration_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            2u8 => {
                fields.push(one_d_sensor_calibration_message_calibration_divisor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            3u8 => {
                fields.push(one_d_sensor_calibration_message_level_shift_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(one_d_sensor_calibration_message_offset_cal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(one_d_sensor_calibration_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn one_d_sensor_calibration_message_sensor_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "sensor_type",
        FieldDataType::SensorType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_calibration_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "calibration_factor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_baro_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "calibration_factor"
    } else {
        "baro_cal_factor"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_calibration_divisor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "calibration_divisor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_level_shift_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "level_shift",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_offset_cal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "offset_cal",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "video_frame message definition"]
#[doc = " * timestamp_ms: Millisecond part of the timestamp."]
#[doc = " * frame_number: Number of the frame that the timestamp and timestamp_ms correlate to"]
#[doc = " * timestamp: Whole second part of the timestamp"]
fn video_frame_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(video_frame_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(video_frame_message_frame_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(video_frame_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_frame_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_frame_message_frame_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "frame_number",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_frame_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "obdii_data message definition"]
#[doc = " * timestamp_ms: Fractional part of timestamp, added to timestamp"]
#[doc = " * time_offset: Offset of PID reading [i] from start_timestamp+start_timestamp_ms. Readings may span accross seconds."]
#[doc = " * pid: Parameter ID"]
#[doc = " * raw_data: Raw parameter data"]
#[doc = " * pid_data_size: Optional, data size of PID[i]. If not specified refer to SAE J1979."]
#[doc = " * system_time: System time associated with sample expressed in ms, can be used instead of time_offset. There will be a system_time value for each raw_data element. For multibyte pids the system_time is repeated."]
#[doc = " * start_timestamp: Timestamp of first sample recorded in the message. Used with time_offset to generate time of each sample"]
#[doc = " * start_timestamp_ms: Fractional part of start_timestamp"]
#[doc = " * timestamp: Timestamp message was output"]
fn obdii_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(obdii_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(obdii_data_message_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(obdii_data_message_pid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(obdii_data_message_raw_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(obdii_data_message_pid_data_size_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(obdii_data_message_system_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(obdii_data_message_start_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(obdii_data_message_start_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            253u8 => {
                fields.push(obdii_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn obdii_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_pid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "pid",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_raw_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "raw_data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_pid_data_size_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "pid_data_size",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_system_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "system_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_start_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "start_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_start_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "start_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "nmea_sentence message definition"]
#[doc = " * timestamp_ms: Fractional part of timestamp, added to timestamp"]
#[doc = " * sentence: NMEA sentence"]
#[doc = " * timestamp: Timestamp message was output"]
fn nmea_sentence_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(nmea_sentence_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(nmea_sentence_message_sentence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(nmea_sentence_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn nmea_sentence_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn nmea_sentence_message_sentence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sentence",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn nmea_sentence_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "aviation_attitude message definition"]
#[doc = " * timestamp_ms: Fractional part of timestamp, added to timestamp"]
#[doc = " * system_time: System time associated with sample expressed in ms."]
#[doc = " * pitch: Range -PI/2 to +PI/2"]
#[doc = " * roll: Range -PI to +PI"]
#[doc = " * accel_lateral: Range -78.4 to +78.4 (-8 Gs to 8 Gs)"]
#[doc = " * accel_normal: Range -78.4 to +78.4 (-8 Gs to 8 Gs)"]
#[doc = " * turn_rate: Range -8.727 to +8.727 (-500 degs/sec to +500 degs/sec)"]
#[doc = " * attitude_stage_complete: The percent complete of the current attitude stage. Set to 0 for attitude stages 0, 1 and 2 and to 100 for attitude stage 3 by AHRS modules that do not support it. Range - 100"]
#[doc = " * track: Track Angle/Heading Range 0 - 2pi"]
#[doc = " * timestamp: Timestamp message was output"]
fn aviation_attitude_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(aviation_attitude_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(aviation_attitude_message_system_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(aviation_attitude_message_pitch_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10430.38f64,
                    0f64,
                    "radians",
                    value,
                )?);
            }
            3u8 => {
                fields.push(aviation_attitude_message_roll_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10430.38f64,
                    0f64,
                    "radians",
                    value,
                )?);
            }
            4u8 => {
                fields.push(aviation_attitude_message_accel_lateral_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s^2",
                    value,
                )?);
            }
            5u8 => {
                fields.push(aviation_attitude_message_accel_normal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s^2",
                    value,
                )?);
            }
            6u8 => {
                fields.push(aviation_attitude_message_turn_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1024f64,
                    0f64,
                    "radians/second",
                    value,
                )?);
            }
            7u8 => {
                fields.push(aviation_attitude_message_stage_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(aviation_attitude_message_attitude_stage_complete_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            9u8 => {
                fields.push(aviation_attitude_message_track_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10430.38f64,
                    0f64,
                    "radians",
                    value,
                )?);
            }
            10u8 => {
                fields.push(aviation_attitude_message_validity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(aviation_attitude_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn aviation_attitude_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_system_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "system_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_pitch_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "pitch",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_roll_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "roll",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_accel_lateral_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "accel_lateral",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_accel_normal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "accel_normal",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_turn_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "turn_rate",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_stage_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "stage",
        FieldDataType::AttitudeStage,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_attitude_stage_complete_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "attitude_stage_complete",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_track_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "track",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_validity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "validity",
        FieldDataType::AttitudeValidity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "video message definition"]
#[doc = " * duration: Playback time of video"]
fn video_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(video_message_url_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(video_message_hosting_provider_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(video_message_duration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_message_url_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "url",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_message_hosting_provider_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "hosting_provider",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_message_duration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "duration",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "video_title message definition"]
#[doc = " * message_count: Total number of title parts"]
#[doc = " * message_index: Long titles will be split into multiple parts"]
fn video_title_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(video_title_message_message_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(video_title_message_text_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(video_title_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_title_message_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "message_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_title_message_text_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "text",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_title_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "video_description message definition"]
#[doc = " * message_count: Total number of description parts"]
#[doc = " * message_index: Long descriptions will be split into multiple parts"]
fn video_description_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(video_description_message_message_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(video_description_message_text_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(video_description_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_description_message_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "message_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_description_message_text_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "text",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_description_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "video_clip message definition"]
#[doc = " * clip_start: Start of clip in video time"]
#[doc = " * clip_end: End of clip in video time"]
fn video_clip_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(video_clip_message_clip_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(video_clip_message_start_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(video_clip_message_start_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(video_clip_message_end_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(video_clip_message_end_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(video_clip_message_clip_start_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            7u8 => {
                fields.push(video_clip_message_clip_end_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_clip_message_clip_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "clip_number",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_start_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "start_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_start_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "start_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_end_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "end_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_end_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "end_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_clip_start_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "clip_start",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_clip_end_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "clip_end",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "set message definition"]
#[doc = " * repetitions: # of repitions of the movement"]
#[doc = " * weight: Amount of weight applied for the set"]
#[doc = " * start_time: Start time of the set"]
#[doc = " * category_subtype: Based on the associated category, see [category]_exercise_names"]
#[doc = " * timestamp: Timestamp of the set"]
fn set_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(set_message_duration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            3u8 => {
                fields.push(set_message_repetitions_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(set_message_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    16f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            5u8 => {
                fields.push(set_message_set_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(set_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(set_message_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(set_message_category_subtype_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(set_message_weight_display_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(set_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(set_message_wkt_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(set_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn set_message_duration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "duration",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_repetitions_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "repetitions",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_set_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "set_type",
        FieldDataType::SetType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "category",
        FieldDataType::ExerciseCategory,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_category_subtype_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "category_subtype",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_weight_display_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "weight_display_unit",
        FieldDataType::FitBaseUnit,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_wkt_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "wkt_step_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "jump message definition"]
#[doc = " * score: A score for a jump calculated based on hang time, rotations, and distance."]
fn jump_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(jump_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            1u8 => {
                fields.push(jump_message_height_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            2u8 => {
                fields.push(jump_message_rotations_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(jump_message_hang_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(jump_message_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(jump_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            6u8 => {
                fields.push(jump_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            7u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(jump_message_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(8u8, enhanced_speed.clone());
                fields.push(jump_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_speed,
                )?);
            }
            8u8 => {
                fields.push(jump_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(jump_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn jump_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "distance",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_height_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "height",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_rotations_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "rotations",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_hang_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "hang_time",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "score",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_enhanced_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "enhanced_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "split message definition"]
fn split_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(split_message_split_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(split_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(split_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            3u8 => {
                fields.push(split_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(split_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            9u8 => {
                fields.push(split_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(split_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            14u8 => {
                fields.push(split_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            21u8 => {
                fields.push(split_message_start_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            22u8 => {
                fields.push(split_message_start_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            23u8 => {
                fields.push(split_message_end_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            24u8 => {
                fields.push(split_message_end_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            25u8 => {
                fields.push(split_message_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            26u8 => {
                fields.push(split_message_avg_vert_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            27u8 => {
                fields.push(split_message_end_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            28u8 => {
                fields.push(split_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            74u8 => {
                fields.push(split_message_start_elevation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            110u8 => {
                fields.push(split_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(split_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn split_message_split_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "split_type",
        FieldDataType::SplitType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_start_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "start_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_start_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "start_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_end_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        None,
        "end_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_end_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        None,
        "end_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        None,
        "max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_avg_vert_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        None,
        "avg_vert_speed",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_end_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        None,
        "end_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        None,
        "total_calories",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_start_elevation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 74u8, value)?
    } else {
        value
    };
    data_field_with_info(
        74u8,
        None,
        "start_elevation",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 110u8, value)?
    } else {
        value
    };
    data_field_with_info(
        110u8,
        None,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "split_summary message definition"]
fn split_summary_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(split_summary_message_split_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(split_summary_message_num_splits_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(split_summary_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(split_summary_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            6u8 => {
                fields.push(split_summary_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            7u8 => {
                fields.push(split_summary_message_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            8u8 => {
                fields.push(split_summary_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            9u8 => {
                fields.push(split_summary_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            10u8 => {
                fields.push(split_summary_message_avg_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            11u8 => {
                fields.push(split_summary_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            12u8 => {
                fields.push(split_summary_message_avg_vert_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            13u8 => {
                fields.push(split_summary_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            77u8 => {
                fields.push(split_summary_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(split_summary_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn split_summary_message_split_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "split_type",
        FieldDataType::SplitType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_num_splits_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "num_splits",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_avg_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "avg_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_avg_vert_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "avg_vert_speed",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "total_calories",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 77u8, value)?
    } else {
        value
    };
    data_field_with_info(
        77u8,
        None,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "climb_pro message definition"]
fn climb_pro_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(climb_pro_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            1u8 => {
                fields.push(climb_pro_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            2u8 => {
                fields.push(climb_pro_message_climb_pro_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(climb_pro_message_climb_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(climb_pro_message_climb_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(climb_pro_message_current_dist_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            253u8 => {
                fields.push(climb_pro_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn climb_pro_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_climb_pro_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "climb_pro_event",
        FieldDataType::ClimbProEvent,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_climb_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "climb_number",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_climb_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "climb_category",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_current_dist_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "current_dist",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Must be logged before developer field is used"]
fn field_description_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(field_description_message_developer_data_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(field_description_message_field_definition_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(field_description_message_fit_base_type_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(field_description_message_field_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(field_description_message_array_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(field_description_message_components_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(field_description_message_scale_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(field_description_message_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(field_description_message_units_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(field_description_message_bits_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(field_description_message_accumulate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(field_description_message_fit_base_unit_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(field_description_message_native_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                fields.push(field_description_message_native_field_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn field_description_message_developer_data_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "developer_data_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_field_definition_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "field_definition_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_fit_base_type_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "fit_base_type_id",
        FieldDataType::FitBaseType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_field_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "field_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_array_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "array",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_components_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "components",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_scale_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "scale",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "offset",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_units_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "units",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_bits_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "bits",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_accumulate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "accumulate",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_fit_base_unit_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "fit_base_unit_id",
        FieldDataType::FitBaseUnit,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_native_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "native_mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_native_field_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "native_field_num",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Must be logged before field description"]
fn developer_data_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(developer_data_id_message_developer_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(developer_data_id_message_application_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(developer_data_id_message_manufacturer_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(developer_data_id_message_developer_data_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(developer_data_id_message_application_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn developer_data_id_message_developer_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "developer_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_application_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "application_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_manufacturer_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "manufacturer_id",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_developer_data_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "developer_data_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_application_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "application_version",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "course message definition"]
fn course_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            4u8 => {
                fields.push(course_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(course_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(course_message_capabilities_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(course_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn course_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_message_capabilities_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "capabilities",
        FieldDataType::CourseCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "course_point message definition"]
fn course_point_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            1u8 => {
                fields.push(course_point_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(course_point_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            3u8 => {
                fields.push(course_point_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            4u8 => {
                fields.push(course_point_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            5u8 => {
                fields.push(course_point_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(course_point_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(course_point_message_favorite_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(course_point_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn course_point_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "type",
        FieldDataType::CoursePoint,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_favorite_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "favorite",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Unique Identification data for a segment file"]
#[doc = " * name: Friendly name assigned to segment"]
#[doc = " * uuid: UUID of the segment"]
#[doc = " * sport: Sport associated with the segment"]
#[doc = " * enabled: Segment enabled for evaluation"]
#[doc = " * user_profile_primary_key: Primary key of the user that created the segment"]
#[doc = " * device_id: ID of the device that created the segment"]
#[doc = " * default_race_leader: Index for the Leader Board entry selected as the default race participant"]
#[doc = " * delete_status: Indicates if any segments should be deleted"]
#[doc = " * selection_type: Indicates how the segment was selected to be sent to the device"]
fn segment_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(segment_id_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(segment_id_message_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(segment_id_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(segment_id_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(segment_id_message_user_profile_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(segment_id_message_device_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(segment_id_message_default_race_leader_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(segment_id_message_delete_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(segment_id_message_selection_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_id_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_user_profile_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "user_profile_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_device_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "device_id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_default_race_leader_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "default_race_leader",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_delete_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "delete_status",
        FieldDataType::SegmentDeleteStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_selection_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "selection_type",
        FieldDataType::SegmentSelectionType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Unique Identification data for an individual segment leader within a segment file"]
#[doc = " * name: Friendly name assigned to leader"]
#[doc = " * type: Leader classification"]
#[doc = " * group_primary_key: Primary user ID of this leader"]
#[doc = " * activity_id: ID of the activity associated with this leader time"]
#[doc = " * segment_time: Segment Time (includes pauses)"]
#[doc = " * activity_id_string: String version of the activity_id. 21 characters long, express in decimal"]
fn segment_leaderboard_entry_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(segment_leaderboard_entry_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(segment_leaderboard_entry_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(segment_leaderboard_entry_message_group_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(segment_leaderboard_entry_message_activity_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(segment_leaderboard_entry_message_segment_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(segment_leaderboard_entry_message_activity_id_string_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(segment_leaderboard_entry_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_leaderboard_entry_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "type",
        FieldDataType::SegmentLeaderboardType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_group_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "group_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_activity_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "activity_id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_segment_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "segment_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_activity_id_string_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "activity_id_string",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Navigation and race evaluation point for a segment decribing a point along the segment path and time it took each segment leader to reach that point"]
#[doc = " * distance: Accumulated distance along the segment at the described point"]
#[doc = " * altitude: Accumulated altitude along the segment at the described point"]
#[doc = " * leader_time: Accumualted time each leader board member required to reach the described point. This value is zero for all leader board members at the starting point of the segment."]
#[doc = " * enhanced_altitude: Accumulated altitude along the segment at the described point"]
fn segment_point_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            1u8 => {
                fields.push(segment_point_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            2u8 => {
                fields.push(segment_point_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            3u8 => {
                fields.push(segment_point_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(segment_point_message_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_altitude) = extract_component(&input, 0usize, 16);
                data_map.insert(6u8, enhanced_altitude.clone());
                fields.push(segment_point_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_altitude,
                )?);
            }
            5u8 => {
                fields.push(segment_point_message_leader_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            6u8 => {
                fields.push(segment_point_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            254u8 => {
                fields.push(segment_point_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_point_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_leader_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "leader_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_enhanced_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "enhanced_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "segment_lap message definition"]
#[doc = " * total_elapsed_time: Time (includes pauses)"]
#[doc = " * total_timer_time: Timer Time (excludes pauses)"]
#[doc = " * total_fat_calories: If New Leaf"]
#[doc = " * avg_cadence: total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time"]
#[doc = " * avg_power: total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time"]
#[doc = " * nec_lat: North east corner latitude."]
#[doc = " * nec_long: North east corner longitude."]
#[doc = " * swc_lat: South west corner latitude."]
#[doc = " * swc_long: South west corner latitude."]
#[doc = " * avg_fractional_cadence: fractional part of the avg_cadence"]
#[doc = " * max_fractional_cadence: fractional part of the max_cadence"]
#[doc = " * total_fractional_cycles: fractional part of the total_cycles"]
#[doc = " * time_standing: Total time spent in the standing position"]
#[doc = " * stand_count: Number of transitions to the standing state"]
#[doc = " * avg_left_pco: Average left platform center offset"]
#[doc = " * avg_right_pco: Average right platform center offset"]
#[doc = " * avg_left_power_phase: Average left power phase angles. Data value indexes defined by power_phase_type."]
#[doc = " * avg_left_power_phase_peak: Average left power phase peak angles. Data value indexes defined by power_phase_type."]
#[doc = " * avg_right_power_phase: Average right power phase angles. Data value indexes defined by power_phase_type."]
#[doc = " * avg_right_power_phase_peak: Average right power phase peak angles. Data value indexes defined by power_phase_type."]
#[doc = " * avg_power_position: Average power by position. Data value indexes defined by rider_position_type."]
#[doc = " * max_power_position: Maximum power by position. Data value indexes defined by rider_position_type."]
#[doc = " * avg_cadence_position: Average cadence by position. Data value indexes defined by rider_position_type."]
#[doc = " * max_cadence_position: Maximum cadence by position. Data value indexes defined by rider_position_type."]
#[doc = " * manufacturer: Manufacturer that produced the segment"]
#[doc = " * total_grit: The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes."]
#[doc = " * total_flow: The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals."]
#[doc = " * avg_grit: The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes."]
#[doc = " * avg_flow: The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals."]
#[doc = " * total_fractional_ascent: fractional part of total_ascent"]
#[doc = " * total_fractional_descent: fractional part of total_descent"]
#[doc = " * timestamp: Lap end time."]
fn segment_lap_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(segment_lap_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(segment_lap_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(segment_lap_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(segment_lap_message_start_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            4u8 => {
                fields.push(segment_lap_message_start_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            5u8 => {
                fields.push(segment_lap_message_end_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            6u8 => {
                fields.push(segment_lap_message_end_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            7u8 => {
                fields.push(segment_lap_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            8u8 => {
                fields.push(segment_lap_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            9u8 => {
                fields.push(segment_lap_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            10u8 => {
                if Sport::Cycling.as_i64()
                    == data_map
                        .get(&23u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(segment_lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(segment_lap_message_total_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "cycles",
                        value,
                    )?);
                }
            }
            11u8 => {
                fields.push(segment_lap_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            12u8 => {
                fields.push(segment_lap_message_total_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            13u8 => {
                fields.push(segment_lap_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            14u8 => {
                fields.push(segment_lap_message_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            15u8 => {
                fields.push(segment_lap_message_avg_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            16u8 => {
                fields.push(segment_lap_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            17u8 => {
                fields.push(segment_lap_message_avg_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            18u8 => {
                fields.push(segment_lap_message_max_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            19u8 => {
                fields.push(segment_lap_message_avg_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            20u8 => {
                fields.push(segment_lap_message_max_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            21u8 => {
                fields.push(segment_lap_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            22u8 => {
                fields.push(segment_lap_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            23u8 => {
                fields.push(segment_lap_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            24u8 => {
                fields.push(segment_lap_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            25u8 => {
                fields.push(segment_lap_message_nec_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            26u8 => {
                fields.push(segment_lap_message_nec_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            27u8 => {
                fields.push(segment_lap_message_swc_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            28u8 => {
                fields.push(segment_lap_message_swc_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            29u8 => {
                fields.push(segment_lap_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            30u8 => {
                fields.push(segment_lap_message_normalized_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            31u8 => {
                fields.push(segment_lap_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            32u8 => {
                fields.push(segment_lap_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            33u8 => {
                fields.push(segment_lap_message_total_work_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "J",
                    value,
                )?);
            }
            34u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(segment_lap_message_avg_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(91u8, enhanced_avg_altitude.clone());
                fields.push(segment_lap_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_avg_altitude,
                )?);
            }
            35u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(segment_lap_message_max_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(92u8, enhanced_max_altitude.clone());
                fields.push(segment_lap_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_max_altitude,
                )?);
            }
            36u8 => {
                fields.push(segment_lap_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            37u8 => {
                fields.push(segment_lap_message_avg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            38u8 => {
                fields.push(segment_lap_message_avg_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            39u8 => {
                fields.push(segment_lap_message_avg_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            40u8 => {
                fields.push(segment_lap_message_max_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            41u8 => {
                fields.push(segment_lap_message_max_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            42u8 => {
                fields.push(segment_lap_message_avg_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            43u8 => {
                fields.push(segment_lap_message_max_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            44u8 => {
                fields.push(segment_lap_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            45u8 => {
                fields.push(segment_lap_message_avg_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            46u8 => {
                fields.push(segment_lap_message_avg_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            47u8 => {
                fields.push(segment_lap_message_max_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            48u8 => {
                fields.push(segment_lap_message_max_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            49u8 => {
                fields.push(segment_lap_message_time_in_hr_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            50u8 => {
                fields.push(segment_lap_message_time_in_speed_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            51u8 => {
                fields.push(segment_lap_message_time_in_cadence_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            52u8 => {
                fields.push(segment_lap_message_time_in_power_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            53u8 => {
                fields.push(segment_lap_message_repetition_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            54u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(segment_lap_message_min_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_min_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(93u8, enhanced_min_altitude.clone());
                fields.push(segment_lap_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_min_altitude,
                )?);
            }
            55u8 => {
                fields.push(segment_lap_message_min_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            56u8 => {
                fields.push(segment_lap_message_active_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            57u8 => {
                fields.push(segment_lap_message_wkt_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            58u8 => {
                fields.push(segment_lap_message_sport_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            59u8 => {
                fields.push(segment_lap_message_avg_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            60u8 => {
                fields.push(segment_lap_message_avg_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            61u8 => {
                fields.push(segment_lap_message_avg_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            62u8 => {
                fields.push(segment_lap_message_avg_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            63u8 => {
                fields.push(segment_lap_message_avg_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            64u8 => {
                fields.push(segment_lap_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            65u8 => {
                fields.push(segment_lap_message_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            66u8 => {
                fields.push(segment_lap_message_avg_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            67u8 => {
                fields.push(segment_lap_message_max_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            68u8 => {
                fields.push(segment_lap_message_total_fractional_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "cycles",
                    value,
                )?);
            }
            69u8 => {
                fields.push(segment_lap_message_front_gear_shift_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            70u8 => {
                fields.push(segment_lap_message_rear_gear_shift_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            71u8 => {
                fields.push(segment_lap_message_time_standing_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            72u8 => {
                fields.push(segment_lap_message_stand_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            73u8 => {
                fields.push(segment_lap_message_avg_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            74u8 => {
                fields.push(segment_lap_message_avg_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            75u8 => {
                fields.push(segment_lap_message_avg_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            76u8 => {
                fields.push(segment_lap_message_avg_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            77u8 => {
                fields.push(segment_lap_message_avg_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            78u8 => {
                fields.push(segment_lap_message_avg_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            79u8 => {
                fields.push(segment_lap_message_avg_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            80u8 => {
                fields.push(segment_lap_message_max_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            81u8 => {
                fields.push(segment_lap_message_avg_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            82u8 => {
                fields.push(segment_lap_message_max_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            83u8 => {
                fields.push(segment_lap_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            84u8 => {
                fields.push(segment_lap_message_total_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            85u8 => {
                fields.push(segment_lap_message_total_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            86u8 => {
                fields.push(segment_lap_message_avg_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            87u8 => {
                fields.push(segment_lap_message_avg_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            89u8 => {
                fields.push(segment_lap_message_total_fractional_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            90u8 => {
                fields.push(segment_lap_message_total_fractional_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            91u8 => {
                fields.push(segment_lap_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            92u8 => {
                fields.push(segment_lap_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            93u8 => {
                fields.push(segment_lap_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            253u8 => {
                fields.push(segment_lap_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(segment_lap_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_lap_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_start_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "start_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_start_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "start_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_end_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "end_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_end_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "end_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strokes"
    };
    data_field_with_info(
        10u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "total_fat_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "max_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "avg_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        None,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        None,
        "avg_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        None,
        "max_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        None,
        "avg_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        None,
        "max_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        None,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_nec_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        None,
        "nec_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_nec_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        None,
        "nec_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_swc_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        None,
        "swc_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_swc_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        None,
        "swc_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        None,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_normalized_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        None,
        "normalized_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31u8, value)?
    } else {
        value
    };
    data_field_with_info(
        31u8,
        None,
        "left_right_balance",
        FieldDataType::LeftRightBalance100,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        None,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_work_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33u8, value)?
    } else {
        value
    };
    data_field_with_info(
        33u8,
        None,
        "total_work",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34u8, value)?
    } else {
        value
    };
    data_field_with_info(
        34u8,
        None,
        "avg_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 35u8, value)?
    } else {
        value
    };
    data_field_with_info(
        35u8,
        None,
        "max_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 36u8, value)?
    } else {
        value
    };
    data_field_with_info(
        36u8,
        None,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37u8, value)?
    } else {
        value
    };
    data_field_with_info(
        37u8,
        None,
        "avg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 38u8, value)?
    } else {
        value
    };
    data_field_with_info(
        38u8,
        None,
        "avg_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        None,
        "avg_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40u8, value)?
    } else {
        value
    };
    data_field_with_info(
        40u8,
        None,
        "max_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41u8, value)?
    } else {
        value
    };
    data_field_with_info(
        41u8,
        None,
        "max_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42u8, value)?
    } else {
        value
    };
    data_field_with_info(
        42u8,
        None,
        "avg_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43u8, value)?
    } else {
        value
    };
    data_field_with_info(
        43u8,
        None,
        "max_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44u8, value)?
    } else {
        value
    };
    data_field_with_info(
        44u8,
        None,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45u8, value)?
    } else {
        value
    };
    data_field_with_info(
        45u8,
        None,
        "avg_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46u8, value)?
    } else {
        value
    };
    data_field_with_info(
        46u8,
        None,
        "avg_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        None,
        "max_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48u8, value)?
    } else {
        value
    };
    data_field_with_info(
        48u8,
        None,
        "max_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49u8, value)?
    } else {
        value
    };
    data_field_with_info(
        49u8,
        None,
        "time_in_hr_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50u8, value)?
    } else {
        value
    };
    data_field_with_info(
        50u8,
        None,
        "time_in_speed_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51u8, value)?
    } else {
        value
    };
    data_field_with_info(
        51u8,
        None,
        "time_in_cadence_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52u8, value)?
    } else {
        value
    };
    data_field_with_info(
        52u8,
        None,
        "time_in_power_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_repetition_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53u8, value)?
    } else {
        value
    };
    data_field_with_info(
        53u8,
        None,
        "repetition_num",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54u8, value)?
    } else {
        value
    };
    data_field_with_info(
        54u8,
        None,
        "min_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_min_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55u8, value)?
    } else {
        value
    };
    data_field_with_info(
        55u8,
        None,
        "min_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_active_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56u8, value)?
    } else {
        value
    };
    data_field_with_info(
        56u8,
        None,
        "active_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_wkt_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57u8, value)?
    } else {
        value
    };
    data_field_with_info(
        57u8,
        None,
        "wkt_step_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_sport_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58u8, value)?
    } else {
        value
    };
    data_field_with_info(
        58u8,
        None,
        "sport_event",
        FieldDataType::SportEvent,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59u8, value)?
    } else {
        value
    };
    data_field_with_info(
        59u8,
        None,
        "avg_left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 60u8, value)?
    } else {
        value
    };
    data_field_with_info(
        60u8,
        None,
        "avg_right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 61u8, value)?
    } else {
        value
    };
    data_field_with_info(
        61u8,
        None,
        "avg_left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62u8, value)?
    } else {
        value
    };
    data_field_with_info(
        62u8,
        None,
        "avg_right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 63u8, value)?
    } else {
        value
    };
    data_field_with_info(
        63u8,
        None,
        "avg_combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 64u8, value)?
    } else {
        value
    };
    data_field_with_info(
        64u8,
        None,
        "status",
        FieldDataType::SegmentLapStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 65u8, value)?
    } else {
        value
    };
    data_field_with_info(
        65u8,
        None,
        "uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 66u8, value)?
    } else {
        value
    };
    data_field_with_info(
        66u8,
        None,
        "avg_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 67u8, value)?
    } else {
        value
    };
    data_field_with_info(
        67u8,
        None,
        "max_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fractional_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 68u8, value)?
    } else {
        value
    };
    data_field_with_info(
        68u8,
        None,
        "total_fractional_cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_front_gear_shift_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 69u8, value)?
    } else {
        value
    };
    data_field_with_info(
        69u8,
        None,
        "front_gear_shift_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_rear_gear_shift_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 70u8, value)?
    } else {
        value
    };
    data_field_with_info(
        70u8,
        None,
        "rear_gear_shift_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_standing_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71u8, value)?
    } else {
        value
    };
    data_field_with_info(
        71u8,
        None,
        "time_standing",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_stand_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 72u8, value)?
    } else {
        value
    };
    data_field_with_info(
        72u8,
        None,
        "stand_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 73u8, value)?
    } else {
        value
    };
    data_field_with_info(
        73u8,
        None,
        "avg_left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 74u8, value)?
    } else {
        value
    };
    data_field_with_info(
        74u8,
        None,
        "avg_right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 75u8, value)?
    } else {
        value
    };
    data_field_with_info(
        75u8,
        None,
        "avg_left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 76u8, value)?
    } else {
        value
    };
    data_field_with_info(
        76u8,
        None,
        "avg_left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 77u8, value)?
    } else {
        value
    };
    data_field_with_info(
        77u8,
        None,
        "avg_right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 78u8, value)?
    } else {
        value
    };
    data_field_with_info(
        78u8,
        None,
        "avg_right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 79u8, value)?
    } else {
        value
    };
    data_field_with_info(
        79u8,
        None,
        "avg_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 80u8, value)?
    } else {
        value
    };
    data_field_with_info(
        80u8,
        None,
        "max_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 81u8, value)?
    } else {
        value
    };
    data_field_with_info(
        81u8,
        None,
        "avg_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82u8, value)?
    } else {
        value
    };
    data_field_with_info(
        82u8,
        None,
        "max_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83u8, value)?
    } else {
        value
    };
    data_field_with_info(
        83u8,
        None,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84u8, value)?
    } else {
        value
    };
    data_field_with_info(
        84u8,
        None,
        "total_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85u8, value)?
    } else {
        value
    };
    data_field_with_info(
        85u8,
        None,
        "total_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86u8, value)?
    } else {
        value
    };
    data_field_with_info(
        86u8,
        None,
        "avg_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 87u8, value)?
    } else {
        value
    };
    data_field_with_info(
        87u8,
        None,
        "avg_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fractional_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89u8, value)?
    } else {
        value
    };
    data_field_with_info(
        89u8,
        None,
        "total_fractional_ascent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fractional_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 90u8, value)?
    } else {
        value
    };
    data_field_with_info(
        90u8,
        None,
        "total_fractional_descent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_enhanced_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 91u8, value)?
    } else {
        value
    };
    data_field_with_info(
        91u8,
        None,
        "enhanced_avg_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_enhanced_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 92u8, value)?
    } else {
        value
    };
    data_field_with_info(
        92u8,
        None,
        "enhanced_max_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_enhanced_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 93u8, value)?
    } else {
        value
    };
    data_field_with_info(
        93u8,
        None,
        "enhanced_min_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Summary of the unique segment and leaderboard information associated with a segment file. This message is used to compile a segment list file describing all segment files on a device. The segment list file is used when refreshing the contents of a segment file with the latest available leaderboard information."]
#[doc = " * file_uuid: UUID of the segment file"]
#[doc = " * enabled: Enabled state of the segment file"]
#[doc = " * user_profile_primary_key: Primary key of the user that created the segment file"]
#[doc = " * leader_type: Leader type of each leader in the segment file"]
#[doc = " * leader_group_primary_key: Group primary key of each leader in the segment file"]
#[doc = " * leader_activity_id: Activity ID of each leader in the segment file"]
#[doc = " * leader_activity_id_string: String version of the activity ID of each leader in the segment file. 21 characters long for each ID, express in decimal"]
#[doc = " * default_race_leader: Index for the Leader Board entry selected as the default race participant"]
fn segment_file_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            1u8 => {
                fields.push(segment_file_message_file_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(segment_file_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(segment_file_message_user_profile_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(segment_file_message_leader_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(segment_file_message_leader_group_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(segment_file_message_leader_activity_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(segment_file_message_leader_activity_id_string_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(segment_file_message_default_race_leader_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(segment_file_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_file_message_file_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "file_uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_user_profile_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "user_profile_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "leader_type",
        FieldDataType::SegmentLeaderboardType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_group_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "leader_group_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_activity_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "leader_activity_id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_activity_id_string_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "leader_activity_id_string",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_default_race_leader_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "default_race_leader",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "workout message definition"]
#[doc = " * num_valid_steps: number of valid steps"]
#[doc = " * wkt_description: Description of the workout"]
fn workout_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            4u8 => {
                fields.push(workout_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(workout_message_capabilities_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(workout_message_num_valid_steps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(workout_message_wkt_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(workout_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(workout_message_pool_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            15u8 => {
                fields.push(workout_message_pool_length_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            17u8 => {
                fields.push(workout_message_wkt_description_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(workout_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn workout_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_capabilities_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "capabilities",
        FieldDataType::WorkoutCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_num_valid_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "num_valid_steps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_wkt_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "wkt_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_pool_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "pool_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_pool_length_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "pool_length_unit",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_wkt_description_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        None,
        "wkt_description",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "workout_session message definition"]
fn workout_session_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(workout_session_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(workout_session_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(workout_session_message_num_valid_steps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(workout_session_message_first_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(workout_session_message_pool_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            5u8 => {
                fields.push(workout_session_message_pool_length_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(workout_session_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn workout_session_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_num_valid_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "num_valid_steps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_first_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "first_step_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_pool_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "pool_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_pool_length_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "pool_length_unit",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "workout_step message definition"]
#[doc = " * duration_step: message_index of step to loop back to. Steps are assumed to be in the order by message_index. custom_name and intensity members are undefined for this duration type."]
#[doc = " * target_speed_zone: speed zone (1-10);Custom =0;"]
#[doc = " * target_hr_zone: hr zone (1-5);Custom =0;"]
#[doc = " * target_cadence_zone: Zone (1-?); Custom = 0;"]
#[doc = " * target_power_zone: Power Zone ( 1-7); Custom = 0;"]
#[doc = " * repeat_steps: # of repetitions"]
#[doc = " * secondary_target_speed_zone: speed zone (1-10);Custom =0;"]
#[doc = " * secondary_target_hr_zone: hr zone (1-5);Custom =0;"]
#[doc = " * secondary_target_cadence_zone: Zone (1-?); Custom = 0;"]
#[doc = " * secondary_target_power_zone: Power Zone ( 1-7); Custom = 0;"]
fn workout_step_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(workout_step_message_wkt_step_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(workout_step_message_duration_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if WktStepDuration::Time.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_time_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "s",
                        value,
                    )?);
                } else if WktStepDuration::RepetitionTime.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_time_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "s",
                        value,
                    )?);
                } else if WktStepDuration::Distance.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_distance_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100f64,
                        0f64,
                        "m",
                        value,
                    )?);
                } else if WktStepDuration::HrLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::HrGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::Calories.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_calories_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "calories",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilStepsCmplt.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilTime.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilDistance.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilCalories.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::PowerLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepDuration::PowerGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepDuration::Reps.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_reps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_duration_value_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            3u8 => {
                fields.push(workout_step_message_target_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_speed_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_hr_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_cadence_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_power_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilStepsCmplt.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_steps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilTime.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_time_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "s",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilDistance.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_distance_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100f64,
                        0f64,
                        "m",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilCalories.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_calories_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "calories",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepTarget::SwimStroke.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_stroke_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_target_value_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            5u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_speed_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_heart_rate_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_cadence_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_power_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_custom_target_value_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            6u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_speed_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_heart_rate_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_cadence_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&3u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_power_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_custom_target_value_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            7u8 => {
                fields.push(workout_step_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(workout_step_message_notes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(workout_step_message_equipment_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(workout_step_message_exercise_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(workout_step_message_exercise_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(workout_step_message_exercise_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            13u8 => {
                fields.push(workout_step_message_weight_display_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            19u8 => {
                fields.push(workout_step_message_secondary_target_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            20u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_speed_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_hr_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_cadence_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_power_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::SwimStroke.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_stroke_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_secondary_target_value_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            21u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_speed_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1000f64,
                            0f64,
                            "m/s",
                            value,
                        )?,
                    );
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_heart_rate_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "% or bpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_cadence_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "rpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_power_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "% or watts",
                            value,
                        )?,
                    );
                } else {
                    fields.push(
                        workout_step_message_secondary_custom_target_value_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "",
                            value,
                        )?,
                    );
                }
            }
            22u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_speed_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1000f64,
                            0f64,
                            "m/s",
                            value,
                        )?,
                    );
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_heart_rate_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "% or bpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_cadence_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "rpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&19u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_power_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "% or watts",
                            value,
                        )?,
                    );
                } else {
                    fields.push(
                        workout_step_message_secondary_custom_target_value_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "",
                            value,
                        )?,
                    );
                }
            }
            254u8 => {
                fields.push(workout_step_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn workout_step_message_wkt_step_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "wkt_step_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "duration_type",
        FieldDataType::WktStepDuration,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "duration_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_time"
    };
    data_field_with_info(
        2u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_distance"
    };
    data_field_with_info(
        2u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_hr_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_hr"
    };
    data_field_with_info(
        2u8,
        None,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_calories"
    };
    data_field_with_info(
        2u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_step_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_step"
    };
    data_field_with_info(
        2u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_power"
    };
    data_field_with_info(
        2u8,
        None,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_reps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_reps"
    };
    data_field_with_info(
        2u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "target_type",
        FieldDataType::WktStepTarget,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "target_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_speed_zone"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_hr_zone"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_cadence_zone"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_power_zone"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_steps"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_time"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_distance"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_calories"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_hr_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_hr"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_power"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_stroke_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_stroke_type"
    };
    data_field_with_info(
        4u8,
        None,
        name,
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_value_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "custom_target_value_low",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_speed_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_speed_low"
    };
    data_field_with_info(
        5u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_heart_rate_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_heart_rate_low"
    };
    data_field_with_info(
        5u8,
        None,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_cadence_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_cadence_low"
    };
    data_field_with_info(
        5u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_power_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_power_low"
    };
    data_field_with_info(
        5u8,
        None,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_value_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "custom_target_value_high",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_speed_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_speed_high"
    };
    data_field_with_info(
        6u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_heart_rate_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_heart_rate_high"
    };
    data_field_with_info(
        6u8,
        None,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_cadence_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_cadence_high"
    };
    data_field_with_info(
        6u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_power_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_power_high"
    };
    data_field_with_info(
        6u8,
        None,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "intensity",
        FieldDataType::Intensity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_notes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "notes",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_equipment_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "equipment",
        FieldDataType::WorkoutEquipment,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_exercise_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "exercise_category",
        FieldDataType::ExerciseCategory,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_exercise_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "exercise_name",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_exercise_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "exercise_weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_weight_display_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "weight_display_unit",
        FieldDataType::FitBaseUnit,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        None,
        "secondary_target_type",
        FieldDataType::WktStepTarget,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        None,
        "secondary_target_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_speed_zone"
    };
    data_field_with_info(
        20u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_hr_zone"
    };
    data_field_with_info(
        20u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_cadence_zone"
    };
    data_field_with_info(
        20u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_power_zone"
    };
    data_field_with_info(
        20u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_stroke_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_stroke_type"
    };
    data_field_with_info(
        20u8,
        None,
        name,
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_value_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        None,
        "secondary_custom_target_value_low",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_speed_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_speed_low"
    };
    data_field_with_info(
        21u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_heart_rate_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_heart_rate_low"
    };
    data_field_with_info(
        21u8,
        None,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_cadence_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_cadence_low"
    };
    data_field_with_info(
        21u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_power_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_power_low"
    };
    data_field_with_info(
        21u8,
        None,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_value_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "secondary_custom_target_value_high",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_speed_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_speed_high"
    };
    data_field_with_info(
        22u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_heart_rate_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_heart_rate_high"
    };
    data_field_with_info(
        22u8,
        None,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_cadence_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_cadence_high"
    };
    data_field_with_info(
        22u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_power_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_power_high"
    };
    data_field_with_info(
        22u8,
        None,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "exercise_title message definition"]
fn exercise_title_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(exercise_title_message_exercise_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(exercise_title_message_exercise_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(exercise_title_message_wkt_step_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(exercise_title_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exercise_title_message_exercise_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "exercise_category",
        FieldDataType::ExerciseCategory,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exercise_title_message_exercise_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "exercise_name",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exercise_title_message_wkt_step_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "wkt_step_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exercise_title_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "schedule message definition"]
#[doc = " * manufacturer: Corresponds to file_id of scheduled workout / course."]
#[doc = " * product: Corresponds to file_id of scheduled workout / course."]
#[doc = " * serial_number: Corresponds to file_id of scheduled workout / course."]
#[doc = " * time_created: Corresponds to file_id of scheduled workout / course."]
#[doc = " * completed: TRUE if this activity has been started"]
fn schedule_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(schedule_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&0u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(schedule_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            2u8 => {
                fields.push(schedule_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(schedule_message_time_created_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(schedule_message_completed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(schedule_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(schedule_message_scheduled_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn schedule_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        1u8,
        None,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_time_created_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "time_created",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_completed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "completed",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "type",
        FieldDataType::Schedule,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_scheduled_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "scheduled_time",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "totals message definition"]
#[doc = " * timer_time: Excludes pauses"]
#[doc = " * elapsed_time: Includes pauses"]
fn totals_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(totals_message_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(totals_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            2u8 => {
                fields.push(totals_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            3u8 => {
                fields.push(totals_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(totals_message_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(totals_message_sessions_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(totals_message_active_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            9u8 => {
                fields.push(totals_message_sport_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(totals_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(totals_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn totals_message_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "calories",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_sessions_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "sessions",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_active_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "active_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_sport_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "sport_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        None,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "weight_scale message definition"]
#[doc = " * active_met: ~4kJ per kcal, 0.25 allows max 16384 kcal"]
#[doc = " * user_profile_index: Associates this weight scale message to a user. This corresponds to the index of the user profile message in the weight scale file."]
fn weight_scale_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(weight_scale_message_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            1u8 => {
                fields.push(weight_scale_message_percent_fat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            2u8 => {
                fields.push(weight_scale_message_percent_hydration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            3u8 => {
                fields.push(weight_scale_message_visceral_fat_mass_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            4u8 => {
                fields.push(weight_scale_message_bone_mass_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            5u8 => {
                fields.push(weight_scale_message_muscle_mass_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            7u8 => {
                fields.push(weight_scale_message_basal_met_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    4f64,
                    0f64,
                    "kcal/day",
                    value,
                )?);
            }
            8u8 => {
                fields.push(weight_scale_message_physique_rating_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(weight_scale_message_active_met_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    4f64,
                    0f64,
                    "kcal/day",
                    value,
                )?);
            }
            10u8 => {
                fields.push(weight_scale_message_metabolic_age_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "years",
                    value,
                )?);
            }
            11u8 => {
                fields.push(weight_scale_message_visceral_fat_rating_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(weight_scale_message_user_profile_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(weight_scale_message_bmi_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "kg/m^2",
                    value,
                )?);
            }
            253u8 => {
                fields.push(weight_scale_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn weight_scale_message_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "weight",
        FieldDataType::Weight,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_percent_fat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "percent_fat",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_percent_hydration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "percent_hydration",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_visceral_fat_mass_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "visceral_fat_mass",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_bone_mass_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "bone_mass",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_muscle_mass_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "muscle_mass",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_basal_met_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "basal_met",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_physique_rating_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "physique_rating",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_active_met_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "active_met",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_metabolic_age_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "metabolic_age",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_visceral_fat_rating_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "visceral_fat_rating",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_user_profile_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "user_profile_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_bmi_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "bmi",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "blood_pressure message definition"]
#[doc = " * user_profile_index: Associates this blood pressure message to a user. This corresponds to the index of the user profile message in the blood pressure file."]
fn blood_pressure_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(blood_pressure_message_systolic_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            1u8 => {
                fields.push(blood_pressure_message_diastolic_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            2u8 => {
                fields.push(blood_pressure_message_mean_arterial_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            3u8 => {
                fields.push(blood_pressure_message_map_3_sample_mean_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            4u8 => {
                fields.push(blood_pressure_message_map_morning_values_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            5u8 => {
                fields.push(blood_pressure_message_map_evening_values_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            6u8 => {
                fields.push(blood_pressure_message_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            7u8 => {
                fields.push(blood_pressure_message_heart_rate_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(blood_pressure_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(blood_pressure_message_user_profile_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(blood_pressure_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn blood_pressure_message_systolic_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "systolic_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_diastolic_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "diastolic_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_mean_arterial_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "mean_arterial_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_map_3_sample_mean_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "map_3_sample_mean",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_map_morning_values_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "map_morning_values",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_map_evening_values_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "map_evening_values",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_heart_rate_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "heart_rate_type",
        FieldDataType::HrType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "status",
        FieldDataType::BpStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_user_profile_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "user_profile_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "monitoring_info message definition"]
#[doc = " * local_timestamp: Use to convert activity timestamps to local time if device does not support time zone and daylight savings time correction."]
#[doc = " * cycles_to_distance: Indexed by activity_type"]
#[doc = " * cycles_to_calories: Indexed by activity_type"]
fn monitoring_info_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(monitoring_info_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(monitoring_info_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(monitoring_info_message_cycles_to_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5000f64,
                    0f64,
                    "m/cycle",
                    value,
                )?);
            }
            4u8 => {
                fields.push(monitoring_info_message_cycles_to_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5000f64,
                    0f64,
                    "kcal/cycle",
                    value,
                )?);
            }
            5u8 => {
                fields.push(monitoring_info_message_resting_metabolic_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal / day",
                    value,
                )?);
            }
            253u8 => {
                fields.push(monitoring_info_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn monitoring_info_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_activity_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "activity_type",
        FieldDataType::ActivityType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_cycles_to_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "cycles_to_distance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_cycles_to_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "cycles_to_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_resting_metabolic_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "resting_metabolic_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "monitoring message definition"]
#[doc = " * device_index: Associates this data to device_info message. Not required for file with single device (sensor)."]
#[doc = " * calories: Accumulated total calories. Maintained by MonitoringReader for each activity_type. See SDK documentation"]
#[doc = " * distance: Accumulated distance. Maintained by MonitoringReader for each activity_type. See SDK documentation."]
#[doc = " * cycles: Accumulated cycles. Maintained by MonitoringReader for each activity_type. See SDK documentation."]
#[doc = " * local_timestamp: Must align to logging interval, for example, time must be 00:00:00 for daily log."]
#[doc = " * temperature: Avg temperature during the logging interval ended at timestamp"]
#[doc = " * temperature_min: Min temperature during the logging interval ended at timestamp"]
#[doc = " * temperature_max: Max temperature during the logging interval ended at timestamp"]
#[doc = " * activity_time: Indexed using minute_activity_level enum"]
#[doc = " * current_activity_type_intensity: Indicates single type / intensity for duration since last monitoring message."]
#[doc = " * timestamp: Must align to logging interval, for example, time must be 00:00:00 for daily log."]
fn monitoring_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(monitoring_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(monitoring_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            2u8 => {
                fields.push(monitoring_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            3u8 => {
                if ActivityType::Walking.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_steps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "steps",
                        value,
                    )?);
                } else if ActivityType::Running.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_steps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "steps",
                        value,
                    )?);
                } else if ActivityType::Cycling.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        2f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if ActivityType::Swimming.as_i64()
                    == data_map
                        .get(&5u8)
                        .and_then(|v| v.try_into().ok())
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        2f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(monitoring_message_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        2f64,
                        0f64,
                        "cycles",
                        value,
                    )?);
                }
            }
            4u8 => {
                fields.push(monitoring_message_active_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(monitoring_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(monitoring_message_activity_subtype_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(monitoring_message_activity_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(monitoring_message_distance_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "100 * m",
                    value,
                )?);
            }
            9u8 => {
                fields.push(monitoring_message_cycles_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "2 * cycles (steps)",
                    value,
                )?);
            }
            10u8 => {
                fields.push(monitoring_message_active_time_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            11u8 => {
                fields.push(monitoring_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(monitoring_message_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            14u8 => {
                fields.push(monitoring_message_temperature_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            15u8 => {
                fields.push(monitoring_message_temperature_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            16u8 => {
                fields.push(monitoring_message_activity_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "minutes",
                    value,
                )?);
            }
            19u8 => {
                fields.push(monitoring_message_active_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            24u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(monitoring_message_current_activity_type_intensity_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), activity_type) = extract_component(&input, 0usize, 5);
                let ((input, offset), intensity) = extract_component(input, offset, 3);
                data_map.insert(5u8, activity_type.clone());
                fields.push(monitoring_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    activity_type,
                )?);
                data_map.insert(28u8, intensity.clone());
                fields.push(monitoring_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    intensity,
                )?);
            }
            25u8 => {
                fields.push(monitoring_message_timestamp_min_8_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "min",
                    value,
                )?);
            }
            26u8 => {
                fields.push(monitoring_message_timestamp_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            27u8 => {
                fields.push(monitoring_message_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            28u8 => {
                fields.push(monitoring_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            29u8 => {
                fields.push(monitoring_message_duration_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "min",
                    value,
                )?);
            }
            30u8 => {
                fields.push(monitoring_message_duration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            31u8 => {
                fields.push(monitoring_message_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            32u8 => {
                fields.push(monitoring_message_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            33u8 => {
                fields.push(monitoring_message_moderate_activity_minutes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "minutes",
                    value,
                )?);
            }
            34u8 => {
                fields.push(monitoring_message_vigorous_activity_minutes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "minutes",
                    value,
                )?);
            }
            253u8 => {
                fields.push(monitoring_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn monitoring_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "cycles"
    } else {
        "steps"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "cycles"
    } else {
        "strokes"
    };
    data_field_with_info(
        3u8,
        None,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_active_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "active_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "activity_type",
        FieldDataType::ActivityType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_subtype_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "activity_subtype",
        FieldDataType::ActivitySubtype,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "activity_level",
        FieldDataType::ActivityLevel,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_distance_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "distance_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_cycles_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "cycles_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_active_time_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "active_time_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "temperature",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_temperature_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "temperature_min",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_temperature_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "temperature_max",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        None,
        "activity_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_active_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        None,
        "active_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_current_activity_type_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        None,
        "current_activity_type_intensity",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_timestamp_min_8_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        None,
        "timestamp_min_8",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_timestamp_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        None,
        "timestamp_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        None,
        "heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        None,
        "intensity",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_duration_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        None,
        "duration_min",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_duration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        None,
        "duration",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31u8, value)?
    } else {
        value
    };
    data_field_with_info(
        31u8,
        None,
        "ascent",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        None,
        "descent",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_moderate_activity_minutes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33u8, value)?
    } else {
        value
    };
    data_field_with_info(
        33u8,
        None,
        "moderate_activity_minutes",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_vigorous_activity_minutes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34u8, value)?
    } else {
        value
    };
    data_field_with_info(
        34u8,
        None,
        "vigorous_activity_minutes",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "monitoring_hr_data message definition"]
#[doc = " * resting_heart_rate: 7-day rolling average"]
#[doc = " * current_day_resting_heart_rate: RHR for today only. (Feeds into 7-day average)"]
#[doc = " * timestamp: Must align to logging interval, for example, time must be 00:00:00 for daily log."]
fn monitoring_hr_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(monitoring_hr_data_message_resting_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            1u8 => {
                fields.push(
                    monitoring_hr_data_message_current_day_resting_heart_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "bpm",
                        value,
                    )?,
                );
            }
            253u8 => {
                fields.push(monitoring_hr_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn monitoring_hr_data_message_resting_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "resting_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_hr_data_message_current_day_resting_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "current_day_resting_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_hr_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "spo2_data message definition"]
#[doc = " * mode: Mode when data was captured"]
fn spo2_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(spo2_data_message_reading_spo2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            1u8 => {
                fields.push(spo2_data_message_reading_confidence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(spo2_data_message_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(spo2_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn spo2_data_message_reading_spo2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "reading_spo2",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn spo2_data_message_reading_confidence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "reading_confidence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn spo2_data_message_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "mode",
        FieldDataType::Spo2MeasurementType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn spo2_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "hr message definition"]
fn hr_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hr_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(hr_message_time256_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        256f64,
                        0f64,
                        "s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), fractional_timestamp) = extract_component(&input, 0usize, 8);
                data_map.insert(0u8, fractional_timestamp.clone());
                fields.push(hr_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256f64,
                    0f64,
                    "s",
                    fractional_timestamp,
                )?);
            }
            6u8 => {
                fields.push(hr_message_filtered_bpm_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            9u8 => {
                fields.push(hr_message_event_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1024f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            10u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(hr_message_event_timestamp_12_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), event_timestamp_1) = extract_component(&input, 0usize, 12);
                let ((input, offset), event_timestamp_2) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_3) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_4) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_5) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_6) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_7) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_8) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_9) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_10) = extract_component(input, offset, 12);
                let event_timestamp = Value::Array(vec![
                    event_timestamp_1,
                    event_timestamp_2,
                    event_timestamp_3,
                    event_timestamp_4,
                    event_timestamp_5,
                    event_timestamp_6,
                    event_timestamp_7,
                    event_timestamp_8,
                    event_timestamp_9,
                    event_timestamp_10,
                ]);
                data_map.insert(9u8, event_timestamp.clone());
                fields.push(hr_message_event_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    1024f64,
                    0f64,
                    "s",
                    event_timestamp,
                )?);
            }
            253u8 => {
                fields.push(hr_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hr_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_time256_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "time256",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_filtered_bpm_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "filtered_bpm",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_event_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "event_timestamp",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_event_timestamp_12_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "event_timestamp_12",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Value from 1 to 100 calculated by FirstBeat"]
#[doc = " * stress_level_time: Time stress score was calculated"]
fn stress_level_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(stress_level_message_stress_level_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(stress_level_message_stress_level_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn stress_level_message_stress_level_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "stress_level_value",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn stress_level_message_stress_level_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "stress_level_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "max_met_data message definition"]
#[doc = " * update_time: Time maxMET and vo2 were calculated"]
#[doc = " * calibrated_data: Indicates if calibrated data was used in the calculation"]
#[doc = " * hr_source: Indicates if the estimate was obtained using a chest strap or wrist heart rate"]
#[doc = " * speed_source: Indidcates if the estimate was obtained using onboard GPS or connected GPS"]
fn max_met_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(max_met_data_message_update_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(max_met_data_message_vo2_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mL/kg/min",
                    value,
                )?);
            }
            5u8 => {
                fields.push(max_met_data_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(max_met_data_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(max_met_data_message_max_met_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(max_met_data_message_calibrated_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(max_met_data_message_hr_source_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(max_met_data_message_speed_source_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn max_met_data_message_update_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "update_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_vo2_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "vo2_max",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_max_met_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "max_met_category",
        FieldDataType::MaxMetCategory,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_calibrated_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "calibrated_data",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_hr_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "hr_source",
        FieldDataType::MaxMetHeartRateSource,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_speed_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "speed_source",
        FieldDataType::MaxMetSpeedSource,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Body battery data used for HSA custom data logging"]
#[doc = " * processing_interval: Processing interval length in seconds"]
#[doc = " * level: Body battery level: [0,100] Blank: -16"]
#[doc = " * charged: Body battery charged value"]
#[doc = " * uncharged: Body battery uncharged value"]
fn hsa_body_battery_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hsa_body_battery_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_body_battery_data_message_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hsa_body_battery_data_message_charged_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(hsa_body_battery_data_message_uncharged_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_body_battery_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_body_battery_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_body_battery_data_message_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "level",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_body_battery_data_message_charged_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "charged",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_body_battery_data_message_uncharged_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "uncharged",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_body_battery_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "HSA events"]
#[doc = " * event_id: Event ID. Health SDK use only"]
fn hsa_event_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hsa_event_message_event_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_event_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_event_message_event_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "event_id",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_event_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Raw accelerometer data used for HSA custom data logging"]
#[doc = " * timestamp_ms: Millisecond resolution of the timestamp"]
#[doc = " * sampling_interval: Sampling Interval in Milliseconds"]
#[doc = " * accel_x: X-Axis Measurement"]
#[doc = " * accel_y: Y-Axis Measurement"]
#[doc = " * accel_z: Z-Axis Measurement"]
#[doc = " * timestamp_32k: 32 kHz timestamp"]
fn hsa_accelerometer_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hsa_accelerometer_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_accelerometer_data_message_sampling_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hsa_accelerometer_data_message_accel_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.024f64,
                    0f64,
                    "mG",
                    value,
                )?);
            }
            3u8 => {
                fields.push(hsa_accelerometer_data_message_accel_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.024f64,
                    0f64,
                    "mG",
                    value,
                )?);
            }
            4u8 => {
                fields.push(hsa_accelerometer_data_message_accel_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.024f64,
                    0f64,
                    "mG",
                    value,
                )?);
            }
            5u8 => {
                fields.push(hsa_accelerometer_data_message_timestamp_32k_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_accelerometer_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_accelerometer_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_sampling_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sampling_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_accel_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "accel_x",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_accel_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "accel_y",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_accel_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "accel_z",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_timestamp_32k_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "timestamp_32k",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "hsa_gyroscope_data message definition"]
#[doc = " * timestamp_ms: Millisecond resolution of the timestamp"]
#[doc = " * sampling_interval: Sampling Interval in 32 kHz timescale"]
#[doc = " * gyro_x: X-Axis Measurement"]
#[doc = " * gyro_y: Y-Axis Measurement"]
#[doc = " * gyro_z: Z-Axis Measurement"]
#[doc = " * timestamp_32k: 32 kHz timestamp"]
fn hsa_gyroscope_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hsa_gyroscope_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_gyroscope_data_message_sampling_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "1/32768 s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hsa_gyroscope_data_message_gyro_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    28.57143f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            3u8 => {
                fields.push(hsa_gyroscope_data_message_gyro_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    28.57143f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(hsa_gyroscope_data_message_gyro_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    28.57143f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(hsa_gyroscope_data_message_timestamp_32k_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "1/32768 s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_gyroscope_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_gyroscope_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_sampling_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "sampling_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_gyro_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "gyro_x",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_gyro_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "gyro_y",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_gyro_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "gyro_z",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_timestamp_32k_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "timestamp_32k",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "User's current daily step data used for HSA custom data logging"]
#[doc = " * processing_interval: Processing interval length in seconds. File start: 0xFFFFFFEF File stop: 0xFFFFFFEE"]
#[doc = " * steps: Total step sum"]
fn hsa_step_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hsa_step_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_step_data_message_steps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "steps",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_step_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_step_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_step_data_message_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "steps",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_step_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "User's current SpO2 data used for HSA custom data logging"]
#[doc = " * processing_interval: Processing interval length in seconds"]
#[doc = " * reading_spo2: SpO2 Reading: [70,100] Blank: 240"]
#[doc = " * confidence: SpO2 Confidence: [0,254]"]
fn hsa_spo2_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hsa_spo2_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_spo2_data_message_reading_spo2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hsa_spo2_data_message_confidence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_spo2_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_spo2_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_spo2_data_message_reading_spo2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "reading_spo2",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_spo2_data_message_confidence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "confidence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_spo2_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "User's current stress data used for HSA custom data logging"]
#[doc = " * processing_interval: Processing interval length in seconds"]
#[doc = " * stress_level: Stress Level: [0,100] Off wrist: -1 Excess motion: -2 Not enough data: -3 Recovering from exercise: -4 Unidentified: -5 Blank: -16"]
fn hsa_stress_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hsa_stress_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_stress_data_message_stress_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_stress_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_stress_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_stress_data_message_stress_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "stress_level",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_stress_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "User's current respiration data used for HSA custom data logging"]
#[doc = " * processing_interval: Processing interval length in seconds"]
#[doc = " * respiration_rate: Breaths / min: [1,100] Invalid: 255 Excess motion: 254 Off wrist: 253 Not available: 252 Blank: 2.4"]
fn hsa_respiration_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hsa_respiration_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_respiration_data_message_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "breaths/min",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_respiration_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_respiration_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_respiration_data_message_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "respiration_rate",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_respiration_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "User's current heart rate data used for HSA custom data logging"]
#[doc = " * processing_interval: Processing interval length in seconds"]
#[doc = " * status: Status of measurements in buffer - 0 indicates SEARCHING 1 indicates LOCKED"]
#[doc = " * heart_rate: Beats / min. Blank: 0"]
fn hsa_heart_rate_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hsa_heart_rate_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_heart_rate_data_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hsa_heart_rate_data_message_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_heart_rate_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_heart_rate_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_heart_rate_data_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "status",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_heart_rate_data_message_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_heart_rate_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Configuration data for HSA custom data logging"]
#[doc = " * data: Encoded configuration data. Health SDK use only"]
#[doc = " * data_size: Size in bytes of data field"]
#[doc = " * timestamp: Encoded configuration data"]
fn hsa_configuration_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hsa_configuration_data_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_configuration_data_message_data_size_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_configuration_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_configuration_data_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_configuration_data_message_data_size_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "data_size",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_configuration_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Wrist temperature data used for HSA custom data logging"]
#[doc = " * processing_interval: Processing interval length in seconds"]
#[doc = " * value: Wrist temperature reading"]
fn hsa_wrist_temperature_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(
                    hsa_wrist_temperature_data_message_processing_interval_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "s",
                        value,
                    )?,
                );
            }
            1u8 => {
                fields.push(hsa_wrist_temperature_data_message_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "degC",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_wrist_temperature_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_wrist_temperature_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_wrist_temperature_data_message_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_wrist_temperature_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "memo_glob message definition"]
#[doc = " * memo: Deprecated. Use data field."]
#[doc = " * mesg_num: Message Number of the parent message"]
#[doc = " * parent_index: Index of mesg that this glob is associated with."]
#[doc = " * field_num: Field within the parent that this glob is associated with"]
#[doc = " * data: Block of utf8 bytes. Note, mutltibyte characters may be split across adjoining memo_glob messages."]
#[doc = " * part_index: Sequence number of memo blocks"]
fn memo_glob_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(memo_glob_message_memo_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(memo_glob_message_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(memo_glob_message_parent_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(memo_glob_message_field_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(memo_glob_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            250u8 => {
                fields.push(memo_glob_message_part_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn memo_glob_message_memo_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "memo",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_parent_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "parent_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_field_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "field_num",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "data",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_part_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 250u8, value)?
    } else {
        value
    };
    data_field_with_info(
        250u8,
        None,
        "part_index",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "sleep_level message definition"]
fn sleep_level_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(sleep_level_message_sleep_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(sleep_level_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn sleep_level_message_sleep_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "sleep_level",
        FieldDataType::SleepLevel,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_level_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "ant_channel_id message definition"]
fn ant_channel_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(ant_channel_id_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(ant_channel_id_message_device_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(ant_channel_id_message_device_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(ant_channel_id_message_transmission_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(ant_channel_id_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ant_channel_id_message_channel_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "channel_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "device_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_device_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "device_number",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_transmission_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "transmission_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "ant_rx message definition"]
fn ant_rx_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(ant_rx_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(ant_rx_message_mesg_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(ant_rx_message_mesg_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), channel_number) = extract_component(&input, 0usize, 8);
                let ((input, offset), data_1) = extract_component(input, offset, 8);
                let ((input, offset), data_2) = extract_component(input, offset, 8);
                let ((input, offset), data_3) = extract_component(input, offset, 8);
                let ((input, offset), data_4) = extract_component(input, offset, 8);
                let ((input, offset), data_5) = extract_component(input, offset, 8);
                let ((input, offset), data_6) = extract_component(input, offset, 8);
                let ((input, offset), data_7) = extract_component(input, offset, 8);
                let ((input, offset), data_8) = extract_component(input, offset, 8);
                data_map.insert(3u8, channel_number.clone());
                fields.push(ant_rx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    channel_number,
                )?);
                let data = Value::Array(vec![
                    data_1, data_2, data_3, data_4, data_5, data_6, data_7, data_8,
                ]);
                data_map.insert(4u8, data.clone());
                fields.push(ant_rx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    data,
                )?);
            }
            3u8 => {
                fields.push(ant_rx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(ant_rx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(ant_rx_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ant_rx_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_mesg_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "mesg_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_mesg_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "mesg_data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_channel_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "channel_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "ant_tx message definition"]
fn ant_tx_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(ant_tx_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(ant_tx_message_mesg_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(ant_tx_message_mesg_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), channel_number) = extract_component(&input, 0usize, 8);
                let ((input, offset), data_1) = extract_component(input, offset, 8);
                let ((input, offset), data_2) = extract_component(input, offset, 8);
                let ((input, offset), data_3) = extract_component(input, offset, 8);
                let ((input, offset), data_4) = extract_component(input, offset, 8);
                let ((input, offset), data_5) = extract_component(input, offset, 8);
                let ((input, offset), data_6) = extract_component(input, offset, 8);
                let ((input, offset), data_7) = extract_component(input, offset, 8);
                let ((input, offset), data_8) = extract_component(input, offset, 8);
                data_map.insert(3u8, channel_number.clone());
                fields.push(ant_tx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    channel_number,
                )?);
                let data = Value::Array(vec![
                    data_1, data_2, data_3, data_4, data_5, data_6, data_7, data_8,
                ]);
                data_map.insert(4u8, data.clone());
                fields.push(ant_tx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    data,
                )?);
            }
            3u8 => {
                fields.push(ant_tx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(ant_tx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(ant_tx_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ant_tx_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_mesg_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "mesg_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_mesg_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "mesg_data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_channel_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "channel_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "exd_screen_configuration message definition"]
#[doc = " * field_count: number of fields in screen"]
fn exd_screen_configuration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(exd_screen_configuration_message_screen_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(exd_screen_configuration_message_field_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(exd_screen_configuration_message_layout_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(exd_screen_configuration_message_screen_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exd_screen_configuration_message_screen_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "screen_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_screen_configuration_message_field_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "field_count",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_screen_configuration_message_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "layout",
        FieldDataType::ExdLayout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_screen_configuration_message_screen_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "screen_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "exd_data_field_configuration message definition"]
fn exd_data_field_configuration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(exd_data_field_configuration_message_screen_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(exd_data_field_configuration_message_concept_field_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), field_id) = extract_component(&input, 0usize, 4);
                let ((input, offset), concept_count) = extract_component(input, offset, 4);
                data_map.insert(2u8, field_id.clone());
                fields.push(exd_data_field_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    field_id,
                )?);
                data_map.insert(3u8, concept_count.clone());
                fields.push(exd_data_field_configuration_message_concept_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    concept_count,
                )?);
            }
            2u8 => {
                fields.push(exd_data_field_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(exd_data_field_configuration_message_concept_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(exd_data_field_configuration_message_display_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(exd_data_field_configuration_message_title_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exd_data_field_configuration_message_screen_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "screen_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_concept_field_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "concept_field",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_field_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "field_id",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_concept_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "concept_count",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_display_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "display_type",
        FieldDataType::ExdDisplayType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_title_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "title",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "exd_data_concept_configuration message definition"]
fn exd_data_concept_configuration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(exd_data_concept_configuration_message_screen_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(exd_data_concept_configuration_message_concept_field_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), field_id) = extract_component(&input, 0usize, 4);
                let ((input, offset), concept_index) = extract_component(input, offset, 4);
                data_map.insert(2u8, field_id.clone());
                fields.push(exd_data_concept_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    field_id,
                )?);
                data_map.insert(3u8, concept_index.clone());
                fields.push(exd_data_concept_configuration_message_concept_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    concept_index,
                )?);
            }
            2u8 => {
                fields.push(exd_data_concept_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(exd_data_concept_configuration_message_concept_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(exd_data_concept_configuration_message_data_page_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(exd_data_concept_configuration_message_concept_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(exd_data_concept_configuration_message_scaling_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(exd_data_concept_configuration_message_data_units_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(exd_data_concept_configuration_message_qualifier_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(exd_data_concept_configuration_message_descriptor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(exd_data_concept_configuration_message_is_signed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exd_data_concept_configuration_message_screen_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "screen_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_concept_field_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "concept_field",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_field_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "field_id",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_concept_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "concept_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_data_page_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "data_page",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_concept_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "concept_key",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_scaling_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "scaling",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_data_units_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "data_units",
        FieldDataType::ExdDataUnits,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_qualifier_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "qualifier",
        FieldDataType::ExdQualifiers,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_descriptor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "descriptor",
        FieldDataType::ExdDescriptors,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_is_signed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "is_signed",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "dive_summary message definition"]
#[doc = " * avg_depth: 0 if above water"]
#[doc = " * max_depth: 0 if above water"]
#[doc = " * surface_interval: Time since end of last dive"]
#[doc = " * avg_pressure_sac: Average pressure-based surface air consumption"]
#[doc = " * avg_volume_sac: Average volumetric surface air consumption"]
#[doc = " * avg_rmv: Average respiratory minute volume"]
#[doc = " * descent_time: Time to reach deepest level stop"]
#[doc = " * ascent_time: Time after leaving bottom until reaching surface"]
#[doc = " * avg_ascent_rate: Average ascent rate, not including descents or stops"]
#[doc = " * avg_descent_rate: Average descent rate, not including ascents or stops"]
#[doc = " * max_ascent_rate: Maximum ascent rate"]
#[doc = " * max_descent_rate: Maximum descent rate"]
#[doc = " * hang_time: Time spent neither ascending nor descending"]
fn dive_summary_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(dive_summary_message_reference_mesg_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(dive_summary_message_reference_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(dive_summary_message_avg_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            3u8 => {
                fields.push(dive_summary_message_max_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(dive_summary_message_surface_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(dive_summary_message_start_cns_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            6u8 => {
                fields.push(dive_summary_message_end_cns_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            7u8 => {
                fields.push(dive_summary_message_start_n2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            8u8 => {
                fields.push(dive_summary_message_end_n2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            9u8 => {
                fields.push(dive_summary_message_o2_toxicity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "OTUs",
                    value,
                )?);
            }
            10u8 => {
                fields.push(dive_summary_message_dive_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(dive_summary_message_bottom_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            12u8 => {
                fields.push(dive_summary_message_avg_pressure_sac_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "bar/min",
                    value,
                )?);
            }
            13u8 => {
                fields.push(dive_summary_message_avg_volume_sac_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "L/min",
                    value,
                )?);
            }
            14u8 => {
                fields.push(dive_summary_message_avg_rmv_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "L/min",
                    value,
                )?);
            }
            15u8 => {
                fields.push(dive_summary_message_descent_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            16u8 => {
                fields.push(dive_summary_message_ascent_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            17u8 => {
                fields.push(dive_summary_message_avg_ascent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            22u8 => {
                fields.push(dive_summary_message_avg_descent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            23u8 => {
                fields.push(dive_summary_message_max_ascent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            24u8 => {
                fields.push(dive_summary_message_max_descent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            25u8 => {
                fields.push(dive_summary_message_hang_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(dive_summary_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_summary_message_reference_mesg_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "reference_mesg",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_reference_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "reference_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "avg_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_max_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "max_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_surface_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "surface_interval",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_start_cns_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "start_cns",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_end_cns_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "end_cns",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_start_n2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "start_n2",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_end_n2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "end_n2",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_o2_toxicity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "o2_toxicity",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_dive_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "dive_number",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_bottom_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "bottom_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_pressure_sac_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        None,
        "avg_pressure_sac",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_volume_sac_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        None,
        "avg_volume_sac",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_rmv_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "avg_rmv",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_descent_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "descent_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_ascent_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        None,
        "ascent_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_ascent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        None,
        "avg_ascent_rate",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_descent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        None,
        "avg_descent_rate",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_max_ascent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        None,
        "max_ascent_rate",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_max_descent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        None,
        "max_descent_rate",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_hang_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        None,
        "hang_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Number of acclerometer zero crossings summed over the specified time interval"]
#[doc = " * time: Time interval length in seconds"]
#[doc = " * energy_total: Total accelerometer energy in the interval"]
#[doc = " * zero_cross_cnt: Count of zero crossings"]
#[doc = " * instance: Instance ID of zero crossing algorithm"]
#[doc = " * time_above_threshold: Total accelerometer time above threshold in the interval"]
fn aad_accel_features_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(aad_accel_features_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(aad_accel_features_message_energy_total_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(aad_accel_features_message_zero_cross_cnt_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(aad_accel_features_message_instance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(aad_accel_features_message_time_above_threshold_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    25f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(aad_accel_features_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn aad_accel_features_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aad_accel_features_message_energy_total_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "energy_total",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aad_accel_features_message_zero_cross_cnt_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "zero_cross_cnt",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aad_accel_features_message_instance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "instance",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aad_accel_features_message_time_above_threshold_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "time_above_threshold",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aad_accel_features_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Heart rate variability"]
#[doc = " * time: Time between beats"]
fn hrv_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hrv_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hrv_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Array of heart beat intervals"]
#[doc = " * timestamp_ms: Milliseconds past date_time"]
#[doc = " * time: Array of millisecond times between beats"]
fn beat_intervals_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(beat_intervals_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(beat_intervals_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            253u8 => {
                fields.push(beat_intervals_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn beat_intervals_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn beat_intervals_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn beat_intervals_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "hrv_status_summary message definition"]
#[doc = " * weekly_average: 7 day RMSSD average over sleep"]
#[doc = " * last_night_average: Last night RMSSD average over sleep"]
#[doc = " * last_night_5_min_high: 5 minute high RMSSD value over sleep"]
#[doc = " * baseline_low_upper: 3 week baseline, upper boundary of low HRV status"]
#[doc = " * baseline_balanced_lower: 3 week baseline, lower boundary of balanced HRV status"]
#[doc = " * baseline_balanced_upper: 3 week baseline, upper boundary of balanced HRV status"]
fn hrv_status_summary_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hrv_status_summary_message_weekly_average_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hrv_status_summary_message_last_night_average_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hrv_status_summary_message_last_night_5_min_high_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            3u8 => {
                fields.push(hrv_status_summary_message_baseline_low_upper_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            4u8 => {
                fields.push(hrv_status_summary_message_baseline_balanced_lower_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            5u8 => {
                fields.push(hrv_status_summary_message_baseline_balanced_upper_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            6u8 => {
                fields.push(hrv_status_summary_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hrv_status_summary_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hrv_status_summary_message_weekly_average_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "weekly_average",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_last_night_average_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "last_night_average",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_last_night_5_min_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "last_night_5_min_high",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_baseline_low_upper_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "baseline_low_upper",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_baseline_balanced_lower_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "baseline_balanced_lower",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_baseline_balanced_upper_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "baseline_balanced_upper",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "status",
        FieldDataType::HrvStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "hrv_value message definition"]
#[doc = " * value: 5 minute RMSSD"]
fn hrv_value_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(hrv_value_message_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hrv_value_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hrv_value_message_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_value_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Raw Beat-to-Beat Interval values"]
#[doc = " * timestamp_ms: Millisecond resolution of the timestamp"]
#[doc = " * data: 1 bit for gap indicator, 1 bit for quality indicator, and 14 bits for Beat-to-Beat interval values in whole-integer millisecond resolution"]
#[doc = " * time: Array of millisecond times between beats"]
#[doc = " * quality: 1 = high confidence. 0 = low confidence. N/A when gap = 1"]
#[doc = " * gap: 1 = gap (time represents ms gap length). 0 = BBI data"]
fn raw_bbi_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(raw_bbi_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(raw_bbi_message_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), time_1) = extract_component(&input, 0usize, 14);
                let ((input, offset), quality_1) = extract_component(input, offset, 1);
                let ((input, offset), gap_1) = extract_component(input, offset, 1);
                let ((input, offset), time_2) = extract_component(input, offset, 14);
                let ((input, offset), quality_2) = extract_component(input, offset, 1);
                let ((input, offset), gap_2) = extract_component(input, offset, 1);
                let ((input, offset), time_3) = extract_component(input, offset, 14);
                let ((input, offset), quality_3) = extract_component(input, offset, 1);
                let ((input, offset), gap_3) = extract_component(input, offset, 1);
                let ((input, offset), time_4) = extract_component(input, offset, 14);
                let ((input, offset), quality_4) = extract_component(input, offset, 1);
                let ((input, offset), gap_4) = extract_component(input, offset, 1);
                let ((input, offset), time_5) = extract_component(input, offset, 14);
                let ((input, offset), quality_5) = extract_component(input, offset, 1);
                let ((input, offset), gap_5) = extract_component(input, offset, 1);
                let ((input, offset), time_6) = extract_component(input, offset, 14);
                let ((input, offset), quality_6) = extract_component(input, offset, 1);
                let ((input, offset), gap_6) = extract_component(input, offset, 1);
                let ((input, offset), time_7) = extract_component(input, offset, 14);
                let ((input, offset), quality_7) = extract_component(input, offset, 1);
                let ((input, offset), gap_7) = extract_component(input, offset, 1);
                let ((input, offset), time_8) = extract_component(input, offset, 14);
                let ((input, offset), quality_8) = extract_component(input, offset, 1);
                let ((input, offset), gap_8) = extract_component(input, offset, 1);
                let ((input, offset), time_9) = extract_component(input, offset, 14);
                let ((input, offset), quality_9) = extract_component(input, offset, 1);
                let ((input, offset), gap_9) = extract_component(input, offset, 1);
                let ((input, offset), time_10) = extract_component(input, offset, 14);
                let ((input, offset), quality_10) = extract_component(input, offset, 1);
                let ((input, offset), gap_10) = extract_component(input, offset, 1);
                let ((input, offset), time_11) = extract_component(input, offset, 14);
                let ((input, offset), quality_11) = extract_component(input, offset, 1);
                let ((input, offset), gap_11) = extract_component(input, offset, 1);
                let ((input, offset), time_12) = extract_component(input, offset, 14);
                let ((input, offset), quality_12) = extract_component(input, offset, 1);
                let ((input, offset), gap_12) = extract_component(input, offset, 1);
                let ((input, offset), time_13) = extract_component(input, offset, 14);
                let ((input, offset), quality_13) = extract_component(input, offset, 1);
                let ((input, offset), gap_13) = extract_component(input, offset, 1);
                let ((input, offset), time_14) = extract_component(input, offset, 14);
                let ((input, offset), quality_14) = extract_component(input, offset, 1);
                let ((input, offset), gap_14) = extract_component(input, offset, 1);
                let ((input, offset), time_15) = extract_component(input, offset, 14);
                let ((input, offset), quality_15) = extract_component(input, offset, 1);
                let ((input, offset), gap_15) = extract_component(input, offset, 1);
                let time = Value::Array(vec![
                    time_1, time_2, time_3, time_4, time_5, time_6, time_7, time_8, time_9,
                    time_10, time_11, time_12, time_13, time_14, time_15,
                ]);
                data_map.insert(2u8, time.clone());
                fields.push(raw_bbi_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    time,
                )?);
                let quality = Value::Array(vec![
                    quality_1, quality_2, quality_3, quality_4, quality_5, quality_6, quality_7,
                    quality_8, quality_9, quality_10, quality_11, quality_12, quality_13,
                    quality_14, quality_15,
                ]);
                data_map.insert(3u8, quality.clone());
                fields.push(raw_bbi_message_quality_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    quality,
                )?);
                let gap = Value::Array(vec![
                    gap_1, gap_2, gap_3, gap_4, gap_5, gap_6, gap_7, gap_8, gap_9, gap_10, gap_11,
                    gap_12, gap_13, gap_14, gap_15,
                ]);
                data_map.insert(4u8, gap.clone());
                fields.push(raw_bbi_message_gap_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    gap,
                )?);
            }
            2u8 => {
                fields.push(raw_bbi_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            3u8 => {
                fields.push(raw_bbi_message_quality_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(raw_bbi_message_gap_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(raw_bbi_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn raw_bbi_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn raw_bbi_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "data",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn raw_bbi_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn raw_bbi_message_quality_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "quality",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn raw_bbi_message_gap_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "gap",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn raw_bbi_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "respiration_rate message definition"]
#[doc = " * respiration_rate: Breaths * 100 /min, -300 indicates invalid, -200 indicates large motion, -100 indicates off wrist"]
fn respiration_rate_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(respiration_rate_message_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "breaths/min",
                    value,
                )?);
            }
            253u8 => {
                fields.push(respiration_rate_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn respiration_rate_message_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "respiration_rate",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn respiration_rate_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Specifically used for XERO products."]
fn chrono_shot_session_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(chrono_shot_session_message_min_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(chrono_shot_session_message_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(chrono_shot_session_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            3u8 => {
                fields.push(chrono_shot_session_message_shot_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(chrono_shot_session_message_projectile_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(chrono_shot_session_message_grain_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "gr",
                    value,
                )?);
            }
            6u8 => {
                fields.push(chrono_shot_session_message_standard_deviation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(chrono_shot_session_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn chrono_shot_session_message_min_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "min_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_shot_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "shot_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_projectile_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "projectile_type",
        FieldDataType::ProjectileType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_grain_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "grain_weight",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_standard_deviation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "standard_deviation",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Specifically used for XERO products."]
fn chrono_shot_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(chrono_shot_data_message_shot_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(chrono_shot_data_message_shot_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(chrono_shot_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn chrono_shot_data_message_shot_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "shot_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_data_message_shot_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "shot_num",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "tank_update message definition"]
fn tank_update_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(tank_update_message_sensor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(tank_update_message_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "bar",
                    value,
                )?);
            }
            253u8 => {
                fields.push(tank_update_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn tank_update_message_sensor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "sensor",
        FieldDataType::AntChannelId,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_update_message_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_update_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "tank_summary message definition"]
fn tank_summary_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(tank_summary_message_sensor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(tank_summary_message_start_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "bar",
                    value,
                )?);
            }
            2u8 => {
                fields.push(tank_summary_message_end_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "bar",
                    value,
                )?);
            }
            3u8 => {
                fields.push(tank_summary_message_volume_used_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "L",
                    value,
                )?);
            }
            253u8 => {
                fields.push(tank_summary_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn tank_summary_message_sensor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "sensor",
        FieldDataType::AntChannelId,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_summary_message_start_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "start_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_summary_message_end_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "end_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_summary_message_volume_used_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "volume_used",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_summary_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "sleep_assessment message definition"]
#[doc = " * combined_awake_score: Average of awake_time_score and awakenings_count_score. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * awake_time_score: Score that evaluates the total time spent awake between sleep. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * awakenings_count_score: Score that evaluates the number of awakenings that interrupt sleep. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * deep_sleep_score: Score that evaluates the amount of deep sleep. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * sleep_duration_score: Score that evaluates the quality of sleep based on sleep stages, heart-rate variability and possible awakenings during the night. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * light_sleep_score: Score that evaluates the amount of light sleep. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * overall_sleep_score: Total score that summarizes the overall quality of sleep, combining sleep duration and quality. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * sleep_quality_score: Score that evaluates the quality of sleep based on sleep stages, heart-rate variability and possible awakenings during the night. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * sleep_recovery_score: Score that evaluates stress and recovery during sleep. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * rem_sleep_score: Score that evaluates the amount of REM sleep. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * sleep_restlessness_score: Score that evaluates the amount of restlessness during sleep. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * awakenings_count: The number of awakenings during sleep."]
#[doc = " * interruptions_score: Score that evaluates the sleep interruptions. If valid: 0 (worst) to 100 (best). If unknown: FIT_UINT8_INVALID."]
#[doc = " * average_stress_during_sleep: Excludes stress during awake periods in the sleep window"]
fn sleep_assessment_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(sleep_assessment_message_combined_awake_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(sleep_assessment_message_awake_time_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(sleep_assessment_message_awakenings_count_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(sleep_assessment_message_deep_sleep_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(sleep_assessment_message_sleep_duration_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(sleep_assessment_message_light_sleep_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(sleep_assessment_message_overall_sleep_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(sleep_assessment_message_sleep_quality_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(sleep_assessment_message_sleep_recovery_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(sleep_assessment_message_rem_sleep_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(sleep_assessment_message_sleep_restlessness_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(sleep_assessment_message_awakenings_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(sleep_assessment_message_interruptions_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                fields.push(sleep_assessment_message_average_stress_during_sleep_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn sleep_assessment_message_combined_awake_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "combined_awake_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_awake_time_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "awake_time_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_awakenings_count_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "awakenings_count_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_deep_sleep_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        None,
        "deep_sleep_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_sleep_duration_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "sleep_duration_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_light_sleep_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        None,
        "light_sleep_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_overall_sleep_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        None,
        "overall_sleep_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_sleep_quality_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        None,
        "sleep_quality_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_sleep_recovery_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        None,
        "sleep_recovery_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_rem_sleep_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        None,
        "rem_sleep_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_sleep_restlessness_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        None,
        "sleep_restlessness_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_awakenings_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        None,
        "awakenings_count",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_interruptions_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        None,
        "interruptions_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_average_stress_during_sleep_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        None,
        "average_stress_during_sleep",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "skin_temp_overnight message definition"]
#[doc = " * average_deviation: The average overnight deviation from baseline temperature in degrees C"]
#[doc = " * average_7_day_deviation: The average 7 day overnight deviation from baseline temperature in degrees C"]
#[doc = " * nightly_value: Final overnight temperature value"]
fn skin_temp_overnight_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((field_nr, value)) = entries.pop_front() {
        match field_nr {
            0u8 => {
                fields.push(skin_temp_overnight_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(skin_temp_overnight_message_average_deviation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(skin_temp_overnight_message_average_7_day_deviation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(skin_temp_overnight_message_nightly_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(skin_temp_overnight_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(field_nr, value));
                }
            }
        }
    }
    Ok(fields)
}
fn skin_temp_overnight_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        None,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn skin_temp_overnight_message_average_deviation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        None,
        "average_deviation",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn skin_temp_overnight_message_average_7_day_deviation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        None,
        "average_7_day_deviation",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn skin_temp_overnight_message_nightly_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        None,
        "nightly_value",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn skin_temp_overnight_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        None,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn unknown_message(
    data_map: &HashMap<u8, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    if options.contains(&DecodeOption::DropUnknownFields) {
        return Ok(Vec::new());
    }
    let fields = data_map
        .iter()
        .map(|(field_def_num, v)| unknown_field(*field_def_num, v.clone()))
        .collect();
    Ok(fields)
}
impl MesgNum {
    #[doc = r" Decode the raw values from a FitDataMessage based on the Global Message Number"]
    pub fn decode_message(
        self,
        data_map: &mut HashMap<u8, Value>,
        accumlators: &mut HashMap<u32, Value>,
        options: &HashSet<DecodeOption>,
    ) -> Result<Vec<FitDataField>> {
        match self {
            MesgNum::FileId => file_id_message(self, data_map, accumlators, options),
            MesgNum::FileCreator => file_creator_message(self, data_map, accumlators, options),
            MesgNum::TimestampCorrelation => {
                timestamp_correlation_message(self, data_map, accumlators, options)
            }
            MesgNum::Software => software_message(self, data_map, accumlators, options),
            MesgNum::SlaveDevice => slave_device_message(self, data_map, accumlators, options),
            MesgNum::Capabilities => capabilities_message(self, data_map, accumlators, options),
            MesgNum::FileCapabilities => {
                file_capabilities_message(self, data_map, accumlators, options)
            }
            MesgNum::MesgCapabilities => {
                mesg_capabilities_message(self, data_map, accumlators, options)
            }
            MesgNum::FieldCapabilities => {
                field_capabilities_message(self, data_map, accumlators, options)
            }
            MesgNum::DeviceSettings => {
                device_settings_message(self, data_map, accumlators, options)
            }
            MesgNum::UserProfile => user_profile_message(self, data_map, accumlators, options),
            MesgNum::HrmProfile => hrm_profile_message(self, data_map, accumlators, options),
            MesgNum::SdmProfile => sdm_profile_message(self, data_map, accumlators, options),
            MesgNum::BikeProfile => bike_profile_message(self, data_map, accumlators, options),
            MesgNum::Connectivity => connectivity_message(self, data_map, accumlators, options),
            MesgNum::WatchfaceSettings => {
                watchface_settings_message(self, data_map, accumlators, options)
            }
            MesgNum::OhrSettings => ohr_settings_message(self, data_map, accumlators, options),
            MesgNum::TimeInZone => time_in_zone_message(self, data_map, accumlators, options),
            MesgNum::ZonesTarget => zones_target_message(self, data_map, accumlators, options),
            MesgNum::Sport => sport_message(self, data_map, accumlators, options),
            MesgNum::HrZone => hr_zone_message(self, data_map, accumlators, options),
            MesgNum::SpeedZone => speed_zone_message(self, data_map, accumlators, options),
            MesgNum::CadenceZone => cadence_zone_message(self, data_map, accumlators, options),
            MesgNum::PowerZone => power_zone_message(self, data_map, accumlators, options),
            MesgNum::MetZone => met_zone_message(self, data_map, accumlators, options),
            MesgNum::DiveSettings => dive_settings_message(self, data_map, accumlators, options),
            MesgNum::DiveAlarm => dive_alarm_message(self, data_map, accumlators, options),
            MesgNum::DiveApneaAlarm => {
                dive_apnea_alarm_message(self, data_map, accumlators, options)
            }
            MesgNum::DiveGas => dive_gas_message(self, data_map, accumlators, options),
            MesgNum::Goal => goal_message(self, data_map, accumlators, options),
            MesgNum::Activity => activity_message(self, data_map, accumlators, options),
            MesgNum::Session => session_message(self, data_map, accumlators, options),
            MesgNum::Lap => lap_message(self, data_map, accumlators, options),
            MesgNum::Length => length_message(self, data_map, accumlators, options),
            MesgNum::Record => record_message(self, data_map, accumlators, options),
            MesgNum::Event => event_message(self, data_map, accumlators, options),
            MesgNum::DeviceInfo => device_info_message(self, data_map, accumlators, options),
            MesgNum::DeviceAuxBatteryInfo => {
                device_aux_battery_info_message(self, data_map, accumlators, options)
            }
            MesgNum::TrainingFile => training_file_message(self, data_map, accumlators, options),
            MesgNum::WeatherConditions => {
                weather_conditions_message(self, data_map, accumlators, options)
            }
            MesgNum::WeatherAlert => weather_alert_message(self, data_map, accumlators, options),
            MesgNum::GpsMetadata => gps_metadata_message(self, data_map, accumlators, options),
            MesgNum::CameraEvent => camera_event_message(self, data_map, accumlators, options),
            MesgNum::GyroscopeData => gyroscope_data_message(self, data_map, accumlators, options),
            MesgNum::AccelerometerData => {
                accelerometer_data_message(self, data_map, accumlators, options)
            }
            MesgNum::MagnetometerData => {
                magnetometer_data_message(self, data_map, accumlators, options)
            }
            MesgNum::BarometerData => barometer_data_message(self, data_map, accumlators, options),
            MesgNum::ThreeDSensorCalibration => {
                three_d_sensor_calibration_message(self, data_map, accumlators, options)
            }
            MesgNum::OneDSensorCalibration => {
                one_d_sensor_calibration_message(self, data_map, accumlators, options)
            }
            MesgNum::VideoFrame => video_frame_message(self, data_map, accumlators, options),
            MesgNum::ObdiiData => obdii_data_message(self, data_map, accumlators, options),
            MesgNum::NmeaSentence => nmea_sentence_message(self, data_map, accumlators, options),
            MesgNum::AviationAttitude => {
                aviation_attitude_message(self, data_map, accumlators, options)
            }
            MesgNum::Video => video_message(self, data_map, accumlators, options),
            MesgNum::VideoTitle => video_title_message(self, data_map, accumlators, options),
            MesgNum::VideoDescription => {
                video_description_message(self, data_map, accumlators, options)
            }
            MesgNum::VideoClip => video_clip_message(self, data_map, accumlators, options),
            MesgNum::Set => set_message(self, data_map, accumlators, options),
            MesgNum::Jump => jump_message(self, data_map, accumlators, options),
            MesgNum::Split => split_message(self, data_map, accumlators, options),
            MesgNum::SplitSummary => split_summary_message(self, data_map, accumlators, options),
            MesgNum::ClimbPro => climb_pro_message(self, data_map, accumlators, options),
            MesgNum::FieldDescription => {
                field_description_message(self, data_map, accumlators, options)
            }
            MesgNum::DeveloperDataId => {
                developer_data_id_message(self, data_map, accumlators, options)
            }
            MesgNum::Course => course_message(self, data_map, accumlators, options),
            MesgNum::CoursePoint => course_point_message(self, data_map, accumlators, options),
            MesgNum::SegmentId => segment_id_message(self, data_map, accumlators, options),
            MesgNum::SegmentLeaderboardEntry => {
                segment_leaderboard_entry_message(self, data_map, accumlators, options)
            }
            MesgNum::SegmentPoint => segment_point_message(self, data_map, accumlators, options),
            MesgNum::SegmentLap => segment_lap_message(self, data_map, accumlators, options),
            MesgNum::SegmentFile => segment_file_message(self, data_map, accumlators, options),
            MesgNum::Workout => workout_message(self, data_map, accumlators, options),
            MesgNum::WorkoutSession => {
                workout_session_message(self, data_map, accumlators, options)
            }
            MesgNum::WorkoutStep => workout_step_message(self, data_map, accumlators, options),
            MesgNum::ExerciseTitle => exercise_title_message(self, data_map, accumlators, options),
            MesgNum::Schedule => schedule_message(self, data_map, accumlators, options),
            MesgNum::Totals => totals_message(self, data_map, accumlators, options),
            MesgNum::WeightScale => weight_scale_message(self, data_map, accumlators, options),
            MesgNum::BloodPressure => blood_pressure_message(self, data_map, accumlators, options),
            MesgNum::MonitoringInfo => {
                monitoring_info_message(self, data_map, accumlators, options)
            }
            MesgNum::Monitoring => monitoring_message(self, data_map, accumlators, options),
            MesgNum::MonitoringHrData => {
                monitoring_hr_data_message(self, data_map, accumlators, options)
            }
            MesgNum::Spo2Data => spo2_data_message(self, data_map, accumlators, options),
            MesgNum::Hr => hr_message(self, data_map, accumlators, options),
            MesgNum::StressLevel => stress_level_message(self, data_map, accumlators, options),
            MesgNum::MaxMetData => max_met_data_message(self, data_map, accumlators, options),
            MesgNum::HsaBodyBatteryData => {
                hsa_body_battery_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaEvent => hsa_event_message(self, data_map, accumlators, options),
            MesgNum::HsaAccelerometerData => {
                hsa_accelerometer_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaGyroscopeData => {
                hsa_gyroscope_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaStepData => hsa_step_data_message(self, data_map, accumlators, options),
            MesgNum::HsaSpo2Data => hsa_spo2_data_message(self, data_map, accumlators, options),
            MesgNum::HsaStressData => hsa_stress_data_message(self, data_map, accumlators, options),
            MesgNum::HsaRespirationData => {
                hsa_respiration_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaHeartRateData => {
                hsa_heart_rate_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaConfigurationData => {
                hsa_configuration_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaWristTemperatureData => {
                hsa_wrist_temperature_data_message(self, data_map, accumlators, options)
            }
            MesgNum::MemoGlob => memo_glob_message(self, data_map, accumlators, options),
            MesgNum::SleepLevel => sleep_level_message(self, data_map, accumlators, options),
            MesgNum::AntChannelId => ant_channel_id_message(self, data_map, accumlators, options),
            MesgNum::AntRx => ant_rx_message(self, data_map, accumlators, options),
            MesgNum::AntTx => ant_tx_message(self, data_map, accumlators, options),
            MesgNum::ExdScreenConfiguration => {
                exd_screen_configuration_message(self, data_map, accumlators, options)
            }
            MesgNum::ExdDataFieldConfiguration => {
                exd_data_field_configuration_message(self, data_map, accumlators, options)
            }
            MesgNum::ExdDataConceptConfiguration => {
                exd_data_concept_configuration_message(self, data_map, accumlators, options)
            }
            MesgNum::DiveSummary => dive_summary_message(self, data_map, accumlators, options),
            MesgNum::AadAccelFeatures => {
                aad_accel_features_message(self, data_map, accumlators, options)
            }
            MesgNum::Hrv => hrv_message(self, data_map, accumlators, options),
            MesgNum::BeatIntervals => beat_intervals_message(self, data_map, accumlators, options),
            MesgNum::HrvStatusSummary => {
                hrv_status_summary_message(self, data_map, accumlators, options)
            }
            MesgNum::HrvValue => hrv_value_message(self, data_map, accumlators, options),
            MesgNum::RawBbi => raw_bbi_message(self, data_map, accumlators, options),
            MesgNum::RespirationRate => {
                respiration_rate_message(self, data_map, accumlators, options)
            }
            MesgNum::ChronoShotSession => {
                chrono_shot_session_message(self, data_map, accumlators, options)
            }
            MesgNum::ChronoShotData => {
                chrono_shot_data_message(self, data_map, accumlators, options)
            }
            MesgNum::TankUpdate => tank_update_message(self, data_map, accumlators, options),
            MesgNum::TankSummary => tank_summary_message(self, data_map, accumlators, options),
            MesgNum::SleepAssessment => {
                sleep_assessment_message(self, data_map, accumlators, options)
            }
            MesgNum::SkinTempOvernight => {
                skin_temp_overnight_message(self, data_map, accumlators, options)
            }
            _ => unknown_message(data_map, options),
        }
    }
}
