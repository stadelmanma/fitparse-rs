//! Auto generated profile messages from FIT SDK Release: 21.89.00
#![allow(unused_variables)]
use super::field_types::*;
use super::{calculate_cumulative_value, data_field_with_info, extract_component, unknown_field};
use crate::de::DecodeOption;
use crate::error::Result;
use crate::{FitDataField, Value};
use std::collections::{HashMap, HashSet, VecDeque};
use std::convert::TryInto;
/// FIT SDK version used to generate profile decoder
pub const VERSION: &str = "21.89.00";
/// Must be first message in file.
fn file_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(file_id_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(file_id_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(file_id_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            3 => {
                fields.push(file_id_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Only set for files that are can be created/erased.
                fields.push(file_id_message_time_created_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                // Only set for files that are not created/erased.
                fields.push(file_id_message_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                // Optional free form string to indicate the devices name or model
                fields.push(file_id_message_product_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn file_id_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "type",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        2,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        2,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_time_created_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "time_created",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "number",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_product_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "product_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_creator_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(file_creator_message_software_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(file_creator_message_hardware_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn file_creator_message_software_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "software_version",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_creator_message_hardware_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "hardware_version",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Fractional part of the UTC timestamp at the time the system timestamp was recorded.
                fields.push(timestamp_correlation_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            1 => {
                // Whole second part of the system timestamp
                fields.push(timestamp_correlation_message_system_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            2 => {
                // Fractional part of the system timestamp
                fields.push(
                    timestamp_correlation_message_fractional_system_timestamp_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        32768.000000,
                        0.000000,
                        "s",
                        value,
                    )?,
                );
            }
            3 => {
                // timestamp epoch expressed in local time used to convert timestamps to local time
                fields.push(timestamp_correlation_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            4 => {
                // Millisecond part of the UTC timestamp at the time the system timestamp was recorded.
                fields.push(timestamp_correlation_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            5 => {
                // Millisecond part of the system timestamp
                fields.push(timestamp_correlation_message_system_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            253 => {
                // Whole second part of UTC timestamp at the time the system timestamp was recorded.
                fields.push(timestamp_correlation_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn timestamp_correlation_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_system_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "system_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_fractional_system_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "fractional_system_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_system_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "system_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn software_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            3 => {
                fields.push(software_message_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(software_message_part_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(software_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn software_message_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "version",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn software_message_part_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "part_number",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn software_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn slave_device_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(slave_device_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(slave_device_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn slave_device_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn slave_device_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn slave_device_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        1,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn slave_device_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        1,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Use language_bits_x types where x is index of array.
                fields.push(capabilities_message_languages_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // Use sport_bits_x types where x is index of array.
                fields.push(capabilities_message_sports_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            21 => {
                fields.push(capabilities_message_workouts_supported_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            23 => {
                fields.push(capabilities_message_connectivity_supported_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn capabilities_message_languages_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "languages",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn capabilities_message_sports_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "sports",
        FieldDataType::SportBits0,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn capabilities_message_workouts_supported_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    data_field_with_info(
        21,
        "workouts_supported",
        FieldDataType::WorkoutCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn capabilities_message_connectivity_supported_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23, value)?
    } else {
        value
    };
    data_field_with_info(
        23,
        "connectivity_supported",
        FieldDataType::ConnectivityCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(file_capabilities_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(file_capabilities_message_flags_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(file_capabilities_message_directory_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(file_capabilities_message_max_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(file_capabilities_message_max_size_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bytes",
                    value,
                )?);
            }
            254 => {
                fields.push(file_capabilities_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn file_capabilities_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "type",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_flags_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "flags",
        FieldDataType::FileFlags,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_directory_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "directory",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_max_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "max_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_max_size_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "max_size",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(mesg_capabilities_message_file_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(mesg_capabilities_message_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(mesg_capabilities_message_count_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                if MesgCount::NumPerFile.as_i64()
                    == data_map
                        .get(&2)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(mesg_capabilities_message_num_per_file_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if MesgCount::MaxPerFile.as_i64()
                    == data_map
                        .get(&2)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(mesg_capabilities_message_max_per_file_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if MesgCount::MaxPerFileType.as_i64()
                    == data_map
                        .get(&2)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(mesg_capabilities_message_max_per_file_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(mesg_capabilities_message_count_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            254 => {
                fields.push(mesg_capabilities_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn mesg_capabilities_message_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "file",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_count_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "count_type",
        FieldDataType::MesgCount,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_num_per_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "count"
    } else {
        "num_per_file"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_max_per_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "count"
    } else {
        "max_per_file"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_max_per_file_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "count"
    } else {
        "max_per_file_type"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(field_capabilities_message_file_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(field_capabilities_message_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(field_capabilities_message_field_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(field_capabilities_message_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(field_capabilities_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn field_capabilities_message_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "file",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_field_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "field_num",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Index into time zone arrays.
                fields.push(device_settings_message_active_time_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // Offset from system time. Required to convert timestamp from system time to UTC.
                fields.push(device_settings_message_utc_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                // Offset from system time.
                fields.push(device_settings_message_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            4 => {
                // Display mode for the time
                fields.push(device_settings_message_time_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                // timezone offset in 1/4 hour increments
                fields.push(device_settings_message_time_zone_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    4.000000,
                    0.000000,
                    "hr",
                    value,
                )?);
            }
            12 => {
                // Mode for backlight
                fields.push(device_settings_message_backlight_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            36 => {
                // Enabled state of the activity tracker functionality
                fields.push(device_settings_message_activity_tracker_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            39 => {
                // UTC timestamp used to set the devices clock and date
                fields.push(device_settings_message_clock_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            40 => {
                // Bitfield to configure enabled screens for each supported loop
                fields.push(device_settings_message_pages_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            46 => {
                // Enabled state of the move alert
                fields.push(device_settings_message_move_alert_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            47 => {
                // Display mode for the date
                fields.push(device_settings_message_date_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            55 => {
                fields.push(device_settings_message_display_orientation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            56 => {
                fields.push(device_settings_message_mounting_side_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            57 => {
                // Bitfield to indicate one page as default for each supported loop
                fields.push(device_settings_message_default_page_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            58 => {
                // Minimum steps before an autosync can occur
                fields.push(device_settings_message_autosync_min_steps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "steps",
                    value,
                )?);
            }
            59 => {
                // Minimum minutes before an autosync can occur
                fields.push(device_settings_message_autosync_min_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "minutes",
                    value,
                )?);
            }
            80 => {
                // Enable auto-detect setting for the lactate threshold feature.
                fields.push(
                    device_settings_message_lactate_threshold_autodetect_enabled_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?,
                );
            }
            86 => {
                // Automatically upload using BLE
                fields.push(device_settings_message_ble_auto_upload_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            89 => {
                // Helps to conserve battery by changing modes
                fields.push(device_settings_message_auto_sync_frequency_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            90 => {
                // Allows setting specific activities auto-activity detect enabled/disabled settings
                fields.push(device_settings_message_auto_activity_detect_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            94 => {
                // Number of screens configured to display
                fields.push(device_settings_message_number_of_screens_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            95 => {
                // Smart Notification display orientation
                fields.push(
                    device_settings_message_smart_notification_display_orientation_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?,
                );
            }
            134 => {
                fields.push(device_settings_message_tap_interface_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            174 => {
                // Used to hold the tap threshold setting
                fields.push(device_settings_message_tap_sensitivity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn device_settings_message_active_time_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "active_time_zone",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_utc_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "utc_offset",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "time_offset",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_time_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "time_mode",
        FieldDataType::TimeMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_time_zone_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "time_zone_offset",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_backlight_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "backlight_mode",
        FieldDataType::BacklightMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_activity_tracker_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 36, value)?
    } else {
        value
    };
    data_field_with_info(
        36,
        "activity_tracker_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_clock_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39, value)?
    } else {
        value
    };
    data_field_with_info(
        39,
        "clock_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_pages_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40, value)?
    } else {
        value
    };
    data_field_with_info(
        40,
        "pages_enabled",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_move_alert_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46, value)?
    } else {
        value
    };
    data_field_with_info(
        46,
        "move_alert_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_date_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47, value)?
    } else {
        value
    };
    data_field_with_info(
        47,
        "date_mode",
        FieldDataType::DateMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_display_orientation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55, value)?
    } else {
        value
    };
    data_field_with_info(
        55,
        "display_orientation",
        FieldDataType::DisplayOrientation,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_mounting_side_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56, value)?
    } else {
        value
    };
    data_field_with_info(
        56,
        "mounting_side",
        FieldDataType::Side,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_default_page_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57, value)?
    } else {
        value
    };
    data_field_with_info(
        57,
        "default_page",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_autosync_min_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58, value)?
    } else {
        value
    };
    data_field_with_info(
        58,
        "autosync_min_steps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_autosync_min_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59, value)?
    } else {
        value
    };
    data_field_with_info(
        59,
        "autosync_min_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_lactate_threshold_autodetect_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 80, value)?
    } else {
        value
    };
    data_field_with_info(
        80,
        "lactate_threshold_autodetect_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_ble_auto_upload_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86, value)?
    } else {
        value
    };
    data_field_with_info(
        86,
        "ble_auto_upload_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_auto_sync_frequency_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89, value)?
    } else {
        value
    };
    data_field_with_info(
        89,
        "auto_sync_frequency",
        FieldDataType::AutoSyncFrequency,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_auto_activity_detect_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 90, value)?
    } else {
        value
    };
    data_field_with_info(
        90,
        "auto_activity_detect",
        FieldDataType::AutoActivityDetect,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_number_of_screens_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94, value)?
    } else {
        value
    };
    data_field_with_info(
        94,
        "number_of_screens",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_smart_notification_display_orientation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95, value)?
    } else {
        value
    };
    data_field_with_info(
        95,
        "smart_notification_display_orientation",
        FieldDataType::DisplayOrientation,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_tap_interface_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 134, value)?
    } else {
        value
    };
    data_field_with_info(
        134,
        "tap_interface",
        FieldDataType::Switch,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_tap_sensitivity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 174, value)?
    } else {
        value
    };
    data_field_with_info(
        174,
        "tap_sensitivity",
        FieldDataType::TapSensitivity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(user_profile_message_friendly_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(user_profile_message_gender_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(user_profile_message_age_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "years",
                    value,
                )?);
            }
            3 => {
                fields.push(user_profile_message_height_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            4 => {
                fields.push(user_profile_message_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "kg",
                    value,
                )?);
            }
            5 => {
                fields.push(user_profile_message_language_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(user_profile_message_elev_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                fields.push(user_profile_message_weight_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                fields.push(user_profile_message_resting_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            9 => {
                fields.push(user_profile_message_default_max_running_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            10 => {
                fields.push(user_profile_message_default_max_biking_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            11 => {
                fields.push(user_profile_message_default_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            12 => {
                fields.push(user_profile_message_hr_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            13 => {
                fields.push(user_profile_message_speed_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            14 => {
                fields.push(user_profile_message_dist_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            16 => {
                fields.push(user_profile_message_power_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            17 => {
                fields.push(user_profile_message_activity_class_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            18 => {
                fields.push(user_profile_message_position_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            21 => {
                fields.push(user_profile_message_temperature_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            22 => {
                fields.push(user_profile_message_local_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            23 => {
                fields.push(user_profile_message_global_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            28 => {
                // Typical wake time
                fields.push(user_profile_message_wake_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            29 => {
                // Typical bed time
                fields.push(user_profile_message_sleep_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            30 => {
                fields.push(user_profile_message_height_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            31 => {
                // User defined running step length set to 0 for auto length
                fields.push(user_profile_message_user_running_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            32 => {
                // User defined walking step length set to 0 for auto length
                fields.push(user_profile_message_user_walking_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            47 => {
                fields.push(user_profile_message_depth_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            49 => {
                fields.push(user_profile_message_dive_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(user_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn user_profile_message_friendly_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "friendly_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_gender_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "gender",
        FieldDataType::Gender,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_age_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "age",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_height_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "height",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_language_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "language",
        FieldDataType::Language,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_elev_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "elev_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_weight_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "weight_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_resting_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "resting_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_default_max_running_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "default_max_running_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_default_max_biking_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "default_max_biking_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_default_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "default_max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_hr_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "hr_setting",
        FieldDataType::DisplayHeart,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_speed_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13, value)?
    } else {
        value
    };
    data_field_with_info(
        13,
        "speed_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_dist_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14, value)?
    } else {
        value
    };
    data_field_with_info(
        14,
        "dist_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_power_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16, value)?
    } else {
        value
    };
    data_field_with_info(
        16,
        "power_setting",
        FieldDataType::DisplayPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_activity_class_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17, value)?
    } else {
        value
    };
    data_field_with_info(
        17,
        "activity_class",
        FieldDataType::ActivityClass,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_position_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18, value)?
    } else {
        value
    };
    data_field_with_info(
        18,
        "position_setting",
        FieldDataType::DisplayPosition,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_temperature_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    data_field_with_info(
        21,
        "temperature_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_local_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    data_field_with_info(
        22,
        "local_id",
        FieldDataType::UserLocalId,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_global_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23, value)?
    } else {
        value
    };
    data_field_with_info(
        23,
        "global_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_wake_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28, value)?
    } else {
        value
    };
    data_field_with_info(
        28,
        "wake_time",
        FieldDataType::LocaltimeIntoDay,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_sleep_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29, value)?
    } else {
        value
    };
    data_field_with_info(
        29,
        "sleep_time",
        FieldDataType::LocaltimeIntoDay,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_height_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30, value)?
    } else {
        value
    };
    data_field_with_info(
        30,
        "height_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_user_running_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31, value)?
    } else {
        value
    };
    data_field_with_info(
        31,
        "user_running_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_user_walking_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32, value)?
    } else {
        value
    };
    data_field_with_info(
        32,
        "user_walking_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_depth_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47, value)?
    } else {
        value
    };
    data_field_with_info(
        47,
        "depth_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_dive_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49, value)?
    } else {
        value
    };
    data_field_with_info(
        49,
        "dive_count",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(hrm_profile_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(hrm_profile_message_hrm_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(hrm_profile_message_log_hrv_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(hrm_profile_message_hrm_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(hrm_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hrm_profile_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_hrm_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "hrm_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_log_hrv_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "log_hrv",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_hrm_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "hrm_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(sdm_profile_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(sdm_profile_message_sdm_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(sdm_profile_message_sdm_cal_factor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            3 => {
                fields.push(sdm_profile_message_odometer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            4 => {
                // Use footpod for speed source instead of GPS
                fields.push(sdm_profile_message_speed_source_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(sdm_profile_message_sdm_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                // Rollover counter that can be used to extend the odometer
                fields.push(sdm_profile_message_odometer_rollover_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(sdm_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn sdm_profile_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_sdm_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "sdm_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_sdm_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "sdm_cal_factor",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_odometer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "odometer",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_speed_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "speed_source",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_sdm_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "sdm_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_odometer_rollover_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "odometer_rollover",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(bike_profile_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(bike_profile_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(bike_profile_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(bike_profile_message_odometer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            4 => {
                fields.push(bike_profile_message_bike_spd_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(bike_profile_message_bike_cad_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(bike_profile_message_bike_spdcad_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                fields.push(bike_profile_message_bike_power_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                fields.push(bike_profile_message_custom_wheelsize_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            9 => {
                fields.push(bike_profile_message_auto_wheelsize_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            10 => {
                fields.push(bike_profile_message_bike_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "kg",
                    value,
                )?);
            }
            11 => {
                fields.push(bike_profile_message_power_cal_factor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            12 => {
                fields.push(bike_profile_message_auto_wheel_cal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            13 => {
                fields.push(bike_profile_message_auto_power_zero_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            14 => {
                fields.push(bike_profile_message_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            15 => {
                fields.push(bike_profile_message_spd_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            16 => {
                fields.push(bike_profile_message_cad_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            17 => {
                fields.push(bike_profile_message_spdcad_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            18 => {
                fields.push(bike_profile_message_power_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            19 => {
                fields.push(bike_profile_message_crank_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            20 => {
                fields.push(bike_profile_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            21 => {
                fields.push(bike_profile_message_bike_spd_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            22 => {
                fields.push(bike_profile_message_bike_cad_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            23 => {
                fields.push(bike_profile_message_bike_spdcad_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            24 => {
                fields.push(bike_profile_message_bike_power_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            37 => {
                // Rollover counter that can be used to extend the odometer
                fields.push(bike_profile_message_odometer_rollover_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            38 => {
                // Number of front gears
                fields.push(bike_profile_message_front_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            39 => {
                // Number of teeth on each gear 0 is innermost
                fields.push(bike_profile_message_front_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            40 => {
                // Number of rear gears
                fields.push(bike_profile_message_rear_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            41 => {
                // Number of teeth on each gear 0 is innermost
                fields.push(bike_profile_message_rear_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            44 => {
                fields.push(bike_profile_message_shimano_di2_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(bike_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn bike_profile_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_odometer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "odometer",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spd_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "bike_spd_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_cad_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "bike_cad_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spdcad_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "bike_spdcad_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_power_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "bike_power_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_custom_wheelsize_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "custom_wheelsize",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_auto_wheelsize_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "auto_wheelsize",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "bike_weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_power_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "power_cal_factor",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_auto_wheel_cal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "auto_wheel_cal",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_auto_power_zero_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13, value)?
    } else {
        value
    };
    data_field_with_info(
        13,
        "auto_power_zero",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14, value)?
    } else {
        value
    };
    data_field_with_info(
        14,
        "id",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_spd_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15, value)?
    } else {
        value
    };
    data_field_with_info(
        15,
        "spd_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_cad_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16, value)?
    } else {
        value
    };
    data_field_with_info(
        16,
        "cad_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_spdcad_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17, value)?
    } else {
        value
    };
    data_field_with_info(
        17,
        "spdcad_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_power_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18, value)?
    } else {
        value
    };
    data_field_with_info(
        18,
        "power_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_crank_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19, value)?
    } else {
        value
    };
    data_field_with_info(
        19,
        "crank_length",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    data_field_with_info(
        20,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spd_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    data_field_with_info(
        21,
        "bike_spd_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_cad_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    data_field_with_info(
        22,
        "bike_cad_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spdcad_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23, value)?
    } else {
        value
    };
    data_field_with_info(
        23,
        "bike_spdcad_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_power_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24, value)?
    } else {
        value
    };
    data_field_with_info(
        24,
        "bike_power_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_odometer_rollover_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37, value)?
    } else {
        value
    };
    data_field_with_info(
        37,
        "odometer_rollover",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_front_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 38, value)?
    } else {
        value
    };
    data_field_with_info(
        38,
        "front_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_front_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39, value)?
    } else {
        value
    };
    data_field_with_info(
        39,
        "front_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_rear_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40, value)?
    } else {
        value
    };
    data_field_with_info(
        40,
        "rear_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_rear_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41, value)?
    } else {
        value
    };
    data_field_with_info(
        41,
        "rear_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_shimano_di2_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44, value)?
    } else {
        value
    };
    data_field_with_info(
        44,
        "shimano_di2_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Use Bluetooth for connectivity features
                fields.push(connectivity_message_bluetooth_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // Use Bluetooth Low Energy for connectivity features
                fields.push(connectivity_message_bluetooth_le_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                // Use ANT for connectivity features
                fields.push(connectivity_message_ant_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(connectivity_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(connectivity_message_live_tracking_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(connectivity_message_weather_conditions_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(connectivity_message_weather_alerts_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                fields.push(connectivity_message_auto_activity_upload_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                fields.push(connectivity_message_course_download_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            9 => {
                fields.push(connectivity_message_workout_download_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            10 => {
                fields.push(connectivity_message_gps_ephemeris_download_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                fields.push(connectivity_message_incident_detection_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            12 => {
                fields.push(connectivity_message_grouptrack_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn connectivity_message_bluetooth_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "bluetooth_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_bluetooth_le_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "bluetooth_le_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_ant_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "ant_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_live_tracking_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "live_tracking_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_weather_conditions_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "weather_conditions_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_weather_alerts_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "weather_alerts_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_auto_activity_upload_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "auto_activity_upload_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_course_download_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "course_download_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_workout_download_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "workout_download_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_gps_ephemeris_download_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "gps_ephemeris_download_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_incident_detection_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "incident_detection_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_grouptrack_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "grouptrack_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(watchface_settings_message_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                if WatchfaceMode::Digital.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(watchface_settings_message_digital_layout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WatchfaceMode::Analog.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(watchface_settings_message_analog_layout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(watchface_settings_message_layout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            254 => {
                fields.push(watchface_settings_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn watchface_settings_message_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "mode",
        FieldDataType::WatchfaceMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "layout",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_digital_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "layout"
    } else {
        "digital_layout"
    };
    data_field_with_info(
        1,
        name,
        FieldDataType::DigitalWatchfaceLayout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_analog_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "layout"
    } else {
        "analog_layout"
    };
    data_field_with_info(
        1,
        name,
        FieldDataType::AnalogWatchfaceLayout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ohr_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(ohr_settings_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                fields.push(ohr_settings_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ohr_settings_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "enabled",
        FieldDataType::Switch,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ohr_settings_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1 => {
                fields.push(zones_target_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(zones_target_message_threshold_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(zones_target_message_functional_threshold_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(zones_target_message_hr_calc_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                fields.push(zones_target_message_pwr_calc_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn zones_target_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_threshold_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "threshold_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_functional_threshold_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "functional_threshold_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_hr_calc_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "hr_calc_type",
        FieldDataType::HrZoneCalc,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_pwr_calc_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "pwr_calc_type",
        FieldDataType::PwrZoneCalc,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sport_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(sport_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(sport_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(sport_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn sport_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sport_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sport_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1 => {
                fields.push(hr_zone_message_high_bpm_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            2 => {
                fields.push(hr_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(hr_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hr_zone_message_high_bpm_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "high_bpm",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn speed_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(speed_zone_message_high_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            1 => {
                fields.push(speed_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(speed_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn speed_zone_message_high_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "high_value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn speed_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn speed_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn cadence_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(cadence_zone_message_high_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            1 => {
                fields.push(cadence_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(cadence_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn cadence_zone_message_high_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "high_value",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn cadence_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn cadence_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn power_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1 => {
                fields.push(power_zone_message_high_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            2 => {
                fields.push(power_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(power_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn power_zone_message_high_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "high_value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn power_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn power_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn met_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1 => {
                fields.push(met_zone_message_high_bpm_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(met_zone_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "kcal / min",
                    value,
                )?);
            }
            3 => {
                fields.push(met_zone_message_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "kcal / min",
                    value,
                )?);
            }
            254 => {
                fields.push(met_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn met_zone_message_high_bpm_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "high_bpm",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn met_zone_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn met_zone_message_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "fat_calories",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn met_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(dive_settings_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(dive_settings_message_model_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(dive_settings_message_gf_low_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            3 => {
                fields.push(dive_settings_message_gf_high_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            4 => {
                fields.push(dive_settings_message_water_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                // Fresh water is usually 1000; salt water is usually 1025
                fields.push(dive_settings_message_water_density_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kg/m^3",
                    value,
                )?);
            }
            6 => {
                // Typically 1.40
                fields.push(dive_settings_message_po2_warn_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            7 => {
                // Typically 1.60
                fields.push(dive_settings_message_po2_critical_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            8 => {
                fields.push(dive_settings_message_po2_deco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            9 => {
                fields.push(dive_settings_message_safety_stop_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            10 => {
                fields.push(dive_settings_message_bottom_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                fields.push(dive_settings_message_bottom_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            12 => {
                fields.push(dive_settings_message_apnea_countdown_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            13 => {
                fields.push(dive_settings_message_apnea_countdown_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            14 => {
                fields.push(dive_settings_message_backlight_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            15 => {
                fields.push(dive_settings_message_backlight_brightness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            16 => {
                fields.push(dive_settings_message_backlight_timeout_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            17 => {
                // Time between surfacing and ending the activity
                fields.push(dive_settings_message_repeat_dive_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            18 => {
                // Time at safety stop (if enabled)
                fields.push(dive_settings_message_safety_stop_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            19 => {
                fields.push(dive_settings_message_heart_rate_source_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            20 => {
                if SourceType::Antplus.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(dive_settings_message_heart_rate_antplus_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if SourceType::Local.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(dive_settings_message_heart_rate_local_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(dive_settings_message_heart_rate_source_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            254 => {
                fields.push(dive_settings_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_settings_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_model_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "model",
        FieldDataType::TissueModelType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_gf_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "gf_low",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_gf_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "gf_high",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_water_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "water_type",
        FieldDataType::WaterType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_water_density_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "water_density",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_po2_warn_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "po2_warn",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_po2_critical_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "po2_critical",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_po2_deco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "po2_deco",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_safety_stop_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "safety_stop_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_bottom_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "bottom_depth",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_bottom_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "bottom_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_apnea_countdown_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "apnea_countdown_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_apnea_countdown_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13, value)?
    } else {
        value
    };
    data_field_with_info(
        13,
        "apnea_countdown_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_backlight_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14, value)?
    } else {
        value
    };
    data_field_with_info(
        14,
        "backlight_mode",
        FieldDataType::DiveBacklightMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_backlight_brightness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15, value)?
    } else {
        value
    };
    data_field_with_info(
        15,
        "backlight_brightness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_backlight_timeout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16, value)?
    } else {
        value
    };
    data_field_with_info(
        16,
        "backlight_timeout",
        FieldDataType::BacklightTimeout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_repeat_dive_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17, value)?
    } else {
        value
    };
    data_field_with_info(
        17,
        "repeat_dive_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_safety_stop_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18, value)?
    } else {
        value
    };
    data_field_with_info(
        18,
        "safety_stop_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_source_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19, value)?
    } else {
        value
    };
    data_field_with_info(
        19,
        "heart_rate_source_type",
        FieldDataType::SourceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    data_field_with_info(
        20,
        "heart_rate_source",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_antplus_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "heart_rate_source"
    } else {
        "heart_rate_antplus_device_type"
    };
    data_field_with_info(
        20,
        name,
        FieldDataType::AntplusDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_local_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "heart_rate_source"
    } else {
        "heart_rate_local_device_type"
    };
    data_field_with_info(
        20,
        name,
        FieldDataType::LocalDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Depth setting (m) for depth type alarms
                fields.push(dive_alarm_message_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            1 => {
                // Time setting (s) for time type alarms
                fields.push(dive_alarm_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            2 => {
                // Enablement flag
                fields.push(dive_alarm_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                // Alarm type setting
                fields.push(dive_alarm_message_alarm_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Tone and Vibe setting for the alarm
                fields.push(dive_alarm_message_sound_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                // Dive types the alarm will trigger on
                fields.push(dive_alarm_message_dive_types_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                // Index of the alarm
                fields.push(dive_alarm_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_alarm_message_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "time",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_alarm_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "alarm_type",
        FieldDataType::DiveAlarmType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_sound_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "sound",
        FieldDataType::Tone,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_dive_types_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "dive_types",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(dive_gas_message_helium_content_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            1 => {
                fields.push(dive_gas_message_oxygen_content_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            2 => {
                fields.push(dive_gas_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(dive_gas_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_gas_message_helium_content_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "helium_content",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message_oxygen_content_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "oxygen_content",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "status",
        FieldDataType::DiveGasStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(goal_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(goal_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(goal_message_start_date_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(goal_message_end_date_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(goal_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(goal_message_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(goal_message_repeat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                fields.push(goal_message_target_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                fields.push(goal_message_recurrence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            9 => {
                fields.push(goal_message_recurrence_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            10 => {
                fields.push(goal_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                fields.push(goal_message_source_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(goal_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn goal_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_start_date_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "start_date",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_end_date_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "end_date",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "type",
        FieldDataType::Goal,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_repeat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "repeat",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_target_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "target_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_recurrence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "recurrence",
        FieldDataType::GoalRecurrence,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_recurrence_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "recurrence_value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "source",
        FieldDataType::GoalSource,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Exclude pauses
                fields.push(activity_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            1 => {
                fields.push(activity_message_num_sessions_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(activity_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(activity_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(activity_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                // timestamp epoch expressed in local time, used to convert activity timestamps to local time
                fields.push(activity_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(activity_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                fields.push(activity_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn activity_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_num_sessions_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "num_sessions",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "type",
        FieldDataType::Activity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // session
                fields.push(session_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // stop
                fields.push(session_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(session_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(session_message_start_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            4 => {
                fields.push(session_message_start_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            5 => {
                fields.push(session_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(session_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                // Time (includes pauses)
                fields.push(session_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            8 => {
                // Timer Time (excludes pauses)
                fields.push(session_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            9 => {
                fields.push(session_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            10 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strides",
                        value,
                    )?);
                } else if Sport::Walking.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strides",
                        value,
                    )?);
                } else if Sport::Cycling.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Swimming.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Rowing.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strokes",
                        value,
                    )?);
                } else if Sport::StandUpPaddleboarding.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(session_message_total_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "cycles",
                        value,
                    )?);
                }
            }
            11 => {
                fields.push(session_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal",
                    value,
                )?);
            }
            13 => {
                fields.push(session_message_total_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal",
                    value,
                )?);
            }
            14 => {
                // total_distance / total_timer_time
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_avg_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(124, enhanced_avg_speed.clone());
                // total_distance / total_timer_time
                fields.push(session_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    enhanced_avg_speed,
                )?);
            }
            15 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_max_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(125, enhanced_max_speed.clone());
                fields.push(session_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    enhanced_max_speed,
                )?);
            }
            16 => {
                // average heart rate (excludes pause time)
                fields.push(session_message_avg_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            17 => {
                fields.push(session_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            18 => {
                // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
                if Sport::Running.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_avg_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(session_message_avg_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "rpm",
                        value,
                    )?);
                }
            }
            19 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_max_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(session_message_max_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "rpm",
                        value,
                    )?);
                }
            }
            20 => {
                // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
                fields.push(session_message_avg_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            21 => {
                fields.push(session_message_max_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            22 => {
                fields.push(session_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            23 => {
                fields.push(session_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            24 => {
                fields.push(session_message_total_training_effect_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            25 => {
                fields.push(session_message_first_lap_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            26 => {
                fields.push(session_message_num_laps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            27 => {
                fields.push(session_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            28 => {
                fields.push(session_message_trigger_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            29 => {
                // North east corner latitude
                fields.push(session_message_nec_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            30 => {
                // North east corner longitude
                fields.push(session_message_nec_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            31 => {
                // South west corner latitude
                fields.push(session_message_swc_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            32 => {
                // South west corner longitude
                fields.push(session_message_swc_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            33 => {
                // # of lengths of swim pool
                fields.push(session_message_num_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "lengths",
                    value,
                )?);
            }
            34 => {
                fields.push(session_message_normalized_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            35 => {
                fields.push(session_message_training_stress_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "tss",
                    value,
                )?);
            }
            36 => {
                fields.push(session_message_intensity_factor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "if",
                    value,
                )?);
            }
            37 => {
                fields.push(session_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            41 => {
                fields.push(session_message_avg_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "strokes/lap",
                    value,
                )?);
            }
            42 => {
                fields.push(session_message_avg_stroke_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            43 => {
                fields.push(session_message_swim_stroke_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "swim_stroke",
                    value,
                )?);
            }
            44 => {
                fields.push(session_message_pool_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            45 => {
                fields.push(session_message_threshold_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            46 => {
                fields.push(session_message_pool_length_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            47 => {
                // # of active lengths of swim pool
                fields.push(session_message_num_active_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "lengths",
                    value,
                )?);
            }
            48 => {
                fields.push(session_message_total_work_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "J",
                    value,
                )?);
            }
            49 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_avg_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5.000000,
                        500.000000,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(126, enhanced_avg_altitude.clone());
                fields.push(session_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    enhanced_avg_altitude,
                )?);
            }
            50 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_max_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5.000000,
                        500.000000,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(128, enhanced_max_altitude.clone());
                fields.push(session_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    enhanced_max_altitude,
                )?);
            }
            51 => {
                fields.push(session_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            52 => {
                fields.push(session_message_avg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            53 => {
                fields.push(session_message_avg_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            54 => {
                fields.push(session_message_avg_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            55 => {
                fields.push(session_message_max_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            56 => {
                fields.push(session_message_max_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            57 => {
                fields.push(session_message_avg_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            58 => {
                fields.push(session_message_max_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            59 => {
                fields.push(session_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            60 => {
                fields.push(session_message_avg_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            61 => {
                fields.push(session_message_avg_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            62 => {
                fields.push(session_message_max_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            63 => {
                fields.push(session_message_max_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            64 => {
                fields.push(session_message_min_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            65 => {
                fields.push(session_message_time_in_hr_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            66 => {
                fields.push(session_message_time_in_speed_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            67 => {
                fields.push(session_message_time_in_cadence_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            68 => {
                fields.push(session_message_time_in_power_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            69 => {
                fields.push(session_message_avg_lap_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            70 => {
                fields.push(session_message_best_lap_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            71 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_min_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5.000000,
                        500.000000,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_min_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(127, enhanced_min_altitude.clone());
                fields.push(session_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    enhanced_min_altitude,
                )?);
            }
            82 => {
                fields.push(session_message_player_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            83 => {
                fields.push(session_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            84 => {
                fields.push(session_message_opponent_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            85 => {
                // stroke_type enum used as the index
                fields.push(session_message_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            86 => {
                // zone number used as the index
                fields.push(session_message_zone_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            87 => {
                fields.push(session_message_max_ball_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            88 => {
                fields.push(session_message_avg_ball_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            89 => {
                fields.push(session_message_avg_vertical_oscillation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            90 => {
                fields.push(session_message_avg_stance_time_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            91 => {
                fields.push(session_message_avg_stance_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            92 => {
                // fractional part of the avg_cadence
                fields.push(session_message_avg_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            93 => {
                // fractional part of the max_cadence
                fields.push(session_message_max_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            94 => {
                // fractional part of the total_cycles
                fields.push(session_message_total_fractional_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128.000000,
                    0.000000,
                    "cycles",
                    value,
                )?);
            }
            95 => {
                // Avg saturated and unsaturated hemoglobin
                fields.push(session_message_avg_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "g/dL",
                    value,
                )?);
            }
            96 => {
                // Min saturated and unsaturated hemoglobin
                fields.push(session_message_min_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "g/dL",
                    value,
                )?);
            }
            97 => {
                // Max saturated and unsaturated hemoglobin
                fields.push(session_message_max_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "g/dL",
                    value,
                )?);
            }
            98 => {
                // Avg percentage of hemoglobin saturated with oxygen
                fields.push(session_message_avg_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            99 => {
                // Min percentage of hemoglobin saturated with oxygen
                fields.push(session_message_min_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            100 => {
                // Max percentage of hemoglobin saturated with oxygen
                fields.push(session_message_max_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            101 => {
                fields.push(session_message_avg_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            102 => {
                fields.push(session_message_avg_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            103 => {
                fields.push(session_message_avg_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            104 => {
                fields.push(session_message_avg_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            105 => {
                fields.push(session_message_avg_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            111 => {
                fields.push(session_message_sport_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            112 => {
                // Total time spend in the standing position
                fields.push(session_message_time_standing_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            113 => {
                // Number of transitions to the standing state
                fields.push(session_message_stand_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            114 => {
                // Average platform center offset Left
                fields.push(session_message_avg_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            115 => {
                // Average platform center offset Right
                fields.push(session_message_avg_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            116 => {
                // Average left power phase angles. Indexes defined by power_phase_type.
                fields.push(session_message_avg_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            117 => {
                // Average left power phase peak angles. Data value indexes defined by power_phase_type.
                fields.push(session_message_avg_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            118 => {
                // Average right power phase angles. Data value indexes defined by power_phase_type.
                fields.push(session_message_avg_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            119 => {
                // Average right power phase peak angles data value indexes defined by power_phase_type.
                fields.push(session_message_avg_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            120 => {
                // Average power by position. Data value indexes defined by rider_position_type.
                fields.push(session_message_avg_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            121 => {
                // Maximum power by position. Data value indexes defined by rider_position_type.
                fields.push(session_message_max_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            122 => {
                // Average cadence by position. Data value indexes defined by rider_position_type.
                fields.push(session_message_avg_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            123 => {
                // Maximum cadence by position. Data value indexes defined by rider_position_type.
                fields.push(session_message_max_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            124 => {
                // total_distance / total_timer_time
                fields.push(session_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            125 => {
                fields.push(session_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            126 => {
                fields.push(session_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            127 => {
                fields.push(session_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            128 => {
                fields.push(session_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            129 => {
                // lev average motor power during session
                fields.push(session_message_avg_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            130 => {
                // lev maximum motor power during session
                fields.push(session_message_max_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            131 => {
                // lev battery consumption during session
                fields.push(session_message_lev_battery_consumption_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            132 => {
                fields.push(session_message_avg_vertical_ratio_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            133 => {
                fields.push(session_message_avg_stance_time_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            134 => {
                fields.push(session_message_avg_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            137 => {
                fields.push(session_message_total_anaerobic_training_effect_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            139 => {
                fields.push(session_message_avg_vam_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            168 => {
                fields.push(session_message_training_load_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    65536.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            181 => {
                // The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
                fields.push(session_message_total_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kGrit",
                    value,
                )?);
            }
            182 => {
                // The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
                fields.push(session_message_total_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "Flow",
                    value,
                )?);
            }
            183 => {
                fields.push(session_message_jump_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            186 => {
                // The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
                fields.push(session_message_avg_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kGrit",
                    value,
                )?);
            }
            187 => {
                // The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
                fields.push(session_message_avg_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "Flow",
                    value,
                )?);
            }
            199 => {
                // fractional part of total_ascent
                fields.push(session_message_total_fractional_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            200 => {
                // fractional part of total_descent
                fields.push(session_message_total_fractional_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            208 => {
                fields.push(session_message_avg_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            209 => {
                fields.push(session_message_min_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            210 => {
                fields.push(session_message_max_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            253 => {
                // Sesson end time.
                fields.push(session_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            254 => {
                // Selected bit is set for the current session.
                fields.push(session_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn session_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "start_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "start_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_strides_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strides"
    };
    data_field_with_info(
        10,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strokes"
    };
    data_field_with_info(
        10,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13, value)?
    } else {
        value
    };
    data_field_with_info(
        13,
        "total_fat_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14, value)?
    } else {
        value
    };
    data_field_with_info(
        14,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15, value)?
    } else {
        value
    };
    data_field_with_info(
        15,
        "max_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16, value)?
    } else {
        value
    };
    data_field_with_info(
        16,
        "avg_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17, value)?
    } else {
        value
    };
    data_field_with_info(
        17,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18, value)?
    } else {
        value
    };
    data_field_with_info(
        18,
        "avg_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "avg_cadence"
    } else {
        "avg_running_cadence"
    };
    data_field_with_info(
        18,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19, value)?
    } else {
        value
    };
    data_field_with_info(
        19,
        "max_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "max_cadence"
    } else {
        "max_running_cadence"
    };
    data_field_with_info(
        19,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    data_field_with_info(
        20,
        "avg_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    data_field_with_info(
        21,
        "max_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    data_field_with_info(
        22,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23, value)?
    } else {
        value
    };
    data_field_with_info(
        23,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_training_effect_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24, value)?
    } else {
        value
    };
    data_field_with_info(
        24,
        "total_training_effect",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_first_lap_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25, value)?
    } else {
        value
    };
    data_field_with_info(
        25,
        "first_lap_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_num_laps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26, value)?
    } else {
        value
    };
    data_field_with_info(
        26,
        "num_laps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27, value)?
    } else {
        value
    };
    data_field_with_info(
        27,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_trigger_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28, value)?
    } else {
        value
    };
    data_field_with_info(
        28,
        "trigger",
        FieldDataType::SessionTrigger,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_nec_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29, value)?
    } else {
        value
    };
    data_field_with_info(
        29,
        "nec_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_nec_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30, value)?
    } else {
        value
    };
    data_field_with_info(
        30,
        "nec_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_swc_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31, value)?
    } else {
        value
    };
    data_field_with_info(
        31,
        "swc_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_swc_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32, value)?
    } else {
        value
    };
    data_field_with_info(
        32,
        "swc_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_num_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33, value)?
    } else {
        value
    };
    data_field_with_info(
        33,
        "num_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_normalized_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34, value)?
    } else {
        value
    };
    data_field_with_info(
        34,
        "normalized_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_training_stress_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 35, value)?
    } else {
        value
    };
    data_field_with_info(
        35,
        "training_stress_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_intensity_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 36, value)?
    } else {
        value
    };
    data_field_with_info(
        36,
        "intensity_factor",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37, value)?
    } else {
        value
    };
    data_field_with_info(
        37,
        "left_right_balance",
        FieldDataType::LeftRightBalance100,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41, value)?
    } else {
        value
    };
    data_field_with_info(
        41,
        "avg_stroke_count",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stroke_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42, value)?
    } else {
        value
    };
    data_field_with_info(
        42,
        "avg_stroke_distance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_swim_stroke_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43, value)?
    } else {
        value
    };
    data_field_with_info(
        43,
        "swim_stroke",
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_pool_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44, value)?
    } else {
        value
    };
    data_field_with_info(
        44,
        "pool_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_threshold_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45, value)?
    } else {
        value
    };
    data_field_with_info(
        45,
        "threshold_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_pool_length_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46, value)?
    } else {
        value
    };
    data_field_with_info(
        46,
        "pool_length_unit",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_num_active_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47, value)?
    } else {
        value
    };
    data_field_with_info(
        47,
        "num_active_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_work_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48, value)?
    } else {
        value
    };
    data_field_with_info(
        48,
        "total_work",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49, value)?
    } else {
        value
    };
    data_field_with_info(
        49,
        "avg_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50, value)?
    } else {
        value
    };
    data_field_with_info(
        50,
        "max_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51, value)?
    } else {
        value
    };
    data_field_with_info(
        51,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52, value)?
    } else {
        value
    };
    data_field_with_info(
        52,
        "avg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53, value)?
    } else {
        value
    };
    data_field_with_info(
        53,
        "avg_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54, value)?
    } else {
        value
    };
    data_field_with_info(
        54,
        "avg_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55, value)?
    } else {
        value
    };
    data_field_with_info(
        55,
        "max_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56, value)?
    } else {
        value
    };
    data_field_with_info(
        56,
        "max_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57, value)?
    } else {
        value
    };
    data_field_with_info(
        57,
        "avg_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58, value)?
    } else {
        value
    };
    data_field_with_info(
        58,
        "max_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59, value)?
    } else {
        value
    };
    data_field_with_info(
        59,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 60, value)?
    } else {
        value
    };
    data_field_with_info(
        60,
        "avg_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 61, value)?
    } else {
        value
    };
    data_field_with_info(
        61,
        "avg_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62, value)?
    } else {
        value
    };
    data_field_with_info(
        62,
        "max_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 63, value)?
    } else {
        value
    };
    data_field_with_info(
        63,
        "max_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 64, value)?
    } else {
        value
    };
    data_field_with_info(
        64,
        "min_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 65, value)?
    } else {
        value
    };
    data_field_with_info(
        65,
        "time_in_hr_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 66, value)?
    } else {
        value
    };
    data_field_with_info(
        66,
        "time_in_speed_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 67, value)?
    } else {
        value
    };
    data_field_with_info(
        67,
        "time_in_cadence_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 68, value)?
    } else {
        value
    };
    data_field_with_info(
        68,
        "time_in_power_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_lap_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 69, value)?
    } else {
        value
    };
    data_field_with_info(
        69,
        "avg_lap_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_best_lap_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 70, value)?
    } else {
        value
    };
    data_field_with_info(
        70,
        "best_lap_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71, value)?
    } else {
        value
    };
    data_field_with_info(
        71,
        "min_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_player_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82, value)?
    } else {
        value
    };
    data_field_with_info(
        82,
        "player_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83, value)?
    } else {
        value
    };
    data_field_with_info(
        83,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_opponent_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84, value)?
    } else {
        value
    };
    data_field_with_info(
        84,
        "opponent_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85, value)?
    } else {
        value
    };
    data_field_with_info(
        85,
        "stroke_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_zone_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86, value)?
    } else {
        value
    };
    data_field_with_info(
        86,
        "zone_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_ball_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 87, value)?
    } else {
        value
    };
    data_field_with_info(
        87,
        "max_ball_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_ball_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 88, value)?
    } else {
        value
    };
    data_field_with_info(
        88,
        "avg_ball_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_vertical_oscillation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89, value)?
    } else {
        value
    };
    data_field_with_info(
        89,
        "avg_vertical_oscillation",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stance_time_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 90, value)?
    } else {
        value
    };
    data_field_with_info(
        90,
        "avg_stance_time_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stance_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 91, value)?
    } else {
        value
    };
    data_field_with_info(
        91,
        "avg_stance_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 92, value)?
    } else {
        value
    };
    data_field_with_info(
        92,
        "avg_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 93, value)?
    } else {
        value
    };
    data_field_with_info(
        93,
        "max_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fractional_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94, value)?
    } else {
        value
    };
    data_field_with_info(
        94,
        "total_fractional_cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95, value)?
    } else {
        value
    };
    data_field_with_info(
        95,
        "avg_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 96, value)?
    } else {
        value
    };
    data_field_with_info(
        96,
        "min_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 97, value)?
    } else {
        value
    };
    data_field_with_info(
        97,
        "max_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 98, value)?
    } else {
        value
    };
    data_field_with_info(
        98,
        "avg_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 99, value)?
    } else {
        value
    };
    data_field_with_info(
        99,
        "min_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 100, value)?
    } else {
        value
    };
    data_field_with_info(
        100,
        "max_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 101, value)?
    } else {
        value
    };
    data_field_with_info(
        101,
        "avg_left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 102, value)?
    } else {
        value
    };
    data_field_with_info(
        102,
        "avg_right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 103, value)?
    } else {
        value
    };
    data_field_with_info(
        103,
        "avg_left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 104, value)?
    } else {
        value
    };
    data_field_with_info(
        104,
        "avg_right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 105, value)?
    } else {
        value
    };
    data_field_with_info(
        105,
        "avg_combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sport_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 111, value)?
    } else {
        value
    };
    data_field_with_info(
        111,
        "sport_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_standing_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 112, value)?
    } else {
        value
    };
    data_field_with_info(
        112,
        "time_standing",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_stand_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 113, value)?
    } else {
        value
    };
    data_field_with_info(
        113,
        "stand_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 114, value)?
    } else {
        value
    };
    data_field_with_info(
        114,
        "avg_left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 115, value)?
    } else {
        value
    };
    data_field_with_info(
        115,
        "avg_right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 116, value)?
    } else {
        value
    };
    data_field_with_info(
        116,
        "avg_left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 117, value)?
    } else {
        value
    };
    data_field_with_info(
        117,
        "avg_left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 118, value)?
    } else {
        value
    };
    data_field_with_info(
        118,
        "avg_right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 119, value)?
    } else {
        value
    };
    data_field_with_info(
        119,
        "avg_right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 120, value)?
    } else {
        value
    };
    data_field_with_info(
        120,
        "avg_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 121, value)?
    } else {
        value
    };
    data_field_with_info(
        121,
        "max_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 122, value)?
    } else {
        value
    };
    data_field_with_info(
        122,
        "avg_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 123, value)?
    } else {
        value
    };
    data_field_with_info(
        123,
        "max_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 124, value)?
    } else {
        value
    };
    data_field_with_info(
        124,
        "enhanced_avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 125, value)?
    } else {
        value
    };
    data_field_with_info(
        125,
        "enhanced_max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 126, value)?
    } else {
        value
    };
    data_field_with_info(
        126,
        "enhanced_avg_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 127, value)?
    } else {
        value
    };
    data_field_with_info(
        127,
        "enhanced_min_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 128, value)?
    } else {
        value
    };
    data_field_with_info(
        128,
        "enhanced_max_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 129, value)?
    } else {
        value
    };
    data_field_with_info(
        129,
        "avg_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 130, value)?
    } else {
        value
    };
    data_field_with_info(
        130,
        "max_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_lev_battery_consumption_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 131, value)?
    } else {
        value
    };
    data_field_with_info(
        131,
        "lev_battery_consumption",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_vertical_ratio_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 132, value)?
    } else {
        value
    };
    data_field_with_info(
        132,
        "avg_vertical_ratio",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stance_time_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 133, value)?
    } else {
        value
    };
    data_field_with_info(
        133,
        "avg_stance_time_balance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 134, value)?
    } else {
        value
    };
    data_field_with_info(
        134,
        "avg_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_anaerobic_training_effect_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 137, value)?
    } else {
        value
    };
    data_field_with_info(
        137,
        "total_anaerobic_training_effect",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_vam_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 139, value)?
    } else {
        value
    };
    data_field_with_info(
        139,
        "avg_vam",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_training_load_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 168, value)?
    } else {
        value
    };
    data_field_with_info(
        168,
        "training_load_peak",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 181, value)?
    } else {
        value
    };
    data_field_with_info(
        181,
        "total_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 182, value)?
    } else {
        value
    };
    data_field_with_info(
        182,
        "total_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_jump_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 183, value)?
    } else {
        value
    };
    data_field_with_info(
        183,
        "jump_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 186, value)?
    } else {
        value
    };
    data_field_with_info(
        186,
        "avg_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 187, value)?
    } else {
        value
    };
    data_field_with_info(
        187,
        "avg_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fractional_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 199, value)?
    } else {
        value
    };
    data_field_with_info(
        199,
        "total_fractional_ascent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fractional_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 200, value)?
    } else {
        value
    };
    data_field_with_info(
        200,
        "total_fractional_descent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 208, value)?
    } else {
        value
    };
    data_field_with_info(
        208,
        "avg_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 209, value)?
    } else {
        value
    };
    data_field_with_info(
        209,
        "min_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 210, value)?
    } else {
        value
    };
    data_field_with_info(
        210,
        "max_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(lap_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(lap_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(lap_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(lap_message_start_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            4 => {
                fields.push(lap_message_start_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            5 => {
                fields.push(lap_message_end_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            6 => {
                fields.push(lap_message_end_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            7 => {
                // Time (includes pauses)
                fields.push(lap_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            8 => {
                // Timer Time (excludes pauses)
                fields.push(lap_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            9 => {
                fields.push(lap_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            10 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&25)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strides",
                        value,
                    )?);
                } else if Sport::Walking.as_i64()
                    == data_map
                        .get(&25)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strides",
                        value,
                    )?);
                } else if Sport::Cycling.as_i64()
                    == data_map
                        .get(&25)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Swimming.as_i64()
                    == data_map
                        .get(&25)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Rowing.as_i64()
                    == data_map
                        .get(&25)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strokes",
                        value,
                    )?);
                } else if Sport::StandUpPaddleboarding.as_i64()
                    == data_map
                        .get(&25)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(lap_message_total_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "cycles",
                        value,
                    )?);
                }
            }
            11 => {
                fields.push(lap_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal",
                    value,
                )?);
            }
            12 => {
                // If New Leaf
                fields.push(lap_message_total_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal",
                    value,
                )?);
            }
            13 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_avg_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(110, enhanced_avg_speed.clone());
                fields.push(lap_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    enhanced_avg_speed,
                )?);
            }
            14 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_max_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(111, enhanced_max_speed.clone());
                fields.push(lap_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    enhanced_max_speed,
                )?);
            }
            15 => {
                fields.push(lap_message_avg_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            16 => {
                fields.push(lap_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            17 => {
                // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
                if Sport::Running.as_i64()
                    == data_map
                        .get(&25)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_avg_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(lap_message_avg_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "rpm",
                        value,
                    )?);
                }
            }
            18 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&25)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_max_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(lap_message_max_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "rpm",
                        value,
                    )?);
                }
            }
            19 => {
                // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
                fields.push(lap_message_avg_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            20 => {
                fields.push(lap_message_max_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            21 => {
                fields.push(lap_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            22 => {
                fields.push(lap_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            23 => {
                fields.push(lap_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            24 => {
                fields.push(lap_message_lap_trigger_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            25 => {
                fields.push(lap_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            26 => {
                fields.push(lap_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            32 => {
                // # of lengths of swim pool
                fields.push(lap_message_num_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "lengths",
                    value,
                )?);
            }
            33 => {
                fields.push(lap_message_normalized_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            34 => {
                fields.push(lap_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            35 => {
                fields.push(lap_message_first_length_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            37 => {
                fields.push(lap_message_avg_stroke_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            38 => {
                fields.push(lap_message_swim_stroke_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            39 => {
                fields.push(lap_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            40 => {
                // # of active lengths of swim pool
                fields.push(lap_message_num_active_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "lengths",
                    value,
                )?);
            }
            41 => {
                fields.push(lap_message_total_work_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "J",
                    value,
                )?);
            }
            42 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_avg_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5.000000,
                        500.000000,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(112, enhanced_avg_altitude.clone());
                fields.push(lap_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    enhanced_avg_altitude,
                )?);
            }
            43 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_max_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5.000000,
                        500.000000,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(114, enhanced_max_altitude.clone());
                fields.push(lap_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    enhanced_max_altitude,
                )?);
            }
            44 => {
                fields.push(lap_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            45 => {
                fields.push(lap_message_avg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            46 => {
                fields.push(lap_message_avg_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            47 => {
                fields.push(lap_message_avg_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            48 => {
                fields.push(lap_message_max_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            49 => {
                fields.push(lap_message_max_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            50 => {
                fields.push(lap_message_avg_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            51 => {
                fields.push(lap_message_max_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            52 => {
                fields.push(lap_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            53 => {
                fields.push(lap_message_avg_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            54 => {
                fields.push(lap_message_avg_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            55 => {
                fields.push(lap_message_max_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            56 => {
                fields.push(lap_message_max_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            57 => {
                fields.push(lap_message_time_in_hr_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            58 => {
                fields.push(lap_message_time_in_speed_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            59 => {
                fields.push(lap_message_time_in_cadence_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            60 => {
                fields.push(lap_message_time_in_power_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            61 => {
                fields.push(lap_message_repetition_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            62 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_min_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5.000000,
                        500.000000,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_min_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(113, enhanced_min_altitude.clone());
                fields.push(lap_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    enhanced_min_altitude,
                )?);
            }
            63 => {
                fields.push(lap_message_min_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            71 => {
                fields.push(lap_message_wkt_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            74 => {
                fields.push(lap_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            75 => {
                // stroke_type enum used as the index
                fields.push(lap_message_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            76 => {
                // zone number used as the index
                fields.push(lap_message_zone_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            77 => {
                fields.push(lap_message_avg_vertical_oscillation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            78 => {
                fields.push(lap_message_avg_stance_time_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            79 => {
                fields.push(lap_message_avg_stance_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            80 => {
                // fractional part of the avg_cadence
                fields.push(lap_message_avg_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            81 => {
                // fractional part of the max_cadence
                fields.push(lap_message_max_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            82 => {
                // fractional part of the total_cycles
                fields.push(lap_message_total_fractional_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128.000000,
                    0.000000,
                    "cycles",
                    value,
                )?);
            }
            83 => {
                fields.push(lap_message_player_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            84 => {
                // Avg saturated and unsaturated hemoglobin
                fields.push(lap_message_avg_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "g/dL",
                    value,
                )?);
            }
            85 => {
                // Min saturated and unsaturated hemoglobin
                fields.push(lap_message_min_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "g/dL",
                    value,
                )?);
            }
            86 => {
                // Max saturated and unsaturated hemoglobin
                fields.push(lap_message_max_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "g/dL",
                    value,
                )?);
            }
            87 => {
                // Avg percentage of hemoglobin saturated with oxygen
                fields.push(lap_message_avg_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            88 => {
                // Min percentage of hemoglobin saturated with oxygen
                fields.push(lap_message_min_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            89 => {
                // Max percentage of hemoglobin saturated with oxygen
                fields.push(lap_message_max_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            91 => {
                fields.push(lap_message_avg_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            92 => {
                fields.push(lap_message_avg_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            93 => {
                fields.push(lap_message_avg_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            94 => {
                fields.push(lap_message_avg_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            95 => {
                fields.push(lap_message_avg_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            98 => {
                // Total time spent in the standing position
                fields.push(lap_message_time_standing_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            99 => {
                // Number of transitions to the standing state
                fields.push(lap_message_stand_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            100 => {
                // Average left platform center offset
                fields.push(lap_message_avg_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            101 => {
                // Average right platform center offset
                fields.push(lap_message_avg_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            102 => {
                // Average left power phase angles. Data value indexes defined by power_phase_type.
                fields.push(lap_message_avg_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            103 => {
                // Average left power phase peak angles. Data value indexes defined by power_phase_type.
                fields.push(lap_message_avg_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            104 => {
                // Average right power phase angles. Data value indexes defined by power_phase_type.
                fields.push(lap_message_avg_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            105 => {
                // Average right power phase peak angles. Data value indexes defined by power_phase_type.
                fields.push(lap_message_avg_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            106 => {
                // Average power by position. Data value indexes defined by rider_position_type.
                fields.push(lap_message_avg_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            107 => {
                // Maximum power by position. Data value indexes defined by rider_position_type.
                fields.push(lap_message_max_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            108 => {
                // Average cadence by position. Data value indexes defined by rider_position_type.
                fields.push(lap_message_avg_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            109 => {
                // Maximum cadence by position. Data value indexes defined by rider_position_type.
                fields.push(lap_message_max_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            110 => {
                fields.push(lap_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            111 => {
                fields.push(lap_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            112 => {
                fields.push(lap_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            113 => {
                fields.push(lap_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            114 => {
                fields.push(lap_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            115 => {
                // lev average motor power during lap
                fields.push(lap_message_avg_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            116 => {
                // lev maximum motor power during lap
                fields.push(lap_message_max_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            117 => {
                // lev battery consumption during lap
                fields.push(lap_message_lev_battery_consumption_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            118 => {
                fields.push(lap_message_avg_vertical_ratio_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            119 => {
                fields.push(lap_message_avg_stance_time_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            120 => {
                fields.push(lap_message_avg_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            121 => {
                fields.push(lap_message_avg_vam_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            149 => {
                // The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
                fields.push(lap_message_total_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kGrit",
                    value,
                )?);
            }
            150 => {
                // The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
                fields.push(lap_message_total_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "Flow",
                    value,
                )?);
            }
            151 => {
                fields.push(lap_message_jump_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            153 => {
                // The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
                fields.push(lap_message_avg_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kGrit",
                    value,
                )?);
            }
            154 => {
                // The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
                fields.push(lap_message_avg_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "Flow",
                    value,
                )?);
            }
            156 => {
                // fractional part of total_ascent
                fields.push(lap_message_total_fractional_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            157 => {
                // fractional part of total_descent
                fields.push(lap_message_total_fractional_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            158 => {
                fields.push(lap_message_avg_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            159 => {
                fields.push(lap_message_min_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            160 => {
                fields.push(lap_message_max_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            253 => {
                // Lap end time.
                fields.push(lap_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            254 => {
                fields.push(lap_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn lap_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_start_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "start_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_start_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "start_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_end_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "end_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_end_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "end_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_strides_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strides"
    };
    data_field_with_info(
        10,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strokes"
    };
    data_field_with_info(
        10,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "total_fat_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13, value)?
    } else {
        value
    };
    data_field_with_info(
        13,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14, value)?
    } else {
        value
    };
    data_field_with_info(
        14,
        "max_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15, value)?
    } else {
        value
    };
    data_field_with_info(
        15,
        "avg_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16, value)?
    } else {
        value
    };
    data_field_with_info(
        16,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17, value)?
    } else {
        value
    };
    data_field_with_info(
        17,
        "avg_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "avg_cadence"
    } else {
        "avg_running_cadence"
    };
    data_field_with_info(
        17,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18, value)?
    } else {
        value
    };
    data_field_with_info(
        18,
        "max_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "max_cadence"
    } else {
        "max_running_cadence"
    };
    data_field_with_info(
        18,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19, value)?
    } else {
        value
    };
    data_field_with_info(
        19,
        "avg_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    data_field_with_info(
        20,
        "max_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    data_field_with_info(
        21,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    data_field_with_info(
        22,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23, value)?
    } else {
        value
    };
    data_field_with_info(
        23,
        "intensity",
        FieldDataType::Intensity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_lap_trigger_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24, value)?
    } else {
        value
    };
    data_field_with_info(
        24,
        "lap_trigger",
        FieldDataType::LapTrigger,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25, value)?
    } else {
        value
    };
    data_field_with_info(
        25,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26, value)?
    } else {
        value
    };
    data_field_with_info(
        26,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_num_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32, value)?
    } else {
        value
    };
    data_field_with_info(
        32,
        "num_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_normalized_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33, value)?
    } else {
        value
    };
    data_field_with_info(
        33,
        "normalized_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34, value)?
    } else {
        value
    };
    data_field_with_info(
        34,
        "left_right_balance",
        FieldDataType::LeftRightBalance100,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_first_length_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 35, value)?
    } else {
        value
    };
    data_field_with_info(
        35,
        "first_length_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stroke_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37, value)?
    } else {
        value
    };
    data_field_with_info(
        37,
        "avg_stroke_distance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_swim_stroke_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 38, value)?
    } else {
        value
    };
    data_field_with_info(
        38,
        "swim_stroke",
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39, value)?
    } else {
        value
    };
    data_field_with_info(
        39,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_num_active_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40, value)?
    } else {
        value
    };
    data_field_with_info(
        40,
        "num_active_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_work_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41, value)?
    } else {
        value
    };
    data_field_with_info(
        41,
        "total_work",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42, value)?
    } else {
        value
    };
    data_field_with_info(
        42,
        "avg_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43, value)?
    } else {
        value
    };
    data_field_with_info(
        43,
        "max_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44, value)?
    } else {
        value
    };
    data_field_with_info(
        44,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45, value)?
    } else {
        value
    };
    data_field_with_info(
        45,
        "avg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46, value)?
    } else {
        value
    };
    data_field_with_info(
        46,
        "avg_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47, value)?
    } else {
        value
    };
    data_field_with_info(
        47,
        "avg_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48, value)?
    } else {
        value
    };
    data_field_with_info(
        48,
        "max_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49, value)?
    } else {
        value
    };
    data_field_with_info(
        49,
        "max_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50, value)?
    } else {
        value
    };
    data_field_with_info(
        50,
        "avg_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51, value)?
    } else {
        value
    };
    data_field_with_info(
        51,
        "max_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52, value)?
    } else {
        value
    };
    data_field_with_info(
        52,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53, value)?
    } else {
        value
    };
    data_field_with_info(
        53,
        "avg_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54, value)?
    } else {
        value
    };
    data_field_with_info(
        54,
        "avg_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55, value)?
    } else {
        value
    };
    data_field_with_info(
        55,
        "max_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56, value)?
    } else {
        value
    };
    data_field_with_info(
        56,
        "max_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57, value)?
    } else {
        value
    };
    data_field_with_info(
        57,
        "time_in_hr_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58, value)?
    } else {
        value
    };
    data_field_with_info(
        58,
        "time_in_speed_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59, value)?
    } else {
        value
    };
    data_field_with_info(
        59,
        "time_in_cadence_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 60, value)?
    } else {
        value
    };
    data_field_with_info(
        60,
        "time_in_power_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_repetition_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 61, value)?
    } else {
        value
    };
    data_field_with_info(
        61,
        "repetition_num",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62, value)?
    } else {
        value
    };
    data_field_with_info(
        62,
        "min_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 63, value)?
    } else {
        value
    };
    data_field_with_info(
        63,
        "min_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_wkt_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71, value)?
    } else {
        value
    };
    data_field_with_info(
        71,
        "wkt_step_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 74, value)?
    } else {
        value
    };
    data_field_with_info(
        74,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 75, value)?
    } else {
        value
    };
    data_field_with_info(
        75,
        "stroke_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_zone_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 76, value)?
    } else {
        value
    };
    data_field_with_info(
        76,
        "zone_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_vertical_oscillation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 77, value)?
    } else {
        value
    };
    data_field_with_info(
        77,
        "avg_vertical_oscillation",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stance_time_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 78, value)?
    } else {
        value
    };
    data_field_with_info(
        78,
        "avg_stance_time_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stance_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 79, value)?
    } else {
        value
    };
    data_field_with_info(
        79,
        "avg_stance_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 80, value)?
    } else {
        value
    };
    data_field_with_info(
        80,
        "avg_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 81, value)?
    } else {
        value
    };
    data_field_with_info(
        81,
        "max_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fractional_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82, value)?
    } else {
        value
    };
    data_field_with_info(
        82,
        "total_fractional_cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_player_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83, value)?
    } else {
        value
    };
    data_field_with_info(
        83,
        "player_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84, value)?
    } else {
        value
    };
    data_field_with_info(
        84,
        "avg_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85, value)?
    } else {
        value
    };
    data_field_with_info(
        85,
        "min_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86, value)?
    } else {
        value
    };
    data_field_with_info(
        86,
        "max_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 87, value)?
    } else {
        value
    };
    data_field_with_info(
        87,
        "avg_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 88, value)?
    } else {
        value
    };
    data_field_with_info(
        88,
        "min_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89, value)?
    } else {
        value
    };
    data_field_with_info(
        89,
        "max_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 91, value)?
    } else {
        value
    };
    data_field_with_info(
        91,
        "avg_left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 92, value)?
    } else {
        value
    };
    data_field_with_info(
        92,
        "avg_right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 93, value)?
    } else {
        value
    };
    data_field_with_info(
        93,
        "avg_left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94, value)?
    } else {
        value
    };
    data_field_with_info(
        94,
        "avg_right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95, value)?
    } else {
        value
    };
    data_field_with_info(
        95,
        "avg_combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_standing_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 98, value)?
    } else {
        value
    };
    data_field_with_info(
        98,
        "time_standing",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_stand_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 99, value)?
    } else {
        value
    };
    data_field_with_info(
        99,
        "stand_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 100, value)?
    } else {
        value
    };
    data_field_with_info(
        100,
        "avg_left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 101, value)?
    } else {
        value
    };
    data_field_with_info(
        101,
        "avg_right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 102, value)?
    } else {
        value
    };
    data_field_with_info(
        102,
        "avg_left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 103, value)?
    } else {
        value
    };
    data_field_with_info(
        103,
        "avg_left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 104, value)?
    } else {
        value
    };
    data_field_with_info(
        104,
        "avg_right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 105, value)?
    } else {
        value
    };
    data_field_with_info(
        105,
        "avg_right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 106, value)?
    } else {
        value
    };
    data_field_with_info(
        106,
        "avg_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 107, value)?
    } else {
        value
    };
    data_field_with_info(
        107,
        "max_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 108, value)?
    } else {
        value
    };
    data_field_with_info(
        108,
        "avg_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 109, value)?
    } else {
        value
    };
    data_field_with_info(
        109,
        "max_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 110, value)?
    } else {
        value
    };
    data_field_with_info(
        110,
        "enhanced_avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 111, value)?
    } else {
        value
    };
    data_field_with_info(
        111,
        "enhanced_max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 112, value)?
    } else {
        value
    };
    data_field_with_info(
        112,
        "enhanced_avg_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 113, value)?
    } else {
        value
    };
    data_field_with_info(
        113,
        "enhanced_min_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 114, value)?
    } else {
        value
    };
    data_field_with_info(
        114,
        "enhanced_max_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 115, value)?
    } else {
        value
    };
    data_field_with_info(
        115,
        "avg_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 116, value)?
    } else {
        value
    };
    data_field_with_info(
        116,
        "max_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_lev_battery_consumption_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 117, value)?
    } else {
        value
    };
    data_field_with_info(
        117,
        "lev_battery_consumption",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_vertical_ratio_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 118, value)?
    } else {
        value
    };
    data_field_with_info(
        118,
        "avg_vertical_ratio",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stance_time_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 119, value)?
    } else {
        value
    };
    data_field_with_info(
        119,
        "avg_stance_time_balance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 120, value)?
    } else {
        value
    };
    data_field_with_info(
        120,
        "avg_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_vam_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 121, value)?
    } else {
        value
    };
    data_field_with_info(
        121,
        "avg_vam",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 149, value)?
    } else {
        value
    };
    data_field_with_info(
        149,
        "total_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 150, value)?
    } else {
        value
    };
    data_field_with_info(
        150,
        "total_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_jump_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 151, value)?
    } else {
        value
    };
    data_field_with_info(
        151,
        "jump_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 153, value)?
    } else {
        value
    };
    data_field_with_info(
        153,
        "avg_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 154, value)?
    } else {
        value
    };
    data_field_with_info(
        154,
        "avg_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fractional_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 156, value)?
    } else {
        value
    };
    data_field_with_info(
        156,
        "total_fractional_ascent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fractional_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 157, value)?
    } else {
        value
    };
    data_field_with_info(
        157,
        "total_fractional_descent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 158, value)?
    } else {
        value
    };
    data_field_with_info(
        158,
        "avg_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 159, value)?
    } else {
        value
    };
    data_field_with_info(
        159,
        "min_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 160, value)?
    } else {
        value
    };
    data_field_with_info(
        160,
        "max_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(length_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(length_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(length_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(length_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            4 => {
                fields.push(length_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            5 => {
                fields.push(length_message_total_strokes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "strokes",
                    value,
                )?);
            }
            6 => {
                fields.push(length_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            7 => {
                fields.push(length_message_swim_stroke_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "swim_stroke",
                    value,
                )?);
            }
            9 => {
                fields.push(length_message_avg_swimming_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "strokes/min",
                    value,
                )?);
            }
            10 => {
                fields.push(length_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                fields.push(length_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal",
                    value,
                )?);
            }
            12 => {
                fields.push(length_message_length_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            18 => {
                fields.push(length_message_player_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            19 => {
                fields.push(length_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            20 => {
                // stroke_type enum used as the index
                fields.push(length_message_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            21 => {
                // zone number used as the index
                fields.push(length_message_zone_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            253 => {
                fields.push(length_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(length_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn length_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "total_strokes",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_swim_stroke_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "swim_stroke",
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_avg_swimming_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "avg_swimming_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_length_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "length_type",
        FieldDataType::LengthType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_player_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18, value)?
    } else {
        value
    };
    data_field_with_info(
        18,
        "player_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19, value)?
    } else {
        value
    };
    data_field_with_info(
        19,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    data_field_with_info(
        20,
        "stroke_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_zone_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    data_field_with_info(
        21,
        "zone_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(record_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            1 => {
                fields.push(record_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            2 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5.000000,
                        500.000000,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_altitude) = extract_component(&input, 0usize, 16);
                data_map.insert(78, enhanced_altitude.clone());
                fields.push(record_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    enhanced_altitude,
                )?);
            }
            3 => {
                fields.push(record_message_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            4 => {
                fields.push(record_message_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            5 => {
                fields.push(record_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            6 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(73, enhanced_speed.clone());
                fields.push(record_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    enhanced_speed,
                )?);
            }
            7 => {
                fields.push(record_message_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_compressed_speed_distance_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "m/s,m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), speed) = extract_component(&input, 0usize, 12);
                let ((input, offset), distance) = extract_component(input, offset, 12);
                data_map.insert(6, speed.clone());
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100.000000,
                        0.000000,
                        "m/s",
                        speed.clone(),
                    )?);
                }
                let input = speed.to_ne_bytes();
                let ((input, offset), enhanced_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(73, enhanced_speed.clone());
                fields.push(record_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m/s",
                    enhanced_speed,
                )?);
                data_map.insert(5, distance.clone());
                fields.push(record_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    16.000000,
                    0.000000,
                    "m",
                    distance,
                )?);
            }
            9 => {
                fields.push(record_message_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            10 => {
                // Relative. 0 is none 254 is Max.
                fields.push(record_message_resistance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                fields.push(record_message_time_from_course_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            12 => {
                fields.push(record_message_cycle_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            13 => {
                fields.push(record_message_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            17 => {
                // Speed at 1s intervals. Timestamp field indicates time of last array element.
                fields.push(record_message_speed_1s_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    16.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            18 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        true,
                        1.000000,
                        0.000000,
                        "cycles",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), total_cycles) = extract_component(&input, 0usize, 8);
                data_map.insert(19, total_cycles.clone());
                fields.push(record_message_total_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    1.000000,
                    0.000000,
                    "cycles",
                    total_cycles,
                )?);
            }
            19 => {
                fields.push(record_message_total_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "cycles",
                    value,
                )?);
            }
            28 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_compressed_accumulated_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        true,
                        1.000000,
                        0.000000,
                        "watts",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), accumulated_power) = extract_component(&input, 0usize, 16);
                data_map.insert(29, accumulated_power.clone());
                fields.push(record_message_accumulated_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    1.000000,
                    0.000000,
                    "watts",
                    accumulated_power,
                )?);
            }
            29 => {
                fields.push(record_message_accumulated_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            30 => {
                fields.push(record_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            31 => {
                fields.push(record_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            32 => {
                fields.push(record_message_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            33 => {
                fields.push(record_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal",
                    value,
                )?);
            }
            39 => {
                fields.push(record_message_vertical_oscillation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            40 => {
                fields.push(record_message_stance_time_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            41 => {
                fields.push(record_message_stance_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            42 => {
                fields.push(record_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            43 => {
                fields.push(record_message_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            44 => {
                fields.push(record_message_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            45 => {
                fields.push(record_message_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            46 => {
                fields.push(record_message_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            47 => {
                fields.push(record_message_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            48 => {
                fields.push(record_message_time128_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            49 => {
                fields.push(record_message_stroke_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            50 => {
                fields.push(record_message_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            51 => {
                fields.push(record_message_ball_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            52 => {
                // Log cadence and fractional cadence for backwards compatability
                fields.push(record_message_cadence256_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            53 => {
                fields.push(record_message_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            54 => {
                // Total saturated and unsaturated hemoglobin
                fields.push(record_message_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "g/dL",
                    value,
                )?);
            }
            55 => {
                // Min saturated and unsaturated hemoglobin
                fields.push(record_message_total_hemoglobin_conc_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "g/dL",
                    value,
                )?);
            }
            56 => {
                // Max saturated and unsaturated hemoglobin
                fields.push(record_message_total_hemoglobin_conc_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "g/dL",
                    value,
                )?);
            }
            57 => {
                // Percentage of hemoglobin saturated with oxygen
                fields.push(record_message_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            58 => {
                // Min percentage of hemoglobin saturated with oxygen
                fields.push(record_message_saturated_hemoglobin_percent_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            59 => {
                // Max percentage of hemoglobin saturated with oxygen
                fields.push(record_message_saturated_hemoglobin_percent_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            62 => {
                fields.push(record_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            67 => {
                // Left platform center offset
                fields.push(record_message_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            68 => {
                // Right platform center offset
                fields.push(record_message_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            69 => {
                // Left power phase angles. Data value indexes defined by power_phase_type.
                fields.push(record_message_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            70 => {
                // Left power phase peak angles. Data value indexes defined by power_phase_type.
                fields.push(record_message_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            71 => {
                // Right power phase angles. Data value indexes defined by power_phase_type.
                fields.push(record_message_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            72 => {
                // Right power phase peak angles. Data value indexes defined by power_phase_type.
                fields.push(record_message_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            73 => {
                fields.push(record_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            78 => {
                fields.push(record_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            81 => {
                // lev battery state of charge
                fields.push(record_message_battery_soc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            82 => {
                // lev motor power
                fields.push(record_message_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            83 => {
                fields.push(record_message_vertical_ratio_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            84 => {
                fields.push(record_message_stance_time_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            85 => {
                fields.push(record_message_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            91 => {
                // Includes atmospheric pressure
                fields.push(record_message_absolute_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "Pa",
                    value,
                )?);
            }
            92 => {
                // 0 if above water
                fields.push(record_message_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            93 => {
                // 0 if above water
                fields.push(record_message_next_stop_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            94 => {
                fields.push(record_message_next_stop_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            95 => {
                fields.push(record_message_time_to_surface_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            96 => {
                fields.push(record_message_ndl_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            97 => {
                fields.push(record_message_cns_load_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            98 => {
                fields.push(record_message_n2_load_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            114 => {
                // The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
                fields.push(record_message_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            115 => {
                // The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
                fields.push(record_message_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            117 => {
                fields.push(record_message_ebike_travel_range_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "km",
                    value,
                )?);
            }
            118 => {
                fields.push(record_message_ebike_battery_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            119 => {
                fields.push(record_message_ebike_assist_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "depends on sensor",
                    value,
                )?);
            }
            120 => {
                fields.push(record_message_ebike_assist_level_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            139 => {
                fields.push(record_message_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            253 => {
                fields.push(record_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn record_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_compressed_speed_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "compressed_speed_distance",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_resistance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "resistance",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_time_from_course_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "time_from_course",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cycle_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "cycle_length",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13, value)?
    } else {
        value
    };
    data_field_with_info(
        13,
        "temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_speed_1s_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17, value)?
    } else {
        value
    };
    data_field_with_info(
        17,
        "speed_1s",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18, value)?
    } else {
        value
    };
    data_field_with_info(
        18,
        "cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19, value)?
    } else {
        value
    };
    data_field_with_info(
        19,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_compressed_accumulated_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28, value)?
    } else {
        value
    };
    data_field_with_info(
        28,
        "compressed_accumulated_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_accumulated_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29, value)?
    } else {
        value
    };
    data_field_with_info(
        29,
        "accumulated_power",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30, value)?
    } else {
        value
    };
    data_field_with_info(
        30,
        "left_right_balance",
        FieldDataType::LeftRightBalance,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31, value)?
    } else {
        value
    };
    data_field_with_info(
        31,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32, value)?
    } else {
        value
    };
    data_field_with_info(
        32,
        "vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33, value)?
    } else {
        value
    };
    data_field_with_info(
        33,
        "calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_vertical_oscillation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39, value)?
    } else {
        value
    };
    data_field_with_info(
        39,
        "vertical_oscillation",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stance_time_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40, value)?
    } else {
        value
    };
    data_field_with_info(
        40,
        "stance_time_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stance_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41, value)?
    } else {
        value
    };
    data_field_with_info(
        41,
        "stance_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_activity_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42, value)?
    } else {
        value
    };
    data_field_with_info(
        42,
        "activity_type",
        FieldDataType::ActivityType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43, value)?
    } else {
        value
    };
    data_field_with_info(
        43,
        "left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44, value)?
    } else {
        value
    };
    data_field_with_info(
        44,
        "right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45, value)?
    } else {
        value
    };
    data_field_with_info(
        45,
        "left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46, value)?
    } else {
        value
    };
    data_field_with_info(
        46,
        "right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47, value)?
    } else {
        value
    };
    data_field_with_info(
        47,
        "combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_time128_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48, value)?
    } else {
        value
    };
    data_field_with_info(
        48,
        "time128",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stroke_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49, value)?
    } else {
        value
    };
    data_field_with_info(
        49,
        "stroke_type",
        FieldDataType::StrokeType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50, value)?
    } else {
        value
    };
    data_field_with_info(
        50,
        "zone",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ball_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51, value)?
    } else {
        value
    };
    data_field_with_info(
        51,
        "ball_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cadence256_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52, value)?
    } else {
        value
    };
    data_field_with_info(
        52,
        "cadence256",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53, value)?
    } else {
        value
    };
    data_field_with_info(
        53,
        "fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54, value)?
    } else {
        value
    };
    data_field_with_info(
        54,
        "total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_hemoglobin_conc_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55, value)?
    } else {
        value
    };
    data_field_with_info(
        55,
        "total_hemoglobin_conc_min",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_hemoglobin_conc_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56, value)?
    } else {
        value
    };
    data_field_with_info(
        56,
        "total_hemoglobin_conc_max",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57, value)?
    } else {
        value
    };
    data_field_with_info(
        57,
        "saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_saturated_hemoglobin_percent_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58, value)?
    } else {
        value
    };
    data_field_with_info(
        58,
        "saturated_hemoglobin_percent_min",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_saturated_hemoglobin_percent_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59, value)?
    } else {
        value
    };
    data_field_with_info(
        59,
        "saturated_hemoglobin_percent_max",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62, value)?
    } else {
        value
    };
    data_field_with_info(
        62,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 67, value)?
    } else {
        value
    };
    data_field_with_info(
        67,
        "left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 68, value)?
    } else {
        value
    };
    data_field_with_info(
        68,
        "right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 69, value)?
    } else {
        value
    };
    data_field_with_info(
        69,
        "left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 70, value)?
    } else {
        value
    };
    data_field_with_info(
        70,
        "left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71, value)?
    } else {
        value
    };
    data_field_with_info(
        71,
        "right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 72, value)?
    } else {
        value
    };
    data_field_with_info(
        72,
        "right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_enhanced_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 73, value)?
    } else {
        value
    };
    data_field_with_info(
        73,
        "enhanced_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_enhanced_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 78, value)?
    } else {
        value
    };
    data_field_with_info(
        78,
        "enhanced_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_battery_soc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 81, value)?
    } else {
        value
    };
    data_field_with_info(
        81,
        "battery_soc",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82, value)?
    } else {
        value
    };
    data_field_with_info(
        82,
        "motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_vertical_ratio_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83, value)?
    } else {
        value
    };
    data_field_with_info(
        83,
        "vertical_ratio",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stance_time_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84, value)?
    } else {
        value
    };
    data_field_with_info(
        84,
        "stance_time_balance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85, value)?
    } else {
        value
    };
    data_field_with_info(
        85,
        "step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_absolute_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 91, value)?
    } else {
        value
    };
    data_field_with_info(
        91,
        "absolute_pressure",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 92, value)?
    } else {
        value
    };
    data_field_with_info(
        92,
        "depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_next_stop_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 93, value)?
    } else {
        value
    };
    data_field_with_info(
        93,
        "next_stop_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_next_stop_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94, value)?
    } else {
        value
    };
    data_field_with_info(
        94,
        "next_stop_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_time_to_surface_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95, value)?
    } else {
        value
    };
    data_field_with_info(
        95,
        "time_to_surface",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ndl_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 96, value)?
    } else {
        value
    };
    data_field_with_info(
        96,
        "ndl_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cns_load_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 97, value)?
    } else {
        value
    };
    data_field_with_info(
        97,
        "cns_load",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_n2_load_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 98, value)?
    } else {
        value
    };
    data_field_with_info(
        98,
        "n2_load",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 114, value)?
    } else {
        value
    };
    data_field_with_info(
        114,
        "grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 115, value)?
    } else {
        value
    };
    data_field_with_info(
        115,
        "flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_travel_range_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 117, value)?
    } else {
        value
    };
    data_field_with_info(
        117,
        "ebike_travel_range",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_battery_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 118, value)?
    } else {
        value
    };
    data_field_with_info(
        118,
        "ebike_battery_level",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_assist_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 119, value)?
    } else {
        value
    };
    data_field_with_info(
        119,
        "ebike_assist_mode",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_assist_level_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 120, value)?
    } else {
        value
    };
    data_field_with_info(
        120,
        "ebike_assist_level_percent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 139, value)?
    } else {
        value
    };
    data_field_with_info(
        139,
        "core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(event_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(event_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(event_message_data16_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), data) = extract_component(&input, 0usize, 16);
                data_map.insert(3, data.clone());
                if Event::Timer.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_timer_trigger_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        data,
                    )?);
                } else if Event::CoursePoint.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_course_point_index_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        data,
                    )?);
                } else if Event::Battery.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_battery_level_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "V",
                        data,
                    )?);
                } else if Event::VirtualPartnerPace.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_virtual_partner_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        data,
                    )?);
                } else if Event::HrHighAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "bpm",
                        data,
                    )?);
                } else if Event::HrLowAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "bpm",
                        data,
                    )?);
                } else if Event::SpeedHighAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        data,
                    )?);
                } else if Event::SpeedLowAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        data,
                    )?);
                } else if Event::CadHighAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "rpm",
                        data,
                    )?);
                } else if Event::CadLowAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "rpm",
                        data,
                    )?);
                } else if Event::PowerHighAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "watts",
                        data,
                    )?);
                } else if Event::PowerLowAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "watts",
                        data,
                    )?);
                } else if Event::TimeDurationAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_time_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "s",
                        data,
                    )?);
                } else if Event::DistanceDurationAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_distance_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100.000000,
                        0.000000,
                        "m",
                        data,
                    )?);
                } else if Event::CalorieDurationAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_calorie_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "calories",
                        data,
                    )?);
                } else if Event::FitnessEquipment.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_fitness_equipment_state_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        data,
                    )?);
                } else if Event::SportPoint.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_sport_point_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        data,
                    )?);
                } else if Event::FrontGearChange.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        data,
                    )?);
                } else if Event::RearGearChange.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        data,
                    )?);
                } else if Event::RiderPositionChange.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_rider_position_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        data,
                    )?);
                } else if Event::CommTimeout.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_comm_timeout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        data,
                    )?);
                } else if Event::RadarThreatAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_radar_threat_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        data,
                    )?);
                } else {
                    fields.push(event_message_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        data,
                    )?);
                }
            }
            3 => {
                if Event::Timer.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_timer_trigger_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Event::CoursePoint.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_course_point_index_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Event::Battery.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_battery_level_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "V",
                        value,
                    )?);
                } else if Event::VirtualPartnerPace.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_virtual_partner_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        value,
                    )?);
                } else if Event::HrHighAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "bpm",
                        value,
                    )?);
                } else if Event::HrLowAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "bpm",
                        value,
                    )?);
                } else if Event::SpeedHighAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        value,
                    )?);
                } else if Event::SpeedLowAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        value,
                    )?);
                } else if Event::CadHighAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "rpm",
                        value,
                    )?);
                } else if Event::CadLowAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "rpm",
                        value,
                    )?);
                } else if Event::PowerHighAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "watts",
                        value,
                    )?);
                } else if Event::PowerLowAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "watts",
                        value,
                    )?);
                } else if Event::TimeDurationAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_time_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "s",
                        value,
                    )?);
                } else if Event::DistanceDurationAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_distance_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100.000000,
                        0.000000,
                        "m",
                        value,
                    )?);
                } else if Event::CalorieDurationAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_calorie_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "calories",
                        value,
                    )?);
                } else if Event::FitnessEquipment.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_fitness_equipment_state_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Event::SportPoint.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_sport_point_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Event::FrontGearChange.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Event::RearGearChange.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Event::RiderPositionChange.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_rider_position_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Event::CommTimeout.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_comm_timeout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Event::RadarThreatAlert.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_radar_threat_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(event_message_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            4 => {
                fields.push(event_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                // Do not populate directly. Autogenerated by decoder for sport_point subfield components
                fields.push(event_message_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                // Do not populate directly. Autogenerated by decoder for sport_point subfield components
                fields.push(event_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            9 => {
                // Do not populate directly. Autogenerated by decoder for gear_change subfield components. Front gear number. 1 is innermost.
                fields.push(event_message_front_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            10 => {
                // Do not populate directly. Autogenerated by decoder for gear_change subfield components. Number of front teeth.
                fields.push(event_message_front_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                // Do not populate directly. Autogenerated by decoder for gear_change subfield components. Rear gear number. 1 is innermost.
                fields.push(event_message_rear_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            12 => {
                // Do not populate directly. Autogenerated by decoder for gear_change subfield components. Number of rear teeth.
                fields.push(event_message_rear_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            13 => {
                fields.push(event_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            21 => {
                // Do not populate directly. Autogenerated by decoder for threat_alert subfield components.
                fields.push(event_message_radar_threat_level_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            22 => {
                // Do not populate directly. Autogenerated by decoder for threat_alert subfield components.
                fields.push(event_message_radar_threat_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            23 => {
                // Do not populate directly. Autogenerated by decoder for radar_threat_alert subfield components
                fields.push(event_message_radar_threat_avg_approach_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            24 => {
                // Do not populate directly. Autogenerated by decoder for radar_threat_alert subfield components
                fields.push(event_message_radar_threat_max_approach_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            253 => {
                fields.push(event_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn event_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_data16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "data16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "data",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_timer_trigger_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "timer_trigger"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::TimerTrigger,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_course_point_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "course_point_index"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_battery_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "battery_level"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_virtual_partner_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "virtual_partner_speed"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_hr_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "hr_high_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_hr_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "hr_low_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_speed_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "speed_high_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_speed_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "speed_low_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_cad_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "cad_high_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_cad_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "cad_low_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_power_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "power_high_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_power_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "power_low_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_time_duration_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "time_duration_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_distance_duration_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "distance_duration_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_calorie_duration_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "calorie_duration_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_fitness_equipment_state_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "fitness_equipment_state"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::FitnessEquipmentState,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_sport_point_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "sport_point"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_gear_change_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "gear_change_data"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_rider_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "rider_position"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::RiderPositionType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_comm_timeout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "comm_timeout"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::CommTimeoutType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "radar_threat_alert"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_front_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "front_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_front_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "front_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_rear_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "rear_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_rear_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "rear_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13, value)?
    } else {
        value
    };
    data_field_with_info(
        13,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_level_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    data_field_with_info(
        21,
        "radar_threat_level_max",
        FieldDataType::RadarThreatLevelType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    data_field_with_info(
        22,
        "radar_threat_count",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_avg_approach_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23, value)?
    } else {
        value
    };
    data_field_with_info(
        23,
        "radar_threat_avg_approach_speed",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_max_approach_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24, value)?
    } else {
        value
    };
    data_field_with_info(
        24,
        "radar_threat_max_approach_speed",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(device_info_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                if SourceType::Antplus.as_i64()
                    == data_map
                        .get(&25)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_antplus_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if SourceType::Ant.as_i64()
                    == data_map
                        .get(&25)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_ant_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(device_info_message_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            2 => {
                fields.push(device_info_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(device_info_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&2)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&2)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&2)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&2)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&2)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(device_info_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            5 => {
                fields.push(device_info_message_software_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(device_info_message_hardware_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                // Reset by new battery or charge.
                fields.push(device_info_message_cum_operating_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            10 => {
                fields.push(device_info_message_battery_voltage_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256.000000,
                    0.000000,
                    "V",
                    value,
                )?);
            }
            11 => {
                fields.push(device_info_message_battery_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            18 => {
                // Indicates the location of the sensor
                fields.push(device_info_message_sensor_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            19 => {
                // Used to describe the sensor or location
                fields.push(device_info_message_descriptor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            20 => {
                fields.push(device_info_message_ant_transmission_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            21 => {
                fields.push(device_info_message_ant_device_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            22 => {
                fields.push(device_info_message_ant_network_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            25 => {
                fields.push(device_info_message_source_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            27 => {
                // Optional free form string to indicate the devices name or model
                fields.push(device_info_message_product_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            32 => {
                fields.push(device_info_message_battery_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            253 => {
                fields.push(device_info_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn device_info_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "device_type",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_antplus_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "device_type"
    } else {
        "antplus_device_type"
    };
    data_field_with_info(
        1,
        name,
        FieldDataType::AntplusDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "device_type"
    } else {
        "ant_device_type"
    };
    data_field_with_info(
        1,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_software_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "software_version",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_hardware_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "hardware_version",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_cum_operating_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "cum_operating_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_battery_voltage_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "battery_voltage",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_battery_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "battery_status",
        FieldDataType::BatteryStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_sensor_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18, value)?
    } else {
        value
    };
    data_field_with_info(
        18,
        "sensor_position",
        FieldDataType::BodyLocation,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_descriptor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19, value)?
    } else {
        value
    };
    data_field_with_info(
        19,
        "descriptor",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_transmission_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    data_field_with_info(
        20,
        "ant_transmission_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_device_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    data_field_with_info(
        21,
        "ant_device_number",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_network_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    data_field_with_info(
        22,
        "ant_network",
        FieldDataType::AntNetwork,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_source_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25, value)?
    } else {
        value
    };
    data_field_with_info(
        25,
        "source_type",
        FieldDataType::SourceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_product_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27, value)?
    } else {
        value
    };
    data_field_with_info(
        27,
        "product_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_battery_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32, value)?
    } else {
        value
    };
    data_field_with_info(
        32,
        "battery_level",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(device_aux_battery_info_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(device_aux_battery_info_message_battery_voltage_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256.000000,
                    0.000000,
                    "V",
                    value,
                )?);
            }
            2 => {
                fields.push(device_aux_battery_info_message_battery_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(device_aux_battery_info_message_battery_identifier_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                fields.push(device_aux_battery_info_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn device_aux_battery_info_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_battery_voltage_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "battery_voltage",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_battery_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "battery_status",
        FieldDataType::BatteryStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_battery_identifier_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "battery_identifier",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
/// Corresponds to file_id of workout or course.
fn training_file_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(training_file_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(training_file_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(training_file_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            3 => {
                fields.push(training_file_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(training_file_message_time_created_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                fields.push(training_file_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn training_file_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "type",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        2,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        2,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_time_created_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "time_created",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Current or forecast
                fields.push(weather_conditions_message_weather_report_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(weather_conditions_message_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            2 => {
                // Corresponds to GSC Response weatherIcon field
                fields.push(weather_conditions_message_condition_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(weather_conditions_message_wind_direction_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            4 => {
                fields.push(weather_conditions_message_wind_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            5 => {
                // range 0-100
                fields.push(weather_conditions_message_precipitation_probability_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                // Heat Index if GCS heatIdx above or equal to 90F or wind chill if GCS windChill below or equal to 32F
                fields.push(weather_conditions_message_temperature_feels_like_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            7 => {
                fields.push(weather_conditions_message_relative_humidity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                // string corresponding to GCS response location string
                fields.push(weather_conditions_message_location_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            9 => {
                fields.push(weather_conditions_message_observed_at_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            10 => {
                fields.push(weather_conditions_message_observed_location_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            11 => {
                fields.push(weather_conditions_message_observed_location_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            12 => {
                fields.push(weather_conditions_message_day_of_week_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            13 => {
                fields.push(weather_conditions_message_high_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            14 => {
                fields.push(weather_conditions_message_low_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            253 => {
                // time of update for current conditions, else forecast time
                fields.push(weather_conditions_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn weather_conditions_message_weather_report_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "weather_report",
        FieldDataType::WeatherReport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_condition_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "condition",
        FieldDataType::WeatherStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_wind_direction_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "wind_direction",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_wind_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "wind_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_precipitation_probability_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "precipitation_probability",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_temperature_feels_like_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "temperature_feels_like",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_relative_humidity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "relative_humidity",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_location_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "location",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_observed_at_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "observed_at_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_observed_location_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "observed_location_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_observed_location_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "observed_location_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_day_of_week_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "day_of_week",
        FieldDataType::DayOfWeek,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_high_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13, value)?
    } else {
        value
    };
    data_field_with_info(
        13,
        "high_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_low_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14, value)?
    } else {
        value
    };
    data_field_with_info(
        14,
        "low_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Unique identifier from GCS report ID string, length is 12
                fields.push(weather_alert_message_report_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // Time alert was issued
                fields.push(weather_alert_message_issue_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                // Time alert expires
                fields.push(weather_alert_message_expire_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                // Warning, Watch, Advisory, Statement
                fields.push(weather_alert_message_severity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Tornado, Severe Thunderstorm, etc.
                fields.push(weather_alert_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                fields.push(weather_alert_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn weather_alert_message_report_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "report_id",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_issue_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "issue_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_expire_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "expire_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_severity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "severity",
        FieldDataType::WeatherSeverity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "type",
        FieldDataType::WeatherSevereType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Millisecond part of the timestamp.
                fields.push(gps_metadata_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            1 => {
                fields.push(gps_metadata_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            2 => {
                fields.push(gps_metadata_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            3 => {
                fields.push(gps_metadata_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            4 => {
                fields.push(gps_metadata_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            5 => {
                fields.push(gps_metadata_message_heading_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            6 => {
                // Used to correlate UTC to system time if the timestamp of the message is in system time. This UTC time is derived from the GPS data.
                fields.push(gps_metadata_message_utc_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            7 => {
                // velocity[0] is lon velocity. Velocity[1] is lat velocity. Velocity[2] is altitude velocity.
                fields.push(gps_metadata_message_velocity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            253 => {
                // Whole second part of the timestamp.
                fields.push(gps_metadata_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn gps_metadata_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_enhanced_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "enhanced_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_enhanced_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "enhanced_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_heading_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "heading",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_utc_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "utc_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_velocity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "velocity",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Millisecond part of the timestamp.
                fields.push(camera_event_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            1 => {
                fields.push(camera_event_message_camera_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(camera_event_message_camera_file_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(camera_event_message_camera_orientation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                // Whole second part of the timestamp.
                fields.push(camera_event_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn camera_event_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_camera_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "camera_event_type",
        FieldDataType::CameraEventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_camera_file_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "camera_file_uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_camera_orientation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "camera_orientation",
        FieldDataType::CameraOrientationType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Millisecond part of the timestamp.
                fields.push(gyroscope_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            1 => {
                // Each time in the array describes the time at which the gyro sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in gyro_x and gyro_y and gyro_z
                fields.push(gyroscope_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            2 => {
                // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
                fields.push(gyroscope_data_message_gyro_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            3 => {
                // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
                fields.push(gyroscope_data_message_gyro_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            4 => {
                // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
                fields.push(gyroscope_data_message_gyro_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            5 => {
                // Calibrated gyro reading
                fields.push(gyroscope_data_message_calibrated_gyro_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "deg/s",
                    value,
                )?);
            }
            6 => {
                // Calibrated gyro reading
                fields.push(gyroscope_data_message_calibrated_gyro_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "deg/s",
                    value,
                )?);
            }
            7 => {
                // Calibrated gyro reading
                fields.push(gyroscope_data_message_calibrated_gyro_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "deg/s",
                    value,
                )?);
            }
            253 => {
                // Whole second part of the timestamp
                fields.push(gyroscope_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn gyroscope_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_gyro_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "gyro_x",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_gyro_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "gyro_y",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_gyro_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "gyro_z",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_calibrated_gyro_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "calibrated_gyro_x",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_calibrated_gyro_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "calibrated_gyro_y",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_calibrated_gyro_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "calibrated_gyro_z",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Millisecond part of the timestamp.
                fields.push(accelerometer_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            1 => {
                // Each time in the array describes the time at which the accelerometer sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in accel_x and accel_y and accel_z
                fields.push(accelerometer_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            2 => {
                // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
                fields.push(accelerometer_data_message_accel_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            3 => {
                // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
                fields.push(accelerometer_data_message_accel_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            4 => {
                // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
                fields.push(accelerometer_data_message_accel_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            5 => {
                // Calibrated accel reading
                fields.push(accelerometer_data_message_calibrated_accel_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "g",
                    value,
                )?);
            }
            6 => {
                // Calibrated accel reading
                fields.push(accelerometer_data_message_calibrated_accel_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "g",
                    value,
                )?);
            }
            7 => {
                // Calibrated accel reading
                fields.push(accelerometer_data_message_calibrated_accel_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "g",
                    value,
                )?);
            }
            8 => {
                // Calibrated accel reading
                fields.push(
                    accelerometer_data_message_compressed_calibrated_accel_x_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "mG",
                        value,
                    )?,
                );
            }
            9 => {
                // Calibrated accel reading
                fields.push(
                    accelerometer_data_message_compressed_calibrated_accel_y_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "mG",
                        value,
                    )?,
                );
            }
            10 => {
                // Calibrated accel reading
                fields.push(
                    accelerometer_data_message_compressed_calibrated_accel_z_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "mG",
                        value,
                    )?,
                );
            }
            253 => {
                // Whole second part of the timestamp
                fields.push(accelerometer_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn accelerometer_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_accel_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "accel_x",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_accel_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "accel_y",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_accel_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "accel_z",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_calibrated_accel_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "calibrated_accel_x",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_calibrated_accel_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "calibrated_accel_y",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_calibrated_accel_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "calibrated_accel_z",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_compressed_calibrated_accel_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "compressed_calibrated_accel_x",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_compressed_calibrated_accel_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "compressed_calibrated_accel_y",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_compressed_calibrated_accel_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "compressed_calibrated_accel_z",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Millisecond part of the timestamp.
                fields.push(magnetometer_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            1 => {
                // Each time in the array describes the time at which the compass sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in cmps_x and cmps_y and cmps_z
                fields.push(magnetometer_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            2 => {
                // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
                fields.push(magnetometer_data_message_mag_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            3 => {
                // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
                fields.push(magnetometer_data_message_mag_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            4 => {
                // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
                fields.push(magnetometer_data_message_mag_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            5 => {
                // Calibrated Magnetometer reading
                fields.push(magnetometer_data_message_calibrated_mag_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "G",
                    value,
                )?);
            }
            6 => {
                // Calibrated Magnetometer reading
                fields.push(magnetometer_data_message_calibrated_mag_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "G",
                    value,
                )?);
            }
            7 => {
                // Calibrated Magnetometer reading
                fields.push(magnetometer_data_message_calibrated_mag_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "G",
                    value,
                )?);
            }
            253 => {
                // Whole second part of the timestamp
                fields.push(magnetometer_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn magnetometer_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_mag_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "mag_x",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_mag_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "mag_y",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_mag_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "mag_z",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_calibrated_mag_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "calibrated_mag_x",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_calibrated_mag_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "calibrated_mag_y",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_calibrated_mag_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "calibrated_mag_z",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn barometer_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Millisecond part of the timestamp.
                fields.push(barometer_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            1 => {
                // Each time in the array describes the time at which the barometer sample with the corrosponding index was taken. The samples may span across seconds. Array size must match the number of samples in baro_cal
                fields.push(barometer_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            2 => {
                // These are the raw ADC reading. The samples may span across seconds. A conversion will need to be done on this data once read.
                fields.push(barometer_data_message_baro_pres_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "Pa",
                    value,
                )?);
            }
            253 => {
                // Whole second part of the timestamp
                fields.push(barometer_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn barometer_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn barometer_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn barometer_data_message_baro_pres_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "baro_pres",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn barometer_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Indicates which sensor the calibration is for
                fields.push(three_d_sensor_calibration_message_sensor_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // Calibration factor used to convert from raw ADC value to degrees, g, etc.
                if SensorType::Accelerometer.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(three_d_sensor_calibration_message_accel_cal_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "g",
                        value,
                    )?);
                } else if SensorType::Gyroscope.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(three_d_sensor_calibration_message_gyro_cal_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "deg/s",
                        value,
                    )?);
                } else {
                    fields.push(three_d_sensor_calibration_message_calibration_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            2 => {
                // Calibration factor divisor
                fields.push(
                    three_d_sensor_calibration_message_calibration_divisor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "counts",
                        value,
                    )?,
                );
            }
            3 => {
                // Level shift value used to shift the ADC value back into range
                fields.push(three_d_sensor_calibration_message_level_shift_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Internal calibration factors, one for each: xy, yx, zx
                fields.push(three_d_sensor_calibration_message_offset_cal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                // 3 x 3 rotation matrix (row major)
                fields.push(three_d_sensor_calibration_message_orientation_matrix_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    65535.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                // Whole second part of the timestamp
                fields.push(three_d_sensor_calibration_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn three_d_sensor_calibration_message_sensor_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "sensor_type",
        FieldDataType::SensorType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_calibration_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "calibration_factor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_accel_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "calibration_factor"
    } else {
        "accel_cal_factor"
    };
    data_field_with_info(
        1,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_gyro_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "calibration_factor"
    } else {
        "gyro_cal_factor"
    };
    data_field_with_info(
        1,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_calibration_divisor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "calibration_divisor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_level_shift_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "level_shift",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_offset_cal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "offset_cal",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_orientation_matrix_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "orientation_matrix",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Indicates which sensor the calibration is for
                fields.push(one_d_sensor_calibration_message_sensor_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // Calibration factor used to convert from raw ADC value to degrees, g, etc.
                if SensorType::Barometer.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(one_d_sensor_calibration_message_baro_cal_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "Pa",
                        value,
                    )?);
                } else {
                    fields.push(one_d_sensor_calibration_message_calibration_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            2 => {
                // Calibration factor divisor
                fields.push(one_d_sensor_calibration_message_calibration_divisor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "counts",
                    value,
                )?);
            }
            3 => {
                // Level shift value used to shift the ADC value back into range
                fields.push(one_d_sensor_calibration_message_level_shift_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Internal Calibration factor
                fields.push(one_d_sensor_calibration_message_offset_cal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                // Whole second part of the timestamp
                fields.push(one_d_sensor_calibration_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn one_d_sensor_calibration_message_sensor_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "sensor_type",
        FieldDataType::SensorType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_calibration_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "calibration_factor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_baro_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "calibration_factor"
    } else {
        "baro_cal_factor"
    };
    data_field_with_info(
        1,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_calibration_divisor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "calibration_divisor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_level_shift_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "level_shift",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_offset_cal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "offset_cal",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_frame_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Millisecond part of the timestamp.
                fields.push(video_frame_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            1 => {
                // Number of the frame that the timestamp and timestamp_ms correlate to
                fields.push(video_frame_message_frame_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                // Whole second part of the timestamp
                fields.push(video_frame_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_frame_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_frame_message_frame_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "frame_number",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_frame_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Fractional part of timestamp, added to timestamp
                fields.push(obdii_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            1 => {
                // Offset of PID reading [i] from start_timestamp+start_timestamp_ms. Readings may span accross seconds.
                fields.push(obdii_data_message_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            2 => {
                // Parameter ID
                fields.push(obdii_data_message_pid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                // Raw parameter data
                fields.push(obdii_data_message_raw_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Optional, data size of PID[i]. If not specified refer to SAE J1979.
                fields.push(obdii_data_message_pid_data_size_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                // System time associated with sample expressed in ms, can be used instead of time_offset. There will be a system_time value for each raw_data element. For multibyte pids the system_time is repeated.
                fields.push(obdii_data_message_system_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                // Timestamp of first sample recorded in the message. Used with time_offset to generate time of each sample
                fields.push(obdii_data_message_start_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                // Fractional part of start_timestamp
                fields.push(obdii_data_message_start_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            253 => {
                // Timestamp message was output
                fields.push(obdii_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn obdii_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_pid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "pid",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_raw_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "raw_data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_pid_data_size_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "pid_data_size",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_system_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "system_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_start_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "start_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_start_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "start_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn nmea_sentence_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Fractional part of timestamp, added to timestamp
                fields.push(nmea_sentence_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            1 => {
                // NMEA sentence
                fields.push(nmea_sentence_message_sentence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                // Timestamp message was output
                fields.push(nmea_sentence_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn nmea_sentence_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn nmea_sentence_message_sentence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "sentence",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn nmea_sentence_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Fractional part of timestamp, added to timestamp
                fields.push(aviation_attitude_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            1 => {
                // System time associated with sample expressed in ms.
                fields.push(aviation_attitude_message_system_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            2 => {
                // Range -PI/2 to +PI/2
                fields.push(aviation_attitude_message_pitch_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10430.380000,
                    0.000000,
                    "radians",
                    value,
                )?);
            }
            3 => {
                // Range -PI to +PI
                fields.push(aviation_attitude_message_roll_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10430.380000,
                    0.000000,
                    "radians",
                    value,
                )?);
            }
            4 => {
                // Range -78.4 to +78.4 (-8 Gs to 8 Gs)
                fields.push(aviation_attitude_message_accel_lateral_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m/s^2",
                    value,
                )?);
            }
            5 => {
                // Range -78.4 to +78.4 (-8 Gs to 8 Gs)
                fields.push(aviation_attitude_message_accel_normal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m/s^2",
                    value,
                )?);
            }
            6 => {
                // Range -8.727 to +8.727 (-500 degs/sec to +500 degs/sec)
                fields.push(aviation_attitude_message_turn_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1024.000000,
                    0.000000,
                    "radians/second",
                    value,
                )?);
            }
            7 => {
                fields.push(aviation_attitude_message_stage_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                // The percent complete of the current attitude stage. Set to 0 for attitude stages 0, 1 and 2 and to 100 for attitude stage 3 by AHRS modules that do not support it. Range - 100
                fields.push(aviation_attitude_message_attitude_stage_complete_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            9 => {
                // Track Angle/Heading Range 0 - 2pi
                fields.push(aviation_attitude_message_track_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10430.380000,
                    0.000000,
                    "radians",
                    value,
                )?);
            }
            10 => {
                fields.push(aviation_attitude_message_validity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                // Timestamp message was output
                fields.push(aviation_attitude_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn aviation_attitude_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_system_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "system_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_pitch_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "pitch",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_roll_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "roll",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_accel_lateral_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "accel_lateral",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_accel_normal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "accel_normal",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_turn_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "turn_rate",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_stage_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "stage",
        FieldDataType::AttitudeStage,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_attitude_stage_complete_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "attitude_stage_complete",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_track_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "track",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_validity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "validity",
        FieldDataType::AttitudeValidity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(video_message_url_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(video_message_hosting_provider_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                // Playback time of video
                fields.push(video_message_duration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_message_url_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "url",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_message_hosting_provider_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "hosting_provider",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_message_duration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "duration",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_title_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Total number of title parts
                fields.push(video_title_message_message_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(video_title_message_text_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                // Long titles will be split into multiple parts
                fields.push(video_title_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_title_message_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "message_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_title_message_text_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "text",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_title_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_description_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Total number of description parts
                fields.push(video_description_message_message_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(video_description_message_text_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                // Long descriptions will be split into multiple parts
                fields.push(video_description_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_description_message_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "message_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_description_message_text_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "text",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_description_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(video_clip_message_clip_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(video_clip_message_start_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(video_clip_message_start_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(video_clip_message_end_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(video_clip_message_end_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                // Start of clip in video time
                fields.push(video_clip_message_clip_start_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            7 => {
                // End of clip in video time
                fields.push(video_clip_message_clip_end_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "ms",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_clip_message_clip_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "clip_number",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_start_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "start_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_start_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "start_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_end_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "end_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_end_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "end_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_clip_start_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "clip_start",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_clip_end_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "clip_end",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(set_message_duration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            3 => {
                // # of repitions of the movement
                fields.push(set_message_repetitions_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Amount of weight applied for the set
                fields.push(set_message_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    16.000000,
                    0.000000,
                    "kg",
                    value,
                )?);
            }
            5 => {
                fields.push(set_message_set_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                // Start time of the set
                fields.push(set_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                fields.push(set_message_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                // Based on the associated category, see [category]_exercise_names
                fields.push(set_message_category_subtype_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            9 => {
                fields.push(set_message_weight_display_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            10 => {
                fields.push(set_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                fields.push(set_message_wkt_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                // Timestamp of the set
                fields.push(set_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn set_message_duration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "duration",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_repetitions_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "repetitions",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_set_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "set_type",
        FieldDataType::SetType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "category",
        FieldDataType::ExerciseCategory,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_category_subtype_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "category_subtype",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_weight_display_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "weight_display_unit",
        FieldDataType::FitBaseUnit,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_wkt_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "wkt_step_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(jump_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            1 => {
                fields.push(jump_message_height_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            2 => {
                fields.push(jump_message_rotations_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(jump_message_hang_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            4 => {
                // A score for a jump calculated based on hang time, rotations, and distance.
                fields.push(jump_message_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(jump_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            6 => {
                fields.push(jump_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            7 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(jump_message_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(8, enhanced_speed.clone());
                fields.push(jump_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    enhanced_speed,
                )?);
            }
            8 => {
                fields.push(jump_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            253 => {
                fields.push(jump_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn jump_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "distance",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_height_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "height",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_rotations_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "rotations",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_hang_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "hang_time",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "score",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_enhanced_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "enhanced_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(climb_pro_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            1 => {
                fields.push(climb_pro_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            2 => {
                fields.push(climb_pro_message_climb_pro_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(climb_pro_message_climb_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(climb_pro_message_climb_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(climb_pro_message_current_dist_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            253 => {
                fields.push(climb_pro_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn climb_pro_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_climb_pro_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "climb_pro_event",
        FieldDataType::ClimbProEvent,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_climb_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "climb_number",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_climb_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "climb_category",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_current_dist_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "current_dist",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
/// Must be logged before developer field is used
fn field_description_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(field_description_message_developer_data_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(field_description_message_field_definition_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(field_description_message_fit_base_type_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(field_description_message_field_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(field_description_message_array_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(field_description_message_components_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(field_description_message_scale_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                fields.push(field_description_message_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                fields.push(field_description_message_units_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            9 => {
                fields.push(field_description_message_bits_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            10 => {
                fields.push(field_description_message_accumulate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            13 => {
                fields.push(field_description_message_fit_base_unit_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            14 => {
                fields.push(field_description_message_native_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            15 => {
                fields.push(field_description_message_native_field_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn field_description_message_developer_data_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "developer_data_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_field_definition_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "field_definition_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_fit_base_type_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "fit_base_type_id",
        FieldDataType::FitBaseType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_field_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "field_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_array_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "array",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_components_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "components",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_scale_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "scale",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "offset",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_units_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "units",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_bits_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "bits",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_accumulate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "accumulate",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_fit_base_unit_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13, value)?
    } else {
        value
    };
    data_field_with_info(
        13,
        "fit_base_unit_id",
        FieldDataType::FitBaseUnit,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_native_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14, value)?
    } else {
        value
    };
    data_field_with_info(
        14,
        "native_mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_native_field_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15, value)?
    } else {
        value
    };
    data_field_with_info(
        15,
        "native_field_num",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
/// Must be logged before field description
fn developer_data_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(developer_data_id_message_developer_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(developer_data_id_message_application_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(developer_data_id_message_manufacturer_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(developer_data_id_message_developer_data_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(developer_data_id_message_application_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn developer_data_id_message_developer_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "developer_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_application_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "application_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_manufacturer_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "manufacturer_id",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_developer_data_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "developer_data_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_application_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "application_version",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            4 => {
                fields.push(course_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(course_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(course_message_capabilities_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                fields.push(course_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn course_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_message_capabilities_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "capabilities",
        FieldDataType::CourseCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1 => {
                fields.push(course_point_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(course_point_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            3 => {
                fields.push(course_point_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            4 => {
                fields.push(course_point_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            5 => {
                fields.push(course_point_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(course_point_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                fields.push(course_point_message_favorite_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(course_point_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn course_point_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "type",
        FieldDataType::CoursePoint,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_favorite_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "favorite",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
/// Unique Identification data for a segment file
fn segment_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Friendly name assigned to segment
                fields.push(segment_id_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // UUID of the segment
                fields.push(segment_id_message_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                // Sport associated with the segment
                fields.push(segment_id_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                // Segment enabled for evaluation
                fields.push(segment_id_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Primary key of the user that created the segment
                fields.push(segment_id_message_user_profile_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                // ID of the device that created the segment
                fields.push(segment_id_message_device_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                // Index for the Leader Board entry selected as the default race participant
                fields.push(segment_id_message_default_race_leader_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                // Indicates if any segments should be deleted
                fields.push(segment_id_message_delete_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                // Indicates how the segment was selected to be sent to the device
                fields.push(segment_id_message_selection_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_id_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_user_profile_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "user_profile_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_device_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "device_id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_default_race_leader_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "default_race_leader",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_delete_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "delete_status",
        FieldDataType::SegmentDeleteStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_selection_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "selection_type",
        FieldDataType::SegmentSelectionType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
/// Unique Identification data for an individual segment leader within a segment file
fn segment_leaderboard_entry_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Friendly name assigned to leader
                fields.push(segment_leaderboard_entry_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // Leader classification
                fields.push(segment_leaderboard_entry_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                // Primary user ID of this leader
                fields.push(segment_leaderboard_entry_message_group_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                // ID of the activity associated with this leader time
                fields.push(segment_leaderboard_entry_message_activity_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Segment Time (includes pauses)
                fields.push(segment_leaderboard_entry_message_segment_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            5 => {
                // String version of the activity_id. 21 characters long, express in decimal
                fields.push(segment_leaderboard_entry_message_activity_id_string_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(segment_leaderboard_entry_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_leaderboard_entry_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "type",
        FieldDataType::SegmentLeaderboardType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_group_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "group_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_activity_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "activity_id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_segment_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "segment_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_activity_id_string_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "activity_id_string",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
/// Navigation and race evaluation point for a segment decribing a point along the segment path and time it took each segment leader to reach that point
fn segment_point_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1 => {
                fields.push(segment_point_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            2 => {
                fields.push(segment_point_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            3 => {
                // Accumulated distance along the segment at the described point
                fields.push(segment_point_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            4 => {
                // Accumulated altitude along the segment at the described point
                fields.push(segment_point_message_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            5 => {
                // Accumualted time each leader board member required to reach the described point. This value is zero for all leader board members at the starting point of the segment.
                fields.push(segment_point_message_leader_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            254 => {
                fields.push(segment_point_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_point_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_leader_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "leader_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(segment_lap_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(segment_lap_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(segment_lap_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(segment_lap_message_start_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            4 => {
                fields.push(segment_lap_message_start_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            5 => {
                fields.push(segment_lap_message_end_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            6 => {
                fields.push(segment_lap_message_end_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            7 => {
                // Time (includes pauses)
                fields.push(segment_lap_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            8 => {
                // Timer Time (excludes pauses)
                fields.push(segment_lap_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            9 => {
                fields.push(segment_lap_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            10 => {
                if Sport::Cycling.as_i64()
                    == data_map
                        .get(&23)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(segment_lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(segment_lap_message_total_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "cycles",
                        value,
                    )?);
                }
            }
            11 => {
                fields.push(segment_lap_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal",
                    value,
                )?);
            }
            12 => {
                // If New Leaf
                fields.push(segment_lap_message_total_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal",
                    value,
                )?);
            }
            13 => {
                fields.push(segment_lap_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            14 => {
                fields.push(segment_lap_message_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            15 => {
                fields.push(segment_lap_message_avg_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            16 => {
                fields.push(segment_lap_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            17 => {
                // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
                fields.push(segment_lap_message_avg_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            18 => {
                fields.push(segment_lap_message_max_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            19 => {
                // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
                fields.push(segment_lap_message_avg_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            20 => {
                fields.push(segment_lap_message_max_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            21 => {
                fields.push(segment_lap_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            22 => {
                fields.push(segment_lap_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            23 => {
                fields.push(segment_lap_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            24 => {
                fields.push(segment_lap_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            25 => {
                // North east corner latitude.
                fields.push(segment_lap_message_nec_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            26 => {
                // North east corner longitude.
                fields.push(segment_lap_message_nec_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            27 => {
                // South west corner latitude.
                fields.push(segment_lap_message_swc_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            28 => {
                // South west corner latitude.
                fields.push(segment_lap_message_swc_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "semicircles",
                    value,
                )?);
            }
            29 => {
                fields.push(segment_lap_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            30 => {
                fields.push(segment_lap_message_normalized_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            31 => {
                fields.push(segment_lap_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            32 => {
                fields.push(segment_lap_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            33 => {
                fields.push(segment_lap_message_total_work_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "J",
                    value,
                )?);
            }
            34 => {
                fields.push(segment_lap_message_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            35 => {
                fields.push(segment_lap_message_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            36 => {
                fields.push(segment_lap_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            37 => {
                fields.push(segment_lap_message_avg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            38 => {
                fields.push(segment_lap_message_avg_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            39 => {
                fields.push(segment_lap_message_avg_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            40 => {
                fields.push(segment_lap_message_max_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            41 => {
                fields.push(segment_lap_message_max_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            42 => {
                fields.push(segment_lap_message_avg_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            43 => {
                fields.push(segment_lap_message_max_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            44 => {
                fields.push(segment_lap_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            45 => {
                fields.push(segment_lap_message_avg_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            46 => {
                fields.push(segment_lap_message_avg_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            47 => {
                fields.push(segment_lap_message_max_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            48 => {
                fields.push(segment_lap_message_max_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            49 => {
                fields.push(segment_lap_message_time_in_hr_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            50 => {
                fields.push(segment_lap_message_time_in_speed_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            51 => {
                fields.push(segment_lap_message_time_in_cadence_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            52 => {
                fields.push(segment_lap_message_time_in_power_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            53 => {
                fields.push(segment_lap_message_repetition_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            54 => {
                fields.push(segment_lap_message_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5.000000,
                    500.000000,
                    "m",
                    value,
                )?);
            }
            55 => {
                fields.push(segment_lap_message_min_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            56 => {
                fields.push(segment_lap_message_active_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            57 => {
                fields.push(segment_lap_message_wkt_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            58 => {
                fields.push(segment_lap_message_sport_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            59 => {
                fields.push(segment_lap_message_avg_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            60 => {
                fields.push(segment_lap_message_avg_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            61 => {
                fields.push(segment_lap_message_avg_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            62 => {
                fields.push(segment_lap_message_avg_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            63 => {
                fields.push(segment_lap_message_avg_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            64 => {
                fields.push(segment_lap_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            65 => {
                fields.push(segment_lap_message_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            66 => {
                // fractional part of the avg_cadence
                fields.push(segment_lap_message_avg_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            67 => {
                // fractional part of the max_cadence
                fields.push(segment_lap_message_max_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            68 => {
                // fractional part of the total_cycles
                fields.push(segment_lap_message_total_fractional_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128.000000,
                    0.000000,
                    "cycles",
                    value,
                )?);
            }
            69 => {
                fields.push(segment_lap_message_front_gear_shift_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            70 => {
                fields.push(segment_lap_message_rear_gear_shift_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            71 => {
                // Total time spent in the standing position
                fields.push(segment_lap_message_time_standing_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            72 => {
                // Number of transitions to the standing state
                fields.push(segment_lap_message_stand_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            73 => {
                // Average left platform center offset
                fields.push(segment_lap_message_avg_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            74 => {
                // Average right platform center offset
                fields.push(segment_lap_message_avg_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mm",
                    value,
                )?);
            }
            75 => {
                // Average left power phase angles. Data value indexes defined by power_phase_type.
                fields.push(segment_lap_message_avg_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            76 => {
                // Average left power phase peak angles. Data value indexes defined by power_phase_type.
                fields.push(segment_lap_message_avg_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            77 => {
                // Average right power phase angles. Data value indexes defined by power_phase_type.
                fields.push(segment_lap_message_avg_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            78 => {
                // Average right power phase peak angles. Data value indexes defined by power_phase_type.
                fields.push(segment_lap_message_avg_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.711111,
                    0.000000,
                    "degrees",
                    value,
                )?);
            }
            79 => {
                // Average power by position. Data value indexes defined by rider_position_type.
                fields.push(segment_lap_message_avg_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            80 => {
                // Maximum power by position. Data value indexes defined by rider_position_type.
                fields.push(segment_lap_message_max_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "watts",
                    value,
                )?);
            }
            81 => {
                // Average cadence by position. Data value indexes defined by rider_position_type.
                fields.push(segment_lap_message_avg_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            82 => {
                // Maximum cadence by position. Data value indexes defined by rider_position_type.
                fields.push(segment_lap_message_max_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "rpm",
                    value,
                )?);
            }
            83 => {
                // Manufacturer that produced the segment
                fields.push(segment_lap_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            84 => {
                // The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
                fields.push(segment_lap_message_total_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kGrit",
                    value,
                )?);
            }
            85 => {
                // The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
                fields.push(segment_lap_message_total_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "Flow",
                    value,
                )?);
            }
            86 => {
                // The grit score estimates how challenging a route could be for a cyclist in terms of time spent going over sharp turns or large grade slopes.
                fields.push(segment_lap_message_avg_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kGrit",
                    value,
                )?);
            }
            87 => {
                // The flow score estimates how long distance wise a cyclist deaccelerates over intervals where deacceleration is unnecessary such as smooth turns or small grade angle intervals.
                fields.push(segment_lap_message_avg_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "Flow",
                    value,
                )?);
            }
            89 => {
                // fractional part of total_ascent
                fields.push(segment_lap_message_total_fractional_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            90 => {
                // fractional part of total_descent
                fields.push(segment_lap_message_total_fractional_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            253 => {
                // Lap end time.
                fields.push(segment_lap_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            254 => {
                fields.push(segment_lap_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_lap_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_start_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "start_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_start_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "start_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_end_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "end_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_end_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "end_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strokes"
    };
    data_field_with_info(
        10,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "total_fat_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13, value)?
    } else {
        value
    };
    data_field_with_info(
        13,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14, value)?
    } else {
        value
    };
    data_field_with_info(
        14,
        "max_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15, value)?
    } else {
        value
    };
    data_field_with_info(
        15,
        "avg_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16, value)?
    } else {
        value
    };
    data_field_with_info(
        16,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17, value)?
    } else {
        value
    };
    data_field_with_info(
        17,
        "avg_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18, value)?
    } else {
        value
    };
    data_field_with_info(
        18,
        "max_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19, value)?
    } else {
        value
    };
    data_field_with_info(
        19,
        "avg_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    data_field_with_info(
        20,
        "max_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    data_field_with_info(
        21,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    data_field_with_info(
        22,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23, value)?
    } else {
        value
    };
    data_field_with_info(
        23,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24, value)?
    } else {
        value
    };
    data_field_with_info(
        24,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_nec_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25, value)?
    } else {
        value
    };
    data_field_with_info(
        25,
        "nec_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_nec_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26, value)?
    } else {
        value
    };
    data_field_with_info(
        26,
        "nec_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_swc_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27, value)?
    } else {
        value
    };
    data_field_with_info(
        27,
        "swc_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_swc_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28, value)?
    } else {
        value
    };
    data_field_with_info(
        28,
        "swc_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29, value)?
    } else {
        value
    };
    data_field_with_info(
        29,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_normalized_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30, value)?
    } else {
        value
    };
    data_field_with_info(
        30,
        "normalized_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31, value)?
    } else {
        value
    };
    data_field_with_info(
        31,
        "left_right_balance",
        FieldDataType::LeftRightBalance100,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32, value)?
    } else {
        value
    };
    data_field_with_info(
        32,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_work_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33, value)?
    } else {
        value
    };
    data_field_with_info(
        33,
        "total_work",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34, value)?
    } else {
        value
    };
    data_field_with_info(
        34,
        "avg_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 35, value)?
    } else {
        value
    };
    data_field_with_info(
        35,
        "max_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 36, value)?
    } else {
        value
    };
    data_field_with_info(
        36,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37, value)?
    } else {
        value
    };
    data_field_with_info(
        37,
        "avg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 38, value)?
    } else {
        value
    };
    data_field_with_info(
        38,
        "avg_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39, value)?
    } else {
        value
    };
    data_field_with_info(
        39,
        "avg_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40, value)?
    } else {
        value
    };
    data_field_with_info(
        40,
        "max_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41, value)?
    } else {
        value
    };
    data_field_with_info(
        41,
        "max_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42, value)?
    } else {
        value
    };
    data_field_with_info(
        42,
        "avg_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43, value)?
    } else {
        value
    };
    data_field_with_info(
        43,
        "max_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44, value)?
    } else {
        value
    };
    data_field_with_info(
        44,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45, value)?
    } else {
        value
    };
    data_field_with_info(
        45,
        "avg_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46, value)?
    } else {
        value
    };
    data_field_with_info(
        46,
        "avg_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47, value)?
    } else {
        value
    };
    data_field_with_info(
        47,
        "max_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48, value)?
    } else {
        value
    };
    data_field_with_info(
        48,
        "max_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49, value)?
    } else {
        value
    };
    data_field_with_info(
        49,
        "time_in_hr_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50, value)?
    } else {
        value
    };
    data_field_with_info(
        50,
        "time_in_speed_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51, value)?
    } else {
        value
    };
    data_field_with_info(
        51,
        "time_in_cadence_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52, value)?
    } else {
        value
    };
    data_field_with_info(
        52,
        "time_in_power_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_repetition_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53, value)?
    } else {
        value
    };
    data_field_with_info(
        53,
        "repetition_num",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54, value)?
    } else {
        value
    };
    data_field_with_info(
        54,
        "min_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_min_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55, value)?
    } else {
        value
    };
    data_field_with_info(
        55,
        "min_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_active_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56, value)?
    } else {
        value
    };
    data_field_with_info(
        56,
        "active_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_wkt_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57, value)?
    } else {
        value
    };
    data_field_with_info(
        57,
        "wkt_step_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_sport_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58, value)?
    } else {
        value
    };
    data_field_with_info(
        58,
        "sport_event",
        FieldDataType::SportEvent,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59, value)?
    } else {
        value
    };
    data_field_with_info(
        59,
        "avg_left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 60, value)?
    } else {
        value
    };
    data_field_with_info(
        60,
        "avg_right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 61, value)?
    } else {
        value
    };
    data_field_with_info(
        61,
        "avg_left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62, value)?
    } else {
        value
    };
    data_field_with_info(
        62,
        "avg_right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 63, value)?
    } else {
        value
    };
    data_field_with_info(
        63,
        "avg_combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 64, value)?
    } else {
        value
    };
    data_field_with_info(
        64,
        "status",
        FieldDataType::SegmentLapStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 65, value)?
    } else {
        value
    };
    data_field_with_info(
        65,
        "uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 66, value)?
    } else {
        value
    };
    data_field_with_info(
        66,
        "avg_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 67, value)?
    } else {
        value
    };
    data_field_with_info(
        67,
        "max_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fractional_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 68, value)?
    } else {
        value
    };
    data_field_with_info(
        68,
        "total_fractional_cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_front_gear_shift_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 69, value)?
    } else {
        value
    };
    data_field_with_info(
        69,
        "front_gear_shift_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_rear_gear_shift_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 70, value)?
    } else {
        value
    };
    data_field_with_info(
        70,
        "rear_gear_shift_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_standing_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71, value)?
    } else {
        value
    };
    data_field_with_info(
        71,
        "time_standing",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_stand_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 72, value)?
    } else {
        value
    };
    data_field_with_info(
        72,
        "stand_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 73, value)?
    } else {
        value
    };
    data_field_with_info(
        73,
        "avg_left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 74, value)?
    } else {
        value
    };
    data_field_with_info(
        74,
        "avg_right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 75, value)?
    } else {
        value
    };
    data_field_with_info(
        75,
        "avg_left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 76, value)?
    } else {
        value
    };
    data_field_with_info(
        76,
        "avg_left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 77, value)?
    } else {
        value
    };
    data_field_with_info(
        77,
        "avg_right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 78, value)?
    } else {
        value
    };
    data_field_with_info(
        78,
        "avg_right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 79, value)?
    } else {
        value
    };
    data_field_with_info(
        79,
        "avg_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 80, value)?
    } else {
        value
    };
    data_field_with_info(
        80,
        "max_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 81, value)?
    } else {
        value
    };
    data_field_with_info(
        81,
        "avg_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82, value)?
    } else {
        value
    };
    data_field_with_info(
        82,
        "max_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83, value)?
    } else {
        value
    };
    data_field_with_info(
        83,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84, value)?
    } else {
        value
    };
    data_field_with_info(
        84,
        "total_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85, value)?
    } else {
        value
    };
    data_field_with_info(
        85,
        "total_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86, value)?
    } else {
        value
    };
    data_field_with_info(
        86,
        "avg_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 87, value)?
    } else {
        value
    };
    data_field_with_info(
        87,
        "avg_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fractional_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89, value)?
    } else {
        value
    };
    data_field_with_info(
        89,
        "total_fractional_ascent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fractional_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 90, value)?
    } else {
        value
    };
    data_field_with_info(
        90,
        "total_fractional_descent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
/// Summary of the unique segment and leaderboard information associated with a segment file. This message is used to compile a segment list file describing all segment files on a device. The segment list file is used when refreshing the contents of a segment file with the latest available leaderboard information.
fn segment_file_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1 => {
                // UUID of the segment file
                fields.push(segment_file_message_file_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                // Enabled state of the segment file
                fields.push(segment_file_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Primary key of the user that created the segment file
                fields.push(segment_file_message_user_profile_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                // Leader type of each leader in the segment file
                fields.push(segment_file_message_leader_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                // Group primary key of each leader in the segment file
                fields.push(segment_file_message_leader_group_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            9 => {
                // Activity ID of each leader in the segment file
                fields.push(segment_file_message_leader_activity_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            10 => {
                // String version of the activity ID of each leader in the segment file. 21 characters long for each ID, express in decimal
                fields.push(segment_file_message_leader_activity_id_string_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                // Index for the Leader Board entry selected as the default race participant
                fields.push(segment_file_message_default_race_leader_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(segment_file_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_file_message_file_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "file_uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_user_profile_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "user_profile_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "leader_type",
        FieldDataType::SegmentLeaderboardType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_group_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "leader_group_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_activity_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "leader_activity_id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_activity_id_string_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "leader_activity_id_string",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_default_race_leader_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "default_race_leader",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            4 => {
                fields.push(workout_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(workout_message_capabilities_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                // number of valid steps
                fields.push(workout_message_num_valid_steps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                fields.push(workout_message_wkt_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                fields.push(workout_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            14 => {
                fields.push(workout_message_pool_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            15 => {
                fields.push(workout_message_pool_length_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn workout_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_capabilities_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "capabilities",
        FieldDataType::WorkoutCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_num_valid_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "num_valid_steps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_wkt_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "wkt_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_pool_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14, value)?
    } else {
        value
    };
    data_field_with_info(
        14,
        "pool_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_pool_length_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15, value)?
    } else {
        value
    };
    data_field_with_info(
        15,
        "pool_length_unit",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(workout_session_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(workout_session_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(workout_session_message_num_valid_steps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(workout_session_message_first_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(workout_session_message_pool_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            5 => {
                fields.push(workout_session_message_pool_length_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(workout_session_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn workout_session_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_num_valid_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "num_valid_steps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_first_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "first_step_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_pool_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "pool_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_pool_length_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "pool_length_unit",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(workout_step_message_wkt_step_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(workout_step_message_duration_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                if WktStepDuration::Time.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_time_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "s",
                        value,
                    )?);
                } else if WktStepDuration::RepetitionTime.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_time_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "s",
                        value,
                    )?);
                } else if WktStepDuration::Distance.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_distance_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100.000000,
                        0.000000,
                        "m",
                        value,
                    )?);
                } else if WktStepDuration::HrLessThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::HrGreaterThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::Calories.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_calories_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "calories",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilStepsCmplt.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilTime.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilDistance.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilCalories.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrLessThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrGreaterThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerLessThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerGreaterThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::PowerLessThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepDuration::PowerGreaterThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepDuration::Reps.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_reps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_duration_value_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            3 => {
                fields.push(workout_step_message_target_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_speed_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_hr_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_cadence_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_power_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilStepsCmplt.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_steps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilTime.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_time_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "s",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilDistance.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_distance_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100.000000,
                        0.000000,
                        "m",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilCalories.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_calories_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "calories",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrLessThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrGreaterThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerLessThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerGreaterThan.as_i64()
                    == data_map
                        .get(&1)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepTarget::SwimStroke.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_stroke_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_target_value_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            5 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_speed_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_heart_rate_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_cadence_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "rpm",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_power_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or watts",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_custom_target_value_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            6 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_speed_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000.000000,
                        0.000000,
                        "m/s",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_heart_rate_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_cadence_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "rpm",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&3)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_power_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "% or watts",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_custom_target_value_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            7 => {
                fields.push(workout_step_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                fields.push(workout_step_message_notes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            9 => {
                fields.push(workout_step_message_equipment_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            10 => {
                fields.push(workout_step_message_exercise_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                fields.push(workout_step_message_exercise_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            12 => {
                fields.push(workout_step_message_exercise_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "kg",
                    value,
                )?);
            }
            13 => {
                fields.push(workout_step_message_weight_display_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            19 => {
                fields.push(workout_step_message_secondary_target_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            20 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_speed_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_hr_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_cadence_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_power_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::SwimStroke.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_stroke_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_secondary_target_value_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            21 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_speed_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1000.000000,
                            0.000000,
                            "m/s",
                            value,
                        )?,
                    );
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_heart_rate_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1.000000,
                            0.000000,
                            "% or bpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_cadence_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1.000000,
                            0.000000,
                            "rpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_power_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1.000000,
                            0.000000,
                            "% or watts",
                            value,
                        )?,
                    );
                } else {
                    fields.push(
                        workout_step_message_secondary_custom_target_value_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1.000000,
                            0.000000,
                            "",
                            value,
                        )?,
                    );
                }
            }
            22 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_speed_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1000.000000,
                            0.000000,
                            "m/s",
                            value,
                        )?,
                    );
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_heart_rate_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1.000000,
                            0.000000,
                            "% or bpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_cadence_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1.000000,
                            0.000000,
                            "rpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&19)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_power_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1.000000,
                            0.000000,
                            "% or watts",
                            value,
                        )?,
                    );
                } else {
                    fields.push(
                        workout_step_message_secondary_custom_target_value_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1.000000,
                            0.000000,
                            "",
                            value,
                        )?,
                    );
                }
            }
            254 => {
                fields.push(workout_step_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn workout_step_message_wkt_step_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "wkt_step_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "duration_type",
        FieldDataType::WktStepDuration,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "duration_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_time"
    };
    data_field_with_info(
        2,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_distance"
    };
    data_field_with_info(
        2,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_hr_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_hr"
    };
    data_field_with_info(
        2,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_calories"
    };
    data_field_with_info(
        2,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_step_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_step"
    };
    data_field_with_info(
        2,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_power"
    };
    data_field_with_info(
        2,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_reps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_reps"
    };
    data_field_with_info(
        2,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "target_type",
        FieldDataType::WktStepTarget,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "target_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_speed_zone"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_hr_zone"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_cadence_zone"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_power_zone"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_steps"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_time"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_distance"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_calories"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_hr_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_hr"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_power"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_stroke_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_stroke_type"
    };
    data_field_with_info(
        4,
        name,
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_value_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "custom_target_value_low",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_speed_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_speed_low"
    };
    data_field_with_info(
        5,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_heart_rate_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_heart_rate_low"
    };
    data_field_with_info(
        5,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_cadence_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_cadence_low"
    };
    data_field_with_info(
        5,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_power_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_power_low"
    };
    data_field_with_info(
        5,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_value_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "custom_target_value_high",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_speed_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_speed_high"
    };
    data_field_with_info(
        6,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_heart_rate_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_heart_rate_high"
    };
    data_field_with_info(
        6,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_cadence_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_cadence_high"
    };
    data_field_with_info(
        6,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_power_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_power_high"
    };
    data_field_with_info(
        6,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "intensity",
        FieldDataType::Intensity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_notes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "notes",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_equipment_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "equipment",
        FieldDataType::WorkoutEquipment,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_exercise_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "exercise_category",
        FieldDataType::ExerciseCategory,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_exercise_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "exercise_name",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_exercise_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "exercise_weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_weight_display_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13, value)?
    } else {
        value
    };
    data_field_with_info(
        13,
        "weight_display_unit",
        FieldDataType::FitBaseUnit,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19, value)?
    } else {
        value
    };
    data_field_with_info(
        19,
        "secondary_target_type",
        FieldDataType::WktStepTarget,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    data_field_with_info(
        20,
        "secondary_target_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_speed_zone"
    };
    data_field_with_info(
        20,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_hr_zone"
    };
    data_field_with_info(
        20,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_cadence_zone"
    };
    data_field_with_info(
        20,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_power_zone"
    };
    data_field_with_info(
        20,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_stroke_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_stroke_type"
    };
    data_field_with_info(
        20,
        name,
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_value_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    data_field_with_info(
        21,
        "secondary_custom_target_value_low",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_speed_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_speed_low"
    };
    data_field_with_info(
        21,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_heart_rate_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_heart_rate_low"
    };
    data_field_with_info(
        21,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_cadence_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_cadence_low"
    };
    data_field_with_info(
        21,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_power_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_power_low"
    };
    data_field_with_info(
        21,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_value_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    data_field_with_info(
        22,
        "secondary_custom_target_value_high",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_speed_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_speed_high"
    };
    data_field_with_info(
        22,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_heart_rate_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_heart_rate_high"
    };
    data_field_with_info(
        22,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_cadence_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_cadence_high"
    };
    data_field_with_info(
        22,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_power_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_power_high"
    };
    data_field_with_info(
        22,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exercise_title_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(exercise_title_message_exercise_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(exercise_title_message_exercise_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(exercise_title_message_wkt_step_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            254 => {
                fields.push(exercise_title_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exercise_title_message_exercise_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "exercise_category",
        FieldDataType::ExerciseCategory,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exercise_title_message_exercise_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "exercise_name",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exercise_title_message_wkt_step_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "wkt_step_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exercise_title_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Corresponds to file_id of scheduled workout / course.
                fields.push(schedule_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // Corresponds to file_id of scheduled workout / course.
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&0)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(schedule_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value,
                    )?);
                }
            }
            2 => {
                // Corresponds to file_id of scheduled workout / course.
                fields.push(schedule_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                // Corresponds to file_id of scheduled workout / course.
                fields.push(schedule_message_time_created_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // TRUE if this activity has been started
                fields.push(schedule_message_completed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(schedule_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(schedule_message_scheduled_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn schedule_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        1,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        1,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_time_created_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "time_created",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_completed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "completed",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "type",
        FieldDataType::Schedule,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_scheduled_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "scheduled_time",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Excludes pauses
                fields.push(totals_message_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            1 => {
                fields.push(totals_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            2 => {
                fields.push(totals_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal",
                    value,
                )?);
            }
            3 => {
                fields.push(totals_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Includes pauses
                fields.push(totals_message_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            5 => {
                fields.push(totals_message_sessions_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(totals_message_active_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            9 => {
                fields.push(totals_message_sport_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                fields.push(totals_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            254 => {
                fields.push(totals_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn totals_message_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "calories",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_sessions_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "sessions",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_active_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "active_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_sport_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "sport_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254, value)?
    } else {
        value
    };
    data_field_with_info(
        254,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(weight_scale_message_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "kg",
                    value,
                )?);
            }
            1 => {
                fields.push(weight_scale_message_percent_fat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            2 => {
                fields.push(weight_scale_message_percent_hydration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "%",
                    value,
                )?);
            }
            3 => {
                fields.push(weight_scale_message_visceral_fat_mass_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "kg",
                    value,
                )?);
            }
            4 => {
                fields.push(weight_scale_message_bone_mass_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "kg",
                    value,
                )?);
            }
            5 => {
                fields.push(weight_scale_message_muscle_mass_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "kg",
                    value,
                )?);
            }
            7 => {
                fields.push(weight_scale_message_basal_met_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    4.000000,
                    0.000000,
                    "kcal/day",
                    value,
                )?);
            }
            8 => {
                fields.push(weight_scale_message_physique_rating_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            9 => {
                // ~4kJ per kcal, 0.25 allows max 16384 kcal
                fields.push(weight_scale_message_active_met_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    4.000000,
                    0.000000,
                    "kcal/day",
                    value,
                )?);
            }
            10 => {
                fields.push(weight_scale_message_metabolic_age_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "years",
                    value,
                )?);
            }
            11 => {
                fields.push(weight_scale_message_visceral_fat_rating_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            12 => {
                // Associates this weight scale message to a user. This corresponds to the index of the user profile message in the weight scale file.
                fields.push(weight_scale_message_user_profile_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                fields.push(weight_scale_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn weight_scale_message_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "weight",
        FieldDataType::Weight,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_percent_fat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "percent_fat",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_percent_hydration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "percent_hydration",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_visceral_fat_mass_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "visceral_fat_mass",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_bone_mass_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "bone_mass",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_muscle_mass_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "muscle_mass",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_basal_met_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "basal_met",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_physique_rating_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "physique_rating",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_active_met_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "active_met",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_metabolic_age_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "metabolic_age",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_visceral_fat_rating_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "visceral_fat_rating",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_user_profile_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "user_profile_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(blood_pressure_message_systolic_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mmHg",
                    value,
                )?);
            }
            1 => {
                fields.push(blood_pressure_message_diastolic_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mmHg",
                    value,
                )?);
            }
            2 => {
                fields.push(blood_pressure_message_mean_arterial_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mmHg",
                    value,
                )?);
            }
            3 => {
                fields.push(blood_pressure_message_map_3_sample_mean_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mmHg",
                    value,
                )?);
            }
            4 => {
                fields.push(blood_pressure_message_map_morning_values_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mmHg",
                    value,
                )?);
            }
            5 => {
                fields.push(blood_pressure_message_map_evening_values_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "mmHg",
                    value,
                )?);
            }
            6 => {
                fields.push(blood_pressure_message_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            7 => {
                fields.push(blood_pressure_message_heart_rate_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                fields.push(blood_pressure_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            9 => {
                // Associates this blood pressure message to a user. This corresponds to the index of the user profile message in the blood pressure file.
                fields.push(blood_pressure_message_user_profile_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                fields.push(blood_pressure_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn blood_pressure_message_systolic_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "systolic_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_diastolic_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "diastolic_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_mean_arterial_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "mean_arterial_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_map_3_sample_mean_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "map_3_sample_mean",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_map_morning_values_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "map_morning_values",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_map_evening_values_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "map_evening_values",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_heart_rate_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "heart_rate_type",
        FieldDataType::HrType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "status",
        FieldDataType::BpStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_user_profile_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "user_profile_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Use to convert activity timestamps to local time if device does not support time zone and daylight savings time correction.
                fields.push(monitoring_info_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            1 => {
                fields.push(monitoring_info_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                // Indexed by activity_type
                fields.push(monitoring_info_message_cycles_to_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5000.000000,
                    0.000000,
                    "m/cycle",
                    value,
                )?);
            }
            4 => {
                // Indexed by activity_type
                fields.push(monitoring_info_message_cycles_to_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5000.000000,
                    0.000000,
                    "kcal/cycle",
                    value,
                )?);
            }
            5 => {
                fields.push(monitoring_info_message_resting_metabolic_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal / day",
                    value,
                )?);
            }
            253 => {
                fields.push(monitoring_info_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn monitoring_info_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_activity_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "activity_type",
        FieldDataType::ActivityType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_cycles_to_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "cycles_to_distance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_cycles_to_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "cycles_to_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_resting_metabolic_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "resting_metabolic_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Associates this data to device_info message. Not required for file with single device (sensor).
                fields.push(monitoring_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // Accumulated total calories. Maintained by MonitoringReader for each activity_type. See SDK documentation
                fields.push(monitoring_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal",
                    value,
                )?);
            }
            2 => {
                // Accumulated distance. Maintained by MonitoringReader for each activity_type. See SDK documentation.
                fields.push(monitoring_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            3 => {
                // Accumulated cycles. Maintained by MonitoringReader for each activity_type. See SDK documentation.
                if ActivityType::Walking.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_steps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "steps",
                        value,
                    )?);
                } else if ActivityType::Running.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_steps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "steps",
                        value,
                    )?);
                } else if ActivityType::Cycling.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        2.000000,
                        0.000000,
                        "strokes",
                        value,
                    )?);
                } else if ActivityType::Swimming.as_i64()
                    == data_map
                        .get(&5)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        2.000000,
                        0.000000,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(monitoring_message_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        2.000000,
                        0.000000,
                        "cycles",
                        value,
                    )?);
                }
            }
            4 => {
                fields.push(monitoring_message_active_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            5 => {
                fields.push(monitoring_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(monitoring_message_activity_subtype_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            7 => {
                fields.push(monitoring_message_activity_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                fields.push(monitoring_message_distance_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "100 * m",
                    value,
                )?);
            }
            9 => {
                fields.push(monitoring_message_cycles_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "2 * cycles (steps)",
                    value,
                )?);
            }
            10 => {
                fields.push(monitoring_message_active_time_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            11 => {
                // Must align to logging interval, for example, time must be 00:00:00 for daily log.
                fields.push(monitoring_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            12 => {
                // Avg temperature during the logging interval ended at timestamp
                fields.push(monitoring_message_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            14 => {
                // Min temperature during the logging interval ended at timestamp
                fields.push(monitoring_message_temperature_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            15 => {
                // Max temperature during the logging interval ended at timestamp
                fields.push(monitoring_message_temperature_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100.000000,
                    0.000000,
                    "C",
                    value,
                )?);
            }
            16 => {
                // Indexed using minute_activity_level enum
                fields.push(monitoring_message_activity_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "minutes",
                    value,
                )?);
            }
            19 => {
                fields.push(monitoring_message_active_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "kcal",
                    value,
                )?);
            }
            24 => {
                // Indicates single type / intensity for duration since last monitoring message.
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(monitoring_message_current_activity_type_intensity_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), activity_type) = extract_component(&input, 0usize, 5);
                let ((input, offset), intensity) = extract_component(input, offset, 3);
                data_map.insert(5, activity_type.clone());
                fields.push(monitoring_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    activity_type,
                )?);
                data_map.insert(28, intensity.clone());
                fields.push(monitoring_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    intensity,
                )?);
            }
            25 => {
                fields.push(monitoring_message_timestamp_min_8_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "min",
                    value,
                )?);
            }
            26 => {
                fields.push(monitoring_message_timestamp_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            27 => {
                fields.push(monitoring_message_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            28 => {
                fields.push(monitoring_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            29 => {
                fields.push(monitoring_message_duration_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "min",
                    value,
                )?);
            }
            30 => {
                fields.push(monitoring_message_duration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            31 => {
                fields.push(monitoring_message_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            32 => {
                fields.push(monitoring_message_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            33 => {
                fields.push(monitoring_message_moderate_activity_minutes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "minutes",
                    value,
                )?);
            }
            34 => {
                fields.push(monitoring_message_vigorous_activity_minutes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "minutes",
                    value,
                )?);
            }
            253 => {
                // Must align to logging interval, for example, time must be 00:00:00 for daily log.
                fields.push(monitoring_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn monitoring_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "cycles"
    } else {
        "steps"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "cycles"
    } else {
        "strokes"
    };
    data_field_with_info(
        3,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_active_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "active_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "activity_type",
        FieldDataType::ActivityType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_subtype_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "activity_subtype",
        FieldDataType::ActivitySubtype,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "activity_level",
        FieldDataType::ActivityLevel,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_distance_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "distance_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_cycles_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "cycles_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_active_time_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "active_time_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12, value)?
    } else {
        value
    };
    data_field_with_info(
        12,
        "temperature",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_temperature_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14, value)?
    } else {
        value
    };
    data_field_with_info(
        14,
        "temperature_min",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_temperature_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15, value)?
    } else {
        value
    };
    data_field_with_info(
        15,
        "temperature_max",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16, value)?
    } else {
        value
    };
    data_field_with_info(
        16,
        "activity_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_active_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19, value)?
    } else {
        value
    };
    data_field_with_info(
        19,
        "active_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_current_activity_type_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24, value)?
    } else {
        value
    };
    data_field_with_info(
        24,
        "current_activity_type_intensity",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_timestamp_min_8_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25, value)?
    } else {
        value
    };
    data_field_with_info(
        25,
        "timestamp_min_8",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_timestamp_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26, value)?
    } else {
        value
    };
    data_field_with_info(
        26,
        "timestamp_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27, value)?
    } else {
        value
    };
    data_field_with_info(
        27,
        "heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28, value)?
    } else {
        value
    };
    data_field_with_info(
        28,
        "intensity",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_duration_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29, value)?
    } else {
        value
    };
    data_field_with_info(
        29,
        "duration_min",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_duration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30, value)?
    } else {
        value
    };
    data_field_with_info(
        30,
        "duration",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31, value)?
    } else {
        value
    };
    data_field_with_info(
        31,
        "ascent",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32, value)?
    } else {
        value
    };
    data_field_with_info(
        32,
        "descent",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_moderate_activity_minutes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33, value)?
    } else {
        value
    };
    data_field_with_info(
        33,
        "moderate_activity_minutes",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_vigorous_activity_minutes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34, value)?
    } else {
        value
    };
    data_field_with_info(
        34,
        "vigorous_activity_minutes",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(hr_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            1 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(hr_message_time256_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        256.000000,
                        0.000000,
                        "s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), fractional_timestamp) = extract_component(&input, 0usize, 8);
                data_map.insert(0, fractional_timestamp.clone());
                fields.push(hr_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256.000000,
                    0.000000,
                    "s",
                    fractional_timestamp,
                )?);
            }
            6 => {
                fields.push(hr_message_filtered_bpm_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "bpm",
                    value,
                )?);
            }
            9 => {
                fields.push(hr_message_event_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1024.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            10 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(hr_message_event_timestamp_12_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), event_timestamp_1) = extract_component(&input, 0usize, 12);
                let ((input, offset), event_timestamp_2) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_3) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_4) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_5) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_6) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_7) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_8) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_9) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_10) = extract_component(input, offset, 12);
                let event_timestamp = Value::Array(vec![
                    event_timestamp_1,
                    event_timestamp_2,
                    event_timestamp_3,
                    event_timestamp_4,
                    event_timestamp_5,
                    event_timestamp_6,
                    event_timestamp_7,
                    event_timestamp_8,
                    event_timestamp_9,
                    event_timestamp_10,
                ]);
                data_map.insert(9, event_timestamp.clone());
                fields.push(hr_message_event_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    1024.000000,
                    0.000000,
                    "s",
                    event_timestamp,
                )?);
            }
            253 => {
                fields.push(hr_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hr_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_time256_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "time256",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_filtered_bpm_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "filtered_bpm",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_event_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "event_timestamp",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_event_timestamp_12_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "event_timestamp_12",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
/// Value from 1 to 100 calculated by FirstBeat
fn stress_level_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(stress_level_message_stress_level_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // Time stress score was calculated
                fields.push(stress_level_message_stress_level_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn stress_level_message_stress_level_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "stress_level_value",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn stress_level_message_stress_level_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "stress_level_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Deprecated. Use data field.
                fields.push(memo_glob_message_memo_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // Message Number of the parent message
                fields.push(memo_glob_message_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                // Index of mesg that this glob is associated with.
                fields.push(memo_glob_message_parent_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                // Field within the parent that this glob is associated with
                fields.push(memo_glob_message_field_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                // Block of utf8 bytes. Note, mutltibyte characters may be split across adjoining memo_glob messages.
                fields.push(memo_glob_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            250 => {
                // Sequence number of memo blocks
                fields.push(memo_glob_message_part_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn memo_glob_message_memo_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "memo",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_parent_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "parent_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_field_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "field_num",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "data",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_part_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 250, value)?
    } else {
        value
    };
    data_field_with_info(
        250,
        "part_index",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(ant_channel_id_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(ant_channel_id_message_device_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(ant_channel_id_message_device_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(ant_channel_id_message_transmission_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(ant_channel_id_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ant_channel_id_message_channel_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "channel_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "device_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_device_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "device_number",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_transmission_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "transmission_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(ant_rx_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            1 => {
                fields.push(ant_rx_message_mesg_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(ant_rx_message_mesg_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), channel_number) = extract_component(&input, 0usize, 8);
                let ((input, offset), data_1) = extract_component(input, offset, 8);
                let ((input, offset), data_2) = extract_component(input, offset, 8);
                let ((input, offset), data_3) = extract_component(input, offset, 8);
                let ((input, offset), data_4) = extract_component(input, offset, 8);
                let ((input, offset), data_5) = extract_component(input, offset, 8);
                let ((input, offset), data_6) = extract_component(input, offset, 8);
                let ((input, offset), data_7) = extract_component(input, offset, 8);
                let ((input, offset), data_8) = extract_component(input, offset, 8);
                data_map.insert(3, channel_number.clone());
                fields.push(ant_rx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    channel_number,
                )?);
                let data = Value::Array(vec![
                    data_1, data_2, data_3, data_4, data_5, data_6, data_7, data_8,
                ]);
                data_map.insert(4, data.clone());
                fields.push(ant_rx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    data,
                )?);
            }
            3 => {
                fields.push(ant_rx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(ant_rx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                fields.push(ant_rx_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ant_rx_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_mesg_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "mesg_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_mesg_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "mesg_data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_channel_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "channel_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(ant_tx_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            1 => {
                fields.push(ant_tx_message_mesg_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(ant_tx_message_mesg_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), channel_number) = extract_component(&input, 0usize, 8);
                let ((input, offset), data_1) = extract_component(input, offset, 8);
                let ((input, offset), data_2) = extract_component(input, offset, 8);
                let ((input, offset), data_3) = extract_component(input, offset, 8);
                let ((input, offset), data_4) = extract_component(input, offset, 8);
                let ((input, offset), data_5) = extract_component(input, offset, 8);
                let ((input, offset), data_6) = extract_component(input, offset, 8);
                let ((input, offset), data_7) = extract_component(input, offset, 8);
                let ((input, offset), data_8) = extract_component(input, offset, 8);
                data_map.insert(3, channel_number.clone());
                fields.push(ant_tx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    channel_number,
                )?);
                let data = Value::Array(vec![
                    data_1, data_2, data_3, data_4, data_5, data_6, data_7, data_8,
                ]);
                data_map.insert(4, data.clone());
                fields.push(ant_tx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    data,
                )?);
            }
            3 => {
                fields.push(ant_tx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(ant_tx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            253 => {
                fields.push(ant_tx_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ant_tx_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_mesg_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "mesg_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_mesg_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "mesg_data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_channel_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "channel_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_screen_configuration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(exd_screen_configuration_message_screen_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                // number of fields in screen
                fields.push(exd_screen_configuration_message_field_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                fields.push(exd_screen_configuration_message_layout_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(exd_screen_configuration_message_screen_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exd_screen_configuration_message_screen_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "screen_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_screen_configuration_message_field_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "field_count",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_screen_configuration_message_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "layout",
        FieldDataType::ExdLayout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_screen_configuration_message_screen_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "screen_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(exd_data_field_configuration_message_screen_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(exd_data_field_configuration_message_concept_field_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), field_id) = extract_component(&input, 0usize, 4);
                let ((input, offset), concept_count) = extract_component(input, offset, 4);
                data_map.insert(2, field_id.clone());
                fields.push(exd_data_field_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    field_id,
                )?);
                data_map.insert(3, concept_count.clone());
                fields.push(exd_data_field_configuration_message_concept_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    concept_count,
                )?);
            }
            2 => {
                fields.push(exd_data_field_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(exd_data_field_configuration_message_concept_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(exd_data_field_configuration_message_display_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(exd_data_field_configuration_message_title_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exd_data_field_configuration_message_screen_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "screen_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_concept_field_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "concept_field",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_field_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "field_id",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_concept_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "concept_count",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_display_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "display_type",
        FieldDataType::ExdDisplayType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_title_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "title",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(exd_data_concept_configuration_message_screen_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(exd_data_concept_configuration_message_concept_field_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1.000000,
                        0.000000,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), field_id) = extract_component(&input, 0usize, 4);
                let ((input, offset), concept_index) = extract_component(input, offset, 4);
                data_map.insert(2, field_id.clone());
                fields.push(exd_data_concept_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    field_id,
                )?);
                data_map.insert(3, concept_index.clone());
                fields.push(exd_data_concept_configuration_message_concept_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    concept_index,
                )?);
            }
            2 => {
                fields.push(exd_data_concept_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            3 => {
                fields.push(exd_data_concept_configuration_message_concept_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            4 => {
                fields.push(exd_data_concept_configuration_message_data_page_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            5 => {
                fields.push(exd_data_concept_configuration_message_concept_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            6 => {
                fields.push(exd_data_concept_configuration_message_scaling_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            8 => {
                fields.push(exd_data_concept_configuration_message_data_units_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            9 => {
                fields.push(exd_data_concept_configuration_message_qualifier_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            10 => {
                fields.push(exd_data_concept_configuration_message_descriptor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                fields.push(exd_data_concept_configuration_message_is_signed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exd_data_concept_configuration_message_screen_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "screen_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_concept_field_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "concept_field",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_field_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "field_id",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_concept_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "concept_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_data_page_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "data_page",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_concept_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "concept_key",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_scaling_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "scaling",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_data_units_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "data_units",
        FieldDataType::ExdDataUnits,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_qualifier_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "qualifier",
        FieldDataType::ExdQualifiers,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_descriptor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "descriptor",
        FieldDataType::ExdDescriptors,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_is_signed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "is_signed",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                fields.push(dive_summary_message_reference_mesg_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            1 => {
                fields.push(dive_summary_message_reference_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            2 => {
                // 0 if above water
                fields.push(dive_summary_message_avg_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            3 => {
                // 0 if above water
                fields.push(dive_summary_message_max_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m",
                    value,
                )?);
            }
            4 => {
                // Time since end of last dive
                fields.push(dive_summary_message_surface_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            5 => {
                fields.push(dive_summary_message_start_cns_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            6 => {
                fields.push(dive_summary_message_end_cns_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            7 => {
                fields.push(dive_summary_message_start_n2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            8 => {
                fields.push(dive_summary_message_end_n2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "percent",
                    value,
                )?);
            }
            9 => {
                fields.push(dive_summary_message_o2_toxicity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "OTUs",
                    value,
                )?);
            }
            10 => {
                fields.push(dive_summary_message_dive_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "",
                    value,
                )?);
            }
            11 => {
                fields.push(dive_summary_message_bottom_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            17 => {
                // Average ascent rate, not including descents or stops
                fields.push(dive_summary_message_avg_ascent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            22 => {
                // Average descent rate, not including ascents or stops
                fields.push(dive_summary_message_avg_descent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            23 => {
                // Maximum ascent rate
                fields.push(dive_summary_message_max_ascent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            24 => {
                // Maximum descent rate
                fields.push(dive_summary_message_max_descent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "m/s",
                    value,
                )?);
            }
            25 => {
                // Time spent neither ascending nor descending
                fields.push(dive_summary_message_hang_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            253 => {
                fields.push(dive_summary_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_summary_message_reference_mesg_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "reference_mesg",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_reference_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1, value)?
    } else {
        value
    };
    data_field_with_info(
        1,
        "reference_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2, value)?
    } else {
        value
    };
    data_field_with_info(
        2,
        "avg_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_max_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3, value)?
    } else {
        value
    };
    data_field_with_info(
        3,
        "max_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_surface_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4, value)?
    } else {
        value
    };
    data_field_with_info(
        4,
        "surface_interval",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_start_cns_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5, value)?
    } else {
        value
    };
    data_field_with_info(
        5,
        "start_cns",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_end_cns_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6, value)?
    } else {
        value
    };
    data_field_with_info(
        6,
        "end_cns",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_start_n2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7, value)?
    } else {
        value
    };
    data_field_with_info(
        7,
        "start_n2",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_end_n2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8, value)?
    } else {
        value
    };
    data_field_with_info(
        8,
        "end_n2",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_o2_toxicity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9, value)?
    } else {
        value
    };
    data_field_with_info(
        9,
        "o2_toxicity",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_dive_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10, value)?
    } else {
        value
    };
    data_field_with_info(
        10,
        "dive_number",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_bottom_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11, value)?
    } else {
        value
    };
    data_field_with_info(
        11,
        "bottom_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_ascent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17, value)?
    } else {
        value
    };
    data_field_with_info(
        17,
        "avg_ascent_rate",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_descent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22, value)?
    } else {
        value
    };
    data_field_with_info(
        22,
        "avg_descent_rate",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_max_ascent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23, value)?
    } else {
        value
    };
    data_field_with_info(
        23,
        "max_ascent_rate",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_max_descent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24, value)?
    } else {
        value
    };
    data_field_with_info(
        24,
        "max_descent_rate",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_hang_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25, value)?
    } else {
        value
    };
    data_field_with_info(
        25,
        "hang_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253, value)?
    } else {
        value
    };
    data_field_with_info(
        253,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
/// Heart rate variability
fn hrv_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0 => {
                // Time between beats
                fields.push(hrv_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000.000000,
                    0.000000,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hrv_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0, value)?
    } else {
        value
    };
    data_field_with_info(
        0,
        "time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}

fn unknown_message(
    data_map: &HashMap<u8, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    // since it's an unknown message all the fields are unknown
    if options.contains(&DecodeOption::DropUnknownFields) {
        {
            return Ok(Vec::new());
        }
    }
    let fields = data_map
        .iter()
        .map(|(k, v)| unknown_field(*k, v.clone()))
        .collect();
    Ok(fields)
}

impl MesgNum {
    /// Decode the raw values from a FitDataMessage based on the Global Message Number
    pub fn decode_message(
        self,
        data_map: &mut HashMap<u8, Value>,
        accumlators: &mut HashMap<u32, Value>,
        options: &HashSet<DecodeOption>,
    ) -> Result<Vec<FitDataField>> {
        match self {
            MesgNum::FileId => file_id_message(self, data_map, accumlators, options),
            MesgNum::FileCreator => file_creator_message(self, data_map, accumlators, options),
            MesgNum::TimestampCorrelation => {
                timestamp_correlation_message(self, data_map, accumlators, options)
            }
            MesgNum::Software => software_message(self, data_map, accumlators, options),
            MesgNum::SlaveDevice => slave_device_message(self, data_map, accumlators, options),
            MesgNum::Capabilities => capabilities_message(self, data_map, accumlators, options),
            MesgNum::FileCapabilities => {
                file_capabilities_message(self, data_map, accumlators, options)
            }
            MesgNum::MesgCapabilities => {
                mesg_capabilities_message(self, data_map, accumlators, options)
            }
            MesgNum::FieldCapabilities => {
                field_capabilities_message(self, data_map, accumlators, options)
            }
            MesgNum::DeviceSettings => {
                device_settings_message(self, data_map, accumlators, options)
            }
            MesgNum::UserProfile => user_profile_message(self, data_map, accumlators, options),
            MesgNum::HrmProfile => hrm_profile_message(self, data_map, accumlators, options),
            MesgNum::SdmProfile => sdm_profile_message(self, data_map, accumlators, options),
            MesgNum::BikeProfile => bike_profile_message(self, data_map, accumlators, options),
            MesgNum::Connectivity => connectivity_message(self, data_map, accumlators, options),
            MesgNum::WatchfaceSettings => {
                watchface_settings_message(self, data_map, accumlators, options)
            }
            MesgNum::OhrSettings => ohr_settings_message(self, data_map, accumlators, options),
            MesgNum::ZonesTarget => zones_target_message(self, data_map, accumlators, options),
            MesgNum::Sport => sport_message(self, data_map, accumlators, options),
            MesgNum::HrZone => hr_zone_message(self, data_map, accumlators, options),
            MesgNum::SpeedZone => speed_zone_message(self, data_map, accumlators, options),
            MesgNum::CadenceZone => cadence_zone_message(self, data_map, accumlators, options),
            MesgNum::PowerZone => power_zone_message(self, data_map, accumlators, options),
            MesgNum::MetZone => met_zone_message(self, data_map, accumlators, options),
            MesgNum::DiveSettings => dive_settings_message(self, data_map, accumlators, options),
            MesgNum::DiveAlarm => dive_alarm_message(self, data_map, accumlators, options),
            MesgNum::DiveGas => dive_gas_message(self, data_map, accumlators, options),
            MesgNum::Goal => goal_message(self, data_map, accumlators, options),
            MesgNum::Activity => activity_message(self, data_map, accumlators, options),
            MesgNum::Session => session_message(self, data_map, accumlators, options),
            MesgNum::Lap => lap_message(self, data_map, accumlators, options),
            MesgNum::Length => length_message(self, data_map, accumlators, options),
            MesgNum::Record => record_message(self, data_map, accumlators, options),
            MesgNum::Event => event_message(self, data_map, accumlators, options),
            MesgNum::DeviceInfo => device_info_message(self, data_map, accumlators, options),
            MesgNum::DeviceAuxBatteryInfo => {
                device_aux_battery_info_message(self, data_map, accumlators, options)
            }
            MesgNum::TrainingFile => training_file_message(self, data_map, accumlators, options),
            MesgNum::WeatherConditions => {
                weather_conditions_message(self, data_map, accumlators, options)
            }
            MesgNum::WeatherAlert => weather_alert_message(self, data_map, accumlators, options),
            MesgNum::GpsMetadata => gps_metadata_message(self, data_map, accumlators, options),
            MesgNum::CameraEvent => camera_event_message(self, data_map, accumlators, options),
            MesgNum::GyroscopeData => gyroscope_data_message(self, data_map, accumlators, options),
            MesgNum::AccelerometerData => {
                accelerometer_data_message(self, data_map, accumlators, options)
            }
            MesgNum::MagnetometerData => {
                magnetometer_data_message(self, data_map, accumlators, options)
            }
            MesgNum::BarometerData => barometer_data_message(self, data_map, accumlators, options),
            MesgNum::ThreeDSensorCalibration => {
                three_d_sensor_calibration_message(self, data_map, accumlators, options)
            }
            MesgNum::OneDSensorCalibration => {
                one_d_sensor_calibration_message(self, data_map, accumlators, options)
            }
            MesgNum::VideoFrame => video_frame_message(self, data_map, accumlators, options),
            MesgNum::ObdiiData => obdii_data_message(self, data_map, accumlators, options),
            MesgNum::NmeaSentence => nmea_sentence_message(self, data_map, accumlators, options),
            MesgNum::AviationAttitude => {
                aviation_attitude_message(self, data_map, accumlators, options)
            }
            MesgNum::Video => video_message(self, data_map, accumlators, options),
            MesgNum::VideoTitle => video_title_message(self, data_map, accumlators, options),
            MesgNum::VideoDescription => {
                video_description_message(self, data_map, accumlators, options)
            }
            MesgNum::VideoClip => video_clip_message(self, data_map, accumlators, options),
            MesgNum::Set => set_message(self, data_map, accumlators, options),
            MesgNum::Jump => jump_message(self, data_map, accumlators, options),
            MesgNum::ClimbPro => climb_pro_message(self, data_map, accumlators, options),
            MesgNum::FieldDescription => {
                field_description_message(self, data_map, accumlators, options)
            }
            MesgNum::DeveloperDataId => {
                developer_data_id_message(self, data_map, accumlators, options)
            }
            MesgNum::Course => course_message(self, data_map, accumlators, options),
            MesgNum::CoursePoint => course_point_message(self, data_map, accumlators, options),
            MesgNum::SegmentId => segment_id_message(self, data_map, accumlators, options),
            MesgNum::SegmentLeaderboardEntry => {
                segment_leaderboard_entry_message(self, data_map, accumlators, options)
            }
            MesgNum::SegmentPoint => segment_point_message(self, data_map, accumlators, options),
            MesgNum::SegmentLap => segment_lap_message(self, data_map, accumlators, options),
            MesgNum::SegmentFile => segment_file_message(self, data_map, accumlators, options),
            MesgNum::Workout => workout_message(self, data_map, accumlators, options),
            MesgNum::WorkoutSession => {
                workout_session_message(self, data_map, accumlators, options)
            }
            MesgNum::WorkoutStep => workout_step_message(self, data_map, accumlators, options),
            MesgNum::ExerciseTitle => exercise_title_message(self, data_map, accumlators, options),
            MesgNum::Schedule => schedule_message(self, data_map, accumlators, options),
            MesgNum::Totals => totals_message(self, data_map, accumlators, options),
            MesgNum::WeightScale => weight_scale_message(self, data_map, accumlators, options),
            MesgNum::BloodPressure => blood_pressure_message(self, data_map, accumlators, options),
            MesgNum::MonitoringInfo => {
                monitoring_info_message(self, data_map, accumlators, options)
            }
            MesgNum::Monitoring => monitoring_message(self, data_map, accumlators, options),
            MesgNum::Hr => hr_message(self, data_map, accumlators, options),
            MesgNum::StressLevel => stress_level_message(self, data_map, accumlators, options),
            MesgNum::MemoGlob => memo_glob_message(self, data_map, accumlators, options),
            MesgNum::AntChannelId => ant_channel_id_message(self, data_map, accumlators, options),
            MesgNum::AntRx => ant_rx_message(self, data_map, accumlators, options),
            MesgNum::AntTx => ant_tx_message(self, data_map, accumlators, options),
            MesgNum::ExdScreenConfiguration => {
                exd_screen_configuration_message(self, data_map, accumlators, options)
            }
            MesgNum::ExdDataFieldConfiguration => {
                exd_data_field_configuration_message(self, data_map, accumlators, options)
            }
            MesgNum::ExdDataConceptConfiguration => {
                exd_data_concept_configuration_message(self, data_map, accumlators, options)
            }
            MesgNum::DiveSummary => dive_summary_message(self, data_map, accumlators, options),
            MesgNum::Hrv => hrv_message(self, data_map, accumlators, options),
            _ => unknown_message(data_map, options),
        }
    }
}
