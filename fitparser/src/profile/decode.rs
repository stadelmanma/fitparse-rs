#![doc = "//! Auto generated profile messages from FIT SDK Release: 21.133.00"]
#![allow(unused_variables)]
use super::field_types::*;
use super::{calculate_cumulative_value, data_field_with_info, extract_component, unknown_field};
use crate::de::DecodeOption;
use crate::error::Result;
use crate::{FitDataField, Value};
use std::collections::{HashMap, HashSet, VecDeque};
use std::convert::TryInto;
#[doc = "FIT SDK version used to generate profile decoder"]
pub const VERSION: &str = "21.133.00";
#[doc = "Must be first message in file."]
fn file_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(file_id_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(file_id_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(file_id_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(file_id_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            3u8 => {
                fields.push(file_id_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(file_id_message_time_created_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(file_id_message_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(file_id_message_product_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn file_id_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "type",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        2u8,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        2u8,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_time_created_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "time_created",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "number",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_id_message_product_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "product_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_creator_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(file_creator_message_software_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(file_creator_message_hardware_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn file_creator_message_software_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "software_version",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_creator_message_hardware_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "hardware_version",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(timestamp_correlation_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(timestamp_correlation_message_system_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(
                    timestamp_correlation_message_fractional_system_timestamp_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        32768f64,
                        0f64,
                        "s",
                        value,
                    )?,
                );
            }
            3u8 => {
                fields.push(timestamp_correlation_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(timestamp_correlation_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            5u8 => {
                fields.push(timestamp_correlation_message_system_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            253u8 => {
                fields.push(timestamp_correlation_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn timestamp_correlation_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_system_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "system_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_fractional_system_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "fractional_system_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_system_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "system_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn timestamp_correlation_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn software_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            3u8 => {
                fields.push(software_message_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(software_message_part_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(software_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn software_message_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "version",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn software_message_part_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "part_number",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn software_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn slave_device_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(slave_device_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(slave_device_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(slave_device_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn slave_device_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn slave_device_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn slave_device_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn slave_device_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(capabilities_message_languages_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(capabilities_message_sports_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            21u8 => {
                fields.push(capabilities_message_workouts_supported_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            23u8 => {
                fields.push(capabilities_message_connectivity_supported_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn capabilities_message_languages_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "languages",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn capabilities_message_sports_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sports",
        FieldDataType::SportBits0,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn capabilities_message_workouts_supported_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "workouts_supported",
        FieldDataType::WorkoutCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn capabilities_message_connectivity_supported_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        "connectivity_supported",
        FieldDataType::ConnectivityCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(file_capabilities_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(file_capabilities_message_flags_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(file_capabilities_message_directory_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(file_capabilities_message_max_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(file_capabilities_message_max_size_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bytes",
                    value,
                )?);
            }
            254u8 => {
                fields.push(file_capabilities_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn file_capabilities_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "type",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_flags_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "flags",
        FieldDataType::FileFlags,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_directory_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "directory",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_max_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "max_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_max_size_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "max_size",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn file_capabilities_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(mesg_capabilities_message_file_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(mesg_capabilities_message_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(mesg_capabilities_message_count_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                if MesgCount::NumPerFile.as_i64()
                    == data_map
                        .get(&2u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(mesg_capabilities_message_num_per_file_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if MesgCount::MaxPerFile.as_i64()
                    == data_map
                        .get(&2u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(mesg_capabilities_message_max_per_file_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if MesgCount::MaxPerFileType.as_i64()
                    == data_map
                        .get(&2u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(mesg_capabilities_message_max_per_file_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(mesg_capabilities_message_count_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            254u8 => {
                fields.push(mesg_capabilities_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn mesg_capabilities_message_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "file",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_count_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "count_type",
        FieldDataType::MesgCount,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_num_per_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "count"
    } else {
        "num_per_file"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_max_per_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "count"
    } else {
        "max_per_file"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_max_per_file_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "count"
    } else {
        "max_per_file_type"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn mesg_capabilities_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(field_capabilities_message_file_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(field_capabilities_message_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(field_capabilities_message_field_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(field_capabilities_message_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(field_capabilities_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn field_capabilities_message_file_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "file",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_field_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "field_num",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_capabilities_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(device_settings_message_active_time_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(device_settings_message_utc_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(device_settings_message_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(device_settings_message_time_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(device_settings_message_time_zone_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    4f64,
                    0f64,
                    "hr",
                    value,
                )?);
            }
            12u8 => {
                fields.push(device_settings_message_backlight_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            36u8 => {
                fields.push(device_settings_message_activity_tracker_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            39u8 => {
                fields.push(device_settings_message_clock_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            40u8 => {
                fields.push(device_settings_message_pages_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            46u8 => {
                fields.push(device_settings_message_move_alert_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            47u8 => {
                fields.push(device_settings_message_date_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            55u8 => {
                fields.push(device_settings_message_display_orientation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            56u8 => {
                fields.push(device_settings_message_mounting_side_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            57u8 => {
                fields.push(device_settings_message_default_page_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            58u8 => {
                fields.push(device_settings_message_autosync_min_steps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "steps",
                    value,
                )?);
            }
            59u8 => {
                fields.push(device_settings_message_autosync_min_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "minutes",
                    value,
                )?);
            }
            80u8 => {
                fields.push(
                    device_settings_message_lactate_threshold_autodetect_enabled_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?,
                );
            }
            86u8 => {
                fields.push(device_settings_message_ble_auto_upload_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            89u8 => {
                fields.push(device_settings_message_auto_sync_frequency_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            90u8 => {
                fields.push(device_settings_message_auto_activity_detect_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            94u8 => {
                fields.push(device_settings_message_number_of_screens_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            95u8 => {
                fields.push(
                    device_settings_message_smart_notification_display_orientation_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?,
                );
            }
            134u8 => {
                fields.push(device_settings_message_tap_interface_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            174u8 => {
                fields.push(device_settings_message_tap_sensitivity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn device_settings_message_active_time_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "active_time_zone",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_utc_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "utc_offset",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "time_offset",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_time_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "time_mode",
        FieldDataType::TimeMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_time_zone_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "time_zone_offset",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_backlight_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "backlight_mode",
        FieldDataType::BacklightMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_activity_tracker_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 36u8, value)?
    } else {
        value
    };
    data_field_with_info(
        36u8,
        "activity_tracker_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_clock_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        "clock_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_pages_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40u8, value)?
    } else {
        value
    };
    data_field_with_info(
        40u8,
        "pages_enabled",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_move_alert_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46u8, value)?
    } else {
        value
    };
    data_field_with_info(
        46u8,
        "move_alert_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_date_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        "date_mode",
        FieldDataType::DateMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_display_orientation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55u8, value)?
    } else {
        value
    };
    data_field_with_info(
        55u8,
        "display_orientation",
        FieldDataType::DisplayOrientation,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_mounting_side_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56u8, value)?
    } else {
        value
    };
    data_field_with_info(
        56u8,
        "mounting_side",
        FieldDataType::Side,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_default_page_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57u8, value)?
    } else {
        value
    };
    data_field_with_info(
        57u8,
        "default_page",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_autosync_min_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58u8, value)?
    } else {
        value
    };
    data_field_with_info(
        58u8,
        "autosync_min_steps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_autosync_min_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59u8, value)?
    } else {
        value
    };
    data_field_with_info(
        59u8,
        "autosync_min_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_lactate_threshold_autodetect_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 80u8, value)?
    } else {
        value
    };
    data_field_with_info(
        80u8,
        "lactate_threshold_autodetect_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_ble_auto_upload_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86u8, value)?
    } else {
        value
    };
    data_field_with_info(
        86u8,
        "ble_auto_upload_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_auto_sync_frequency_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89u8, value)?
    } else {
        value
    };
    data_field_with_info(
        89u8,
        "auto_sync_frequency",
        FieldDataType::AutoSyncFrequency,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_auto_activity_detect_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 90u8, value)?
    } else {
        value
    };
    data_field_with_info(
        90u8,
        "auto_activity_detect",
        FieldDataType::AutoActivityDetect,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_number_of_screens_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94u8, value)?
    } else {
        value
    };
    data_field_with_info(
        94u8,
        "number_of_screens",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_smart_notification_display_orientation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95u8, value)?
    } else {
        value
    };
    data_field_with_info(
        95u8,
        "smart_notification_display_orientation",
        FieldDataType::DisplayOrientation,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_tap_interface_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 134u8, value)?
    } else {
        value
    };
    data_field_with_info(
        134u8,
        "tap_interface",
        FieldDataType::Switch,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_settings_message_tap_sensitivity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 174u8, value)?
    } else {
        value
    };
    data_field_with_info(
        174u8,
        "tap_sensitivity",
        FieldDataType::TapSensitivity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(user_profile_message_friendly_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(user_profile_message_gender_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(user_profile_message_age_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "years",
                    value,
                )?);
            }
            3u8 => {
                fields.push(user_profile_message_height_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(user_profile_message_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            5u8 => {
                fields.push(user_profile_message_language_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(user_profile_message_elev_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(user_profile_message_weight_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(user_profile_message_resting_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            9u8 => {
                fields.push(user_profile_message_default_max_running_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            10u8 => {
                fields.push(user_profile_message_default_max_biking_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            11u8 => {
                fields.push(user_profile_message_default_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            12u8 => {
                fields.push(user_profile_message_hr_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(user_profile_message_speed_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(user_profile_message_dist_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            16u8 => {
                fields.push(user_profile_message_power_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            17u8 => {
                fields.push(user_profile_message_activity_class_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            18u8 => {
                fields.push(user_profile_message_position_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            21u8 => {
                fields.push(user_profile_message_temperature_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            22u8 => {
                fields.push(user_profile_message_local_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            23u8 => {
                fields.push(user_profile_message_global_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            28u8 => {
                fields.push(user_profile_message_wake_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            29u8 => {
                fields.push(user_profile_message_sleep_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            30u8 => {
                fields.push(user_profile_message_height_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            31u8 => {
                fields.push(user_profile_message_user_running_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            32u8 => {
                fields.push(user_profile_message_user_walking_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            47u8 => {
                fields.push(user_profile_message_depth_setting_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            49u8 => {
                fields.push(user_profile_message_dive_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(user_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn user_profile_message_friendly_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "friendly_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_gender_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "gender",
        FieldDataType::Gender,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_age_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "age",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_height_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "height",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_language_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "language",
        FieldDataType::Language,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_elev_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "elev_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_weight_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "weight_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_resting_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "resting_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_default_max_running_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "default_max_running_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_default_max_biking_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "default_max_biking_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_default_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "default_max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_hr_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "hr_setting",
        FieldDataType::DisplayHeart,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_speed_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "speed_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_dist_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "dist_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_power_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        "power_setting",
        FieldDataType::DisplayPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_activity_class_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        "activity_class",
        FieldDataType::ActivityClass,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_position_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        "position_setting",
        FieldDataType::DisplayPosition,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_temperature_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "temperature_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_local_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "local_id",
        FieldDataType::UserLocalId,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_global_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        "global_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_wake_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        "wake_time",
        FieldDataType::LocaltimeIntoDay,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_sleep_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        "sleep_time",
        FieldDataType::LocaltimeIntoDay,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_height_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        "height_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_user_running_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31u8, value)?
    } else {
        value
    };
    data_field_with_info(
        31u8,
        "user_running_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_user_walking_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        "user_walking_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_depth_setting_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        "depth_setting",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_dive_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49u8, value)?
    } else {
        value
    };
    data_field_with_info(
        49u8,
        "dive_count",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn user_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hrm_profile_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hrm_profile_message_hrm_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hrm_profile_message_log_hrv_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(hrm_profile_message_hrm_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(hrm_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hrm_profile_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_hrm_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "hrm_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_log_hrv_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "log_hrv",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_hrm_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "hrm_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrm_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(sdm_profile_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(sdm_profile_message_sdm_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(sdm_profile_message_sdm_cal_factor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            3u8 => {
                fields.push(sdm_profile_message_odometer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(sdm_profile_message_speed_source_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(sdm_profile_message_sdm_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(sdm_profile_message_odometer_rollover_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(sdm_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn sdm_profile_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_sdm_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sdm_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_sdm_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "sdm_cal_factor",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_odometer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "odometer",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_speed_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "speed_source",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_sdm_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "sdm_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_odometer_rollover_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "odometer_rollover",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sdm_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(bike_profile_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(bike_profile_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(bike_profile_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(bike_profile_message_odometer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(bike_profile_message_bike_spd_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(bike_profile_message_bike_cad_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(bike_profile_message_bike_spdcad_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(bike_profile_message_bike_power_ant_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(bike_profile_message_custom_wheelsize_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            9u8 => {
                fields.push(bike_profile_message_auto_wheelsize_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            10u8 => {
                fields.push(bike_profile_message_bike_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            11u8 => {
                fields.push(bike_profile_message_power_cal_factor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            12u8 => {
                fields.push(bike_profile_message_auto_wheel_cal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(bike_profile_message_auto_power_zero_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(bike_profile_message_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                fields.push(bike_profile_message_spd_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            16u8 => {
                fields.push(bike_profile_message_cad_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            17u8 => {
                fields.push(bike_profile_message_spdcad_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            18u8 => {
                fields.push(bike_profile_message_power_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            19u8 => {
                fields.push(bike_profile_message_crank_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            20u8 => {
                fields.push(bike_profile_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            21u8 => {
                fields.push(bike_profile_message_bike_spd_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            22u8 => {
                fields.push(bike_profile_message_bike_cad_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            23u8 => {
                fields.push(bike_profile_message_bike_spdcad_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            24u8 => {
                fields.push(bike_profile_message_bike_power_ant_id_trans_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            37u8 => {
                fields.push(bike_profile_message_odometer_rollover_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            38u8 => {
                fields.push(bike_profile_message_front_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            39u8 => {
                fields.push(bike_profile_message_front_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            40u8 => {
                fields.push(bike_profile_message_rear_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            41u8 => {
                fields.push(bike_profile_message_rear_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            44u8 => {
                fields.push(bike_profile_message_shimano_di2_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(bike_profile_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn bike_profile_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_odometer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "odometer",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spd_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "bike_spd_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_cad_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "bike_cad_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spdcad_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "bike_spdcad_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_power_ant_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "bike_power_ant_id",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_custom_wheelsize_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "custom_wheelsize",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_auto_wheelsize_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "auto_wheelsize",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "bike_weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_power_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "power_cal_factor",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_auto_wheel_cal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "auto_wheel_cal",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_auto_power_zero_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "auto_power_zero",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "id",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_spd_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "spd_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_cad_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        "cad_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_spdcad_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        "spdcad_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_power_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        "power_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_crank_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        "crank_length",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spd_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "bike_spd_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_cad_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "bike_cad_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_spdcad_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        "bike_spdcad_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_bike_power_ant_id_trans_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        "bike_power_ant_id_trans_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_odometer_rollover_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37u8, value)?
    } else {
        value
    };
    data_field_with_info(
        37u8,
        "odometer_rollover",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_front_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 38u8, value)?
    } else {
        value
    };
    data_field_with_info(
        38u8,
        "front_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_front_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        "front_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_rear_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40u8, value)?
    } else {
        value
    };
    data_field_with_info(
        40u8,
        "rear_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_rear_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41u8, value)?
    } else {
        value
    };
    data_field_with_info(
        41u8,
        "rear_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_shimano_di2_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44u8, value)?
    } else {
        value
    };
    data_field_with_info(
        44u8,
        "shimano_di2_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn bike_profile_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(connectivity_message_bluetooth_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(connectivity_message_bluetooth_le_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(connectivity_message_ant_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(connectivity_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(connectivity_message_live_tracking_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(connectivity_message_weather_conditions_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(connectivity_message_weather_alerts_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(connectivity_message_auto_activity_upload_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(connectivity_message_course_download_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(connectivity_message_workout_download_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(connectivity_message_gps_ephemeris_download_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(connectivity_message_incident_detection_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(connectivity_message_grouptrack_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn connectivity_message_bluetooth_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "bluetooth_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_bluetooth_le_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "bluetooth_le_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_ant_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "ant_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_live_tracking_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "live_tracking_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_weather_conditions_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "weather_conditions_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_weather_alerts_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "weather_alerts_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_auto_activity_upload_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "auto_activity_upload_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_course_download_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "course_download_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_workout_download_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "workout_download_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_gps_ephemeris_download_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "gps_ephemeris_download_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_incident_detection_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "incident_detection_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn connectivity_message_grouptrack_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "grouptrack_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(watchface_settings_message_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if WatchfaceMode::Digital.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(watchface_settings_message_digital_layout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WatchfaceMode::Analog.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(watchface_settings_message_analog_layout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(watchface_settings_message_layout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            254u8 => {
                fields.push(watchface_settings_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn watchface_settings_message_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "mode",
        FieldDataType::WatchfaceMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "layout",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_digital_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "layout"
    } else {
        "digital_layout"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::DigitalWatchfaceLayout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_analog_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "layout"
    } else {
        "analog_layout"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::AnalogWatchfaceLayout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn watchface_settings_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ohr_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(ohr_settings_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(ohr_settings_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ohr_settings_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "enabled",
        FieldDataType::Switch,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ohr_settings_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(time_in_zone_message_reference_mesg_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(time_in_zone_message_reference_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(time_in_zone_message_time_in_hr_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            3u8 => {
                fields.push(time_in_zone_message_time_in_speed_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(time_in_zone_message_time_in_cadence_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(time_in_zone_message_time_in_power_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            6u8 => {
                fields.push(time_in_zone_message_hr_zone_high_boundary_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            7u8 => {
                fields.push(time_in_zone_message_speed_zone_high_boundary_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            8u8 => {
                fields.push(time_in_zone_message_cadence_zone_high_bondary_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            9u8 => {
                fields.push(time_in_zone_message_power_zone_high_boundary_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            10u8 => {
                fields.push(time_in_zone_message_hr_calc_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(time_in_zone_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(time_in_zone_message_resting_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(time_in_zone_message_threshold_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(time_in_zone_message_pwr_calc_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                fields.push(time_in_zone_message_functional_threshold_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(time_in_zone_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn time_in_zone_message_reference_mesg_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "reference_mesg",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_reference_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "reference_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_time_in_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "time_in_hr_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_time_in_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "time_in_speed_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_time_in_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "time_in_cadence_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_time_in_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "time_in_power_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_hr_zone_high_boundary_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "hr_zone_high_boundary",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_speed_zone_high_boundary_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "speed_zone_high_boundary",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_cadence_zone_high_bondary_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "cadence_zone_high_bondary",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_power_zone_high_boundary_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "power_zone_high_boundary",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_hr_calc_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "hr_calc_type",
        FieldDataType::HrZoneCalc,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_resting_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "resting_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_threshold_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "threshold_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_pwr_calc_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "pwr_calc_type",
        FieldDataType::PwrZoneCalc,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_functional_threshold_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "functional_threshold_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn time_in_zone_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1u8 => {
                fields.push(zones_target_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(zones_target_message_threshold_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(zones_target_message_functional_threshold_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(zones_target_message_hr_calc_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(zones_target_message_pwr_calc_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn zones_target_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_threshold_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "threshold_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_functional_threshold_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "functional_threshold_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_hr_calc_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "hr_calc_type",
        FieldDataType::HrZoneCalc,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn zones_target_message_pwr_calc_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "pwr_calc_type",
        FieldDataType::PwrZoneCalc,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sport_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(sport_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(sport_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(sport_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn sport_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sport_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sport_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1u8 => {
                fields.push(hr_zone_message_high_bpm_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hr_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(hr_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hr_zone_message_high_bpm_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "high_bpm",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn speed_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(speed_zone_message_high_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(speed_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(speed_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn speed_zone_message_high_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "high_value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn speed_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn speed_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn cadence_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(cadence_zone_message_high_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            1u8 => {
                fields.push(cadence_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(cadence_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn cadence_zone_message_high_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "high_value",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn cadence_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn cadence_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn power_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1u8 => {
                fields.push(power_zone_message_high_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            2u8 => {
                fields.push(power_zone_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(power_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn power_zone_message_high_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "high_value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn power_zone_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn power_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn met_zone_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1u8 => {
                fields.push(met_zone_message_high_bpm_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(met_zone_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "kcal / min",
                    value,
                )?);
            }
            3u8 => {
                fields.push(met_zone_message_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "kcal / min",
                    value,
                )?);
            }
            254u8 => {
                fields.push(met_zone_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn met_zone_message_high_bpm_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "high_bpm",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn met_zone_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn met_zone_message_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "fat_calories",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn met_zone_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(dive_settings_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(dive_settings_message_model_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(dive_settings_message_gf_low_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            3u8 => {
                fields.push(dive_settings_message_gf_high_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            4u8 => {
                fields.push(dive_settings_message_water_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(dive_settings_message_water_density_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kg/m^3",
                    value,
                )?);
            }
            6u8 => {
                fields.push(dive_settings_message_po2_warn_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            7u8 => {
                fields.push(dive_settings_message_po2_critical_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            8u8 => {
                fields.push(dive_settings_message_po2_deco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            9u8 => {
                fields.push(dive_settings_message_safety_stop_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(dive_settings_message_bottom_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(dive_settings_message_bottom_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(dive_settings_message_apnea_countdown_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(dive_settings_message_apnea_countdown_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(dive_settings_message_backlight_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                fields.push(dive_settings_message_backlight_brightness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            16u8 => {
                fields.push(dive_settings_message_backlight_timeout_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            17u8 => {
                fields.push(dive_settings_message_repeat_dive_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            18u8 => {
                fields.push(dive_settings_message_safety_stop_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            19u8 => {
                fields.push(dive_settings_message_heart_rate_source_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            20u8 => {
                if SourceType::Antplus.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(dive_settings_message_heart_rate_antplus_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if SourceType::Local.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(dive_settings_message_heart_rate_local_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(dive_settings_message_heart_rate_source_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            21u8 => {
                fields.push(dive_settings_message_travel_gas_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            22u8 => {
                fields.push(dive_settings_message_ccr_low_setpoint_switch_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            23u8 => {
                fields.push(dive_settings_message_ccr_low_setpoint_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            24u8 => {
                fields.push(dive_settings_message_ccr_low_setpoint_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            25u8 => {
                fields.push(dive_settings_message_ccr_high_setpoint_switch_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            26u8 => {
                fields.push(dive_settings_message_ccr_high_setpoint_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            27u8 => {
                fields.push(dive_settings_message_ccr_high_setpoint_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            29u8 => {
                fields.push(dive_settings_message_gas_consumption_display_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            30u8 => {
                fields.push(dive_settings_message_up_key_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            35u8 => {
                fields.push(dive_settings_message_dive_sounds_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            36u8 => {
                fields.push(dive_settings_message_last_stop_multiple_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            37u8 => {
                fields.push(dive_settings_message_no_fly_time_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(dive_settings_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(dive_settings_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_settings_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_model_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "model",
        FieldDataType::TissueModelType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_gf_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "gf_low",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_gf_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "gf_high",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_water_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "water_type",
        FieldDataType::WaterType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_water_density_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "water_density",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_po2_warn_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "po2_warn",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_po2_critical_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "po2_critical",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_po2_deco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "po2_deco",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_safety_stop_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "safety_stop_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_bottom_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "bottom_depth",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_bottom_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "bottom_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_apnea_countdown_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "apnea_countdown_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_apnea_countdown_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "apnea_countdown_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_backlight_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "backlight_mode",
        FieldDataType::DiveBacklightMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_backlight_brightness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "backlight_brightness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_backlight_timeout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        "backlight_timeout",
        FieldDataType::BacklightTimeout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_repeat_dive_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        "repeat_dive_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_safety_stop_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        "safety_stop_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_source_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        "heart_rate_source_type",
        FieldDataType::SourceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        "heart_rate_source",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_antplus_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "heart_rate_source"
    } else {
        "heart_rate_antplus_device_type"
    };
    data_field_with_info(
        20u8,
        name,
        FieldDataType::AntplusDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_heart_rate_local_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "heart_rate_source"
    } else {
        "heart_rate_local_device_type"
    };
    data_field_with_info(
        20u8,
        name,
        FieldDataType::LocalDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_travel_gas_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "travel_gas",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_low_setpoint_switch_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "ccr_low_setpoint_switch_mode",
        FieldDataType::CcrSetpointSwitchMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_low_setpoint_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        "ccr_low_setpoint",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_low_setpoint_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        "ccr_low_setpoint_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_high_setpoint_switch_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        "ccr_high_setpoint_switch_mode",
        FieldDataType::CcrSetpointSwitchMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_high_setpoint_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        "ccr_high_setpoint",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_ccr_high_setpoint_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        "ccr_high_setpoint_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_gas_consumption_display_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        "gas_consumption_display",
        FieldDataType::GasConsumptionRateType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_up_key_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        "up_key_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_dive_sounds_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 35u8, value)?
    } else {
        value
    };
    data_field_with_info(
        35u8,
        "dive_sounds",
        FieldDataType::Tone,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_last_stop_multiple_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 36u8, value)?
    } else {
        value
    };
    data_field_with_info(
        36u8,
        "last_stop_multiple",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_no_fly_time_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37u8, value)?
    } else {
        value
    };
    data_field_with_info(
        37u8,
        "no_fly_time_mode",
        FieldDataType::NoFlyTimeMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_settings_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(dive_alarm_message_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            1u8 => {
                fields.push(dive_alarm_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(dive_alarm_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(dive_alarm_message_alarm_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(dive_alarm_message_sound_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(dive_alarm_message_dive_types_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(dive_alarm_message_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(dive_alarm_message_popup_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(dive_alarm_message_trigger_on_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(dive_alarm_message_trigger_on_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(dive_alarm_message_repeating_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(dive_alarm_message_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "mps",
                    value,
                )?);
            }
            254u8 => {
                fields.push(dive_alarm_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_alarm_message_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "time",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_alarm_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "alarm_type",
        FieldDataType::DiveAlarmType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_sound_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "sound",
        FieldDataType::Tone,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_dive_types_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "dive_types",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_popup_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "popup_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_trigger_on_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "trigger_on_descent",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_trigger_on_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "trigger_on_ascent",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_repeating_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "repeating",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "speed",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_alarm_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(dive_apnea_alarm_message_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            1u8 => {
                fields.push(dive_apnea_alarm_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(dive_apnea_alarm_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(dive_apnea_alarm_message_alarm_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(dive_apnea_alarm_message_sound_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(dive_apnea_alarm_message_dive_types_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(dive_apnea_alarm_message_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(dive_apnea_alarm_message_popup_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(dive_apnea_alarm_message_trigger_on_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(dive_apnea_alarm_message_trigger_on_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(dive_apnea_alarm_message_repeating_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(dive_apnea_alarm_message_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "mps",
                    value,
                )?);
            }
            254u8 => {
                fields.push(dive_apnea_alarm_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_apnea_alarm_message_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "time",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_alarm_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "alarm_type",
        FieldDataType::DiveAlarmType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_sound_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "sound",
        FieldDataType::Tone,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_dive_types_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "dive_types",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_popup_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "popup_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_trigger_on_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "trigger_on_descent",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_trigger_on_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "trigger_on_ascent",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_repeating_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "repeating",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "speed",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_apnea_alarm_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(dive_gas_message_helium_content_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            1u8 => {
                fields.push(dive_gas_message_oxygen_content_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            2u8 => {
                fields.push(dive_gas_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(dive_gas_message_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(dive_gas_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_gas_message_helium_content_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "helium_content",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message_oxygen_content_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "oxygen_content",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "status",
        FieldDataType::DiveGasStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "mode",
        FieldDataType::DiveGasMode,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_gas_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(goal_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(goal_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(goal_message_start_date_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(goal_message_end_date_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(goal_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(goal_message_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(goal_message_repeat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(goal_message_target_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(goal_message_recurrence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(goal_message_recurrence_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(goal_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(goal_message_source_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(goal_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn goal_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_start_date_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "start_date",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_end_date_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "end_date",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "type",
        FieldDataType::Goal,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_repeat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "repeat",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_target_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "target_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_recurrence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "recurrence",
        FieldDataType::GoalRecurrence,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_recurrence_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "recurrence_value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "source",
        FieldDataType::GoalSource,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn goal_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(activity_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(activity_message_num_sessions_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(activity_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(activity_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(activity_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(activity_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(activity_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(activity_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn activity_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_num_sessions_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "num_sessions",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "type",
        FieldDataType::Activity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn activity_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(session_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(session_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(session_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(session_message_start_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            4u8 => {
                fields.push(session_message_start_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            5u8 => {
                fields.push(session_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(session_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(session_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            8u8 => {
                fields.push(session_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            9u8 => {
                fields.push(session_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            10u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides",
                        value,
                    )?);
                } else if Sport::Walking.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides",
                        value,
                    )?);
                } else if Sport::Cycling.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Swimming.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Rowing.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::StandUpPaddleboarding.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(session_message_total_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "cycles",
                        value,
                    )?);
                }
            }
            11u8 => {
                fields.push(session_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            13u8 => {
                fields.push(session_message_total_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            14u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_avg_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(124u8, enhanced_avg_speed.clone());
                fields.push(session_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_avg_speed,
                )?);
            }
            15u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_max_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(125u8, enhanced_max_speed.clone());
                fields.push(session_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_max_speed,
                )?);
            }
            16u8 => {
                fields.push(session_message_avg_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            17u8 => {
                fields.push(session_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            18u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_avg_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(session_message_avg_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                }
            }
            19u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(session_message_max_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(session_message_max_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                }
            }
            20u8 => {
                fields.push(session_message_avg_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            21u8 => {
                fields.push(session_message_max_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            22u8 => {
                fields.push(session_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            23u8 => {
                fields.push(session_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            24u8 => {
                fields.push(session_message_total_training_effect_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            25u8 => {
                fields.push(session_message_first_lap_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            26u8 => {
                fields.push(session_message_num_laps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            27u8 => {
                fields.push(session_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            28u8 => {
                fields.push(session_message_trigger_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            29u8 => {
                fields.push(session_message_nec_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            30u8 => {
                fields.push(session_message_nec_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            31u8 => {
                fields.push(session_message_swc_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            32u8 => {
                fields.push(session_message_swc_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            33u8 => {
                fields.push(session_message_num_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "lengths",
                    value,
                )?);
            }
            34u8 => {
                fields.push(session_message_normalized_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            35u8 => {
                fields.push(session_message_training_stress_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "tss",
                    value,
                )?);
            }
            36u8 => {
                fields.push(session_message_intensity_factor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "if",
                    value,
                )?);
            }
            37u8 => {
                fields.push(session_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            38u8 => {
                fields.push(session_message_end_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            39u8 => {
                fields.push(session_message_end_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            41u8 => {
                fields.push(session_message_avg_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "strokes/lap",
                    value,
                )?);
            }
            42u8 => {
                fields.push(session_message_avg_stroke_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            43u8 => {
                fields.push(session_message_swim_stroke_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "swim_stroke",
                    value,
                )?);
            }
            44u8 => {
                fields.push(session_message_pool_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            45u8 => {
                fields.push(session_message_threshold_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            46u8 => {
                fields.push(session_message_pool_length_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            47u8 => {
                fields.push(session_message_num_active_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "lengths",
                    value,
                )?);
            }
            48u8 => {
                fields.push(session_message_total_work_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "J",
                    value,
                )?);
            }
            49u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_avg_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(126u8, enhanced_avg_altitude.clone());
                fields.push(session_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_avg_altitude,
                )?);
            }
            50u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_max_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(128u8, enhanced_max_altitude.clone());
                fields.push(session_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_max_altitude,
                )?);
            }
            51u8 => {
                fields.push(session_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            52u8 => {
                fields.push(session_message_avg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            53u8 => {
                fields.push(session_message_avg_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            54u8 => {
                fields.push(session_message_avg_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            55u8 => {
                fields.push(session_message_max_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            56u8 => {
                fields.push(session_message_max_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            57u8 => {
                fields.push(session_message_avg_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            58u8 => {
                fields.push(session_message_max_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            59u8 => {
                fields.push(session_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            60u8 => {
                fields.push(session_message_avg_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            61u8 => {
                fields.push(session_message_avg_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            62u8 => {
                fields.push(session_message_max_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            63u8 => {
                fields.push(session_message_max_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            64u8 => {
                fields.push(session_message_min_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            65u8 => {
                fields.push(session_message_time_in_hr_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            66u8 => {
                fields.push(session_message_time_in_speed_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            67u8 => {
                fields.push(session_message_time_in_cadence_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            68u8 => {
                fields.push(session_message_time_in_power_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            69u8 => {
                fields.push(session_message_avg_lap_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            70u8 => {
                fields.push(session_message_best_lap_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            71u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_min_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_min_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(127u8, enhanced_min_altitude.clone());
                fields.push(session_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_min_altitude,
                )?);
            }
            82u8 => {
                fields.push(session_message_player_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            83u8 => {
                fields.push(session_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            84u8 => {
                fields.push(session_message_opponent_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            85u8 => {
                fields.push(session_message_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            86u8 => {
                fields.push(session_message_zone_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            87u8 => {
                fields.push(session_message_max_ball_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            88u8 => {
                fields.push(session_message_avg_ball_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            89u8 => {
                fields.push(session_message_avg_vertical_oscillation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            90u8 => {
                fields.push(session_message_avg_stance_time_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            91u8 => {
                fields.push(session_message_avg_stance_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            92u8 => {
                fields.push(session_message_avg_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            93u8 => {
                fields.push(session_message_max_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            94u8 => {
                fields.push(session_message_total_fractional_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "cycles",
                    value,
                )?);
            }
            95u8 => {
                fields.push(session_message_avg_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            96u8 => {
                fields.push(session_message_min_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            97u8 => {
                fields.push(session_message_max_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            98u8 => {
                fields.push(session_message_avg_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            99u8 => {
                fields.push(session_message_min_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            100u8 => {
                fields.push(session_message_max_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            101u8 => {
                fields.push(session_message_avg_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            102u8 => {
                fields.push(session_message_avg_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            103u8 => {
                fields.push(session_message_avg_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            104u8 => {
                fields.push(session_message_avg_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            105u8 => {
                fields.push(session_message_avg_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            110u8 => {
                fields.push(session_message_sport_profile_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            111u8 => {
                fields.push(session_message_sport_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            112u8 => {
                fields.push(session_message_time_standing_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            113u8 => {
                fields.push(session_message_stand_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            114u8 => {
                fields.push(session_message_avg_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            115u8 => {
                fields.push(session_message_avg_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            116u8 => {
                fields.push(session_message_avg_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            117u8 => {
                fields.push(session_message_avg_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            118u8 => {
                fields.push(session_message_avg_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            119u8 => {
                fields.push(session_message_avg_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            120u8 => {
                fields.push(session_message_avg_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            121u8 => {
                fields.push(session_message_max_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            122u8 => {
                fields.push(session_message_avg_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            123u8 => {
                fields.push(session_message_max_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            124u8 => {
                fields.push(session_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            125u8 => {
                fields.push(session_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            126u8 => {
                fields.push(session_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            127u8 => {
                fields.push(session_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            128u8 => {
                fields.push(session_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            129u8 => {
                fields.push(session_message_avg_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            130u8 => {
                fields.push(session_message_max_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            131u8 => {
                fields.push(session_message_lev_battery_consumption_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            132u8 => {
                fields.push(session_message_avg_vertical_ratio_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            133u8 => {
                fields.push(session_message_avg_stance_time_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            134u8 => {
                fields.push(session_message_avg_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            137u8 => {
                fields.push(session_message_total_anaerobic_training_effect_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            139u8 => {
                fields.push(session_message_avg_vam_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            140u8 => {
                fields.push(session_message_avg_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            141u8 => {
                fields.push(session_message_max_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            142u8 => {
                fields.push(session_message_surface_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            143u8 => {
                fields.push(session_message_start_cns_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            144u8 => {
                fields.push(session_message_end_cns_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            145u8 => {
                fields.push(session_message_start_n2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            146u8 => {
                fields.push(session_message_end_n2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            147u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_avg_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(169u8, enhanced_avg_respiration_rate.clone());
                fields.push(session_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_avg_respiration_rate,
                )?);
            }
            148u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_max_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(170u8, enhanced_max_respiration_rate.clone());
                fields.push(session_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_max_respiration_rate,
                )?);
            }
            149u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(session_message_min_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_min_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(180u8, enhanced_min_respiration_rate.clone());
                fields.push(session_message_enhanced_min_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_min_respiration_rate,
                )?);
            }
            150u8 => {
                fields.push(session_message_min_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            155u8 => {
                fields.push(session_message_o2_toxicity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "OTUs",
                    value,
                )?);
            }
            156u8 => {
                fields.push(session_message_dive_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            168u8 => {
                fields.push(session_message_training_load_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    65536f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            169u8 => {
                fields.push(session_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            170u8 => {
                fields.push(session_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            180u8 => {
                fields.push(session_message_enhanced_min_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            181u8 => {
                fields.push(session_message_total_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            182u8 => {
                fields.push(session_message_total_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            183u8 => {
                fields.push(session_message_jump_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            186u8 => {
                fields.push(session_message_avg_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            187u8 => {
                fields.push(session_message_avg_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            194u8 => {
                fields.push(session_message_avg_spo2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            195u8 => {
                fields.push(session_message_avg_stress_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            197u8 => {
                fields.push(session_message_sdrr_hrv_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mS",
                    value,
                )?);
            }
            198u8 => {
                fields.push(session_message_rmssd_hrv_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mS",
                    value,
                )?);
            }
            199u8 => {
                fields.push(session_message_total_fractional_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            200u8 => {
                fields.push(session_message_total_fractional_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            208u8 => {
                fields.push(session_message_avg_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            209u8 => {
                fields.push(session_message_min_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            210u8 => {
                fields.push(session_message_max_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            253u8 => {
                fields.push(session_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(session_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn session_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "start_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "start_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_strides_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strides"
    };
    data_field_with_info(
        10u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strokes"
    };
    data_field_with_info(
        10u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "total_fat_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "max_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        "avg_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        "avg_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "avg_cadence"
    } else {
        "avg_running_cadence"
    };
    data_field_with_info(
        18u8,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        "max_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "max_cadence"
    } else {
        "max_running_cadence"
    };
    data_field_with_info(
        19u8,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        "avg_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "max_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_training_effect_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        "total_training_effect",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_first_lap_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        "first_lap_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_num_laps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        "num_laps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_trigger_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        "trigger",
        FieldDataType::SessionTrigger,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_nec_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        "nec_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_nec_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        "nec_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_swc_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31u8, value)?
    } else {
        value
    };
    data_field_with_info(
        31u8,
        "swc_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_swc_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        "swc_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_num_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33u8, value)?
    } else {
        value
    };
    data_field_with_info(
        33u8,
        "num_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_normalized_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34u8, value)?
    } else {
        value
    };
    data_field_with_info(
        34u8,
        "normalized_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_training_stress_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 35u8, value)?
    } else {
        value
    };
    data_field_with_info(
        35u8,
        "training_stress_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_intensity_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 36u8, value)?
    } else {
        value
    };
    data_field_with_info(
        36u8,
        "intensity_factor",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37u8, value)?
    } else {
        value
    };
    data_field_with_info(
        37u8,
        "left_right_balance",
        FieldDataType::LeftRightBalance100,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_end_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 38u8, value)?
    } else {
        value
    };
    data_field_with_info(
        38u8,
        "end_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_end_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        "end_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41u8, value)?
    } else {
        value
    };
    data_field_with_info(
        41u8,
        "avg_stroke_count",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stroke_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42u8, value)?
    } else {
        value
    };
    data_field_with_info(
        42u8,
        "avg_stroke_distance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_swim_stroke_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43u8, value)?
    } else {
        value
    };
    data_field_with_info(
        43u8,
        "swim_stroke",
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_pool_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44u8, value)?
    } else {
        value
    };
    data_field_with_info(
        44u8,
        "pool_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_threshold_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45u8, value)?
    } else {
        value
    };
    data_field_with_info(
        45u8,
        "threshold_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_pool_length_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46u8, value)?
    } else {
        value
    };
    data_field_with_info(
        46u8,
        "pool_length_unit",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_num_active_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        "num_active_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_work_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48u8, value)?
    } else {
        value
    };
    data_field_with_info(
        48u8,
        "total_work",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49u8, value)?
    } else {
        value
    };
    data_field_with_info(
        49u8,
        "avg_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50u8, value)?
    } else {
        value
    };
    data_field_with_info(
        50u8,
        "max_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51u8, value)?
    } else {
        value
    };
    data_field_with_info(
        51u8,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52u8, value)?
    } else {
        value
    };
    data_field_with_info(
        52u8,
        "avg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53u8, value)?
    } else {
        value
    };
    data_field_with_info(
        53u8,
        "avg_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54u8, value)?
    } else {
        value
    };
    data_field_with_info(
        54u8,
        "avg_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55u8, value)?
    } else {
        value
    };
    data_field_with_info(
        55u8,
        "max_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56u8, value)?
    } else {
        value
    };
    data_field_with_info(
        56u8,
        "max_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57u8, value)?
    } else {
        value
    };
    data_field_with_info(
        57u8,
        "avg_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58u8, value)?
    } else {
        value
    };
    data_field_with_info(
        58u8,
        "max_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59u8, value)?
    } else {
        value
    };
    data_field_with_info(
        59u8,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 60u8, value)?
    } else {
        value
    };
    data_field_with_info(
        60u8,
        "avg_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 61u8, value)?
    } else {
        value
    };
    data_field_with_info(
        61u8,
        "avg_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62u8, value)?
    } else {
        value
    };
    data_field_with_info(
        62u8,
        "max_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 63u8, value)?
    } else {
        value
    };
    data_field_with_info(
        63u8,
        "max_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 64u8, value)?
    } else {
        value
    };
    data_field_with_info(
        64u8,
        "min_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 65u8, value)?
    } else {
        value
    };
    data_field_with_info(
        65u8,
        "time_in_hr_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 66u8, value)?
    } else {
        value
    };
    data_field_with_info(
        66u8,
        "time_in_speed_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 67u8, value)?
    } else {
        value
    };
    data_field_with_info(
        67u8,
        "time_in_cadence_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_in_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 68u8, value)?
    } else {
        value
    };
    data_field_with_info(
        68u8,
        "time_in_power_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_lap_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 69u8, value)?
    } else {
        value
    };
    data_field_with_info(
        69u8,
        "avg_lap_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_best_lap_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 70u8, value)?
    } else {
        value
    };
    data_field_with_info(
        70u8,
        "best_lap_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71u8, value)?
    } else {
        value
    };
    data_field_with_info(
        71u8,
        "min_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_player_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82u8, value)?
    } else {
        value
    };
    data_field_with_info(
        82u8,
        "player_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83u8, value)?
    } else {
        value
    };
    data_field_with_info(
        83u8,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_opponent_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84u8, value)?
    } else {
        value
    };
    data_field_with_info(
        84u8,
        "opponent_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85u8, value)?
    } else {
        value
    };
    data_field_with_info(
        85u8,
        "stroke_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_zone_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86u8, value)?
    } else {
        value
    };
    data_field_with_info(
        86u8,
        "zone_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_ball_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 87u8, value)?
    } else {
        value
    };
    data_field_with_info(
        87u8,
        "max_ball_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_ball_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 88u8, value)?
    } else {
        value
    };
    data_field_with_info(
        88u8,
        "avg_ball_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_vertical_oscillation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89u8, value)?
    } else {
        value
    };
    data_field_with_info(
        89u8,
        "avg_vertical_oscillation",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stance_time_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 90u8, value)?
    } else {
        value
    };
    data_field_with_info(
        90u8,
        "avg_stance_time_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stance_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 91u8, value)?
    } else {
        value
    };
    data_field_with_info(
        91u8,
        "avg_stance_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 92u8, value)?
    } else {
        value
    };
    data_field_with_info(
        92u8,
        "avg_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 93u8, value)?
    } else {
        value
    };
    data_field_with_info(
        93u8,
        "max_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fractional_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94u8, value)?
    } else {
        value
    };
    data_field_with_info(
        94u8,
        "total_fractional_cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95u8, value)?
    } else {
        value
    };
    data_field_with_info(
        95u8,
        "avg_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 96u8, value)?
    } else {
        value
    };
    data_field_with_info(
        96u8,
        "min_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 97u8, value)?
    } else {
        value
    };
    data_field_with_info(
        97u8,
        "max_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 98u8, value)?
    } else {
        value
    };
    data_field_with_info(
        98u8,
        "avg_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 99u8, value)?
    } else {
        value
    };
    data_field_with_info(
        99u8,
        "min_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 100u8, value)?
    } else {
        value
    };
    data_field_with_info(
        100u8,
        "max_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 101u8, value)?
    } else {
        value
    };
    data_field_with_info(
        101u8,
        "avg_left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 102u8, value)?
    } else {
        value
    };
    data_field_with_info(
        102u8,
        "avg_right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 103u8, value)?
    } else {
        value
    };
    data_field_with_info(
        103u8,
        "avg_left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 104u8, value)?
    } else {
        value
    };
    data_field_with_info(
        104u8,
        "avg_right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 105u8, value)?
    } else {
        value
    };
    data_field_with_info(
        105u8,
        "avg_combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sport_profile_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 110u8, value)?
    } else {
        value
    };
    data_field_with_info(
        110u8,
        "sport_profile_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sport_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 111u8, value)?
    } else {
        value
    };
    data_field_with_info(
        111u8,
        "sport_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_time_standing_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 112u8, value)?
    } else {
        value
    };
    data_field_with_info(
        112u8,
        "time_standing",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_stand_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 113u8, value)?
    } else {
        value
    };
    data_field_with_info(
        113u8,
        "stand_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 114u8, value)?
    } else {
        value
    };
    data_field_with_info(
        114u8,
        "avg_left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 115u8, value)?
    } else {
        value
    };
    data_field_with_info(
        115u8,
        "avg_right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 116u8, value)?
    } else {
        value
    };
    data_field_with_info(
        116u8,
        "avg_left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 117u8, value)?
    } else {
        value
    };
    data_field_with_info(
        117u8,
        "avg_left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 118u8, value)?
    } else {
        value
    };
    data_field_with_info(
        118u8,
        "avg_right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 119u8, value)?
    } else {
        value
    };
    data_field_with_info(
        119u8,
        "avg_right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 120u8, value)?
    } else {
        value
    };
    data_field_with_info(
        120u8,
        "avg_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 121u8, value)?
    } else {
        value
    };
    data_field_with_info(
        121u8,
        "max_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 122u8, value)?
    } else {
        value
    };
    data_field_with_info(
        122u8,
        "avg_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 123u8, value)?
    } else {
        value
    };
    data_field_with_info(
        123u8,
        "max_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 124u8, value)?
    } else {
        value
    };
    data_field_with_info(
        124u8,
        "enhanced_avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 125u8, value)?
    } else {
        value
    };
    data_field_with_info(
        125u8,
        "enhanced_max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 126u8, value)?
    } else {
        value
    };
    data_field_with_info(
        126u8,
        "enhanced_avg_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 127u8, value)?
    } else {
        value
    };
    data_field_with_info(
        127u8,
        "enhanced_min_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 128u8, value)?
    } else {
        value
    };
    data_field_with_info(
        128u8,
        "enhanced_max_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 129u8, value)?
    } else {
        value
    };
    data_field_with_info(
        129u8,
        "avg_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 130u8, value)?
    } else {
        value
    };
    data_field_with_info(
        130u8,
        "max_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_lev_battery_consumption_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 131u8, value)?
    } else {
        value
    };
    data_field_with_info(
        131u8,
        "lev_battery_consumption",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_vertical_ratio_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 132u8, value)?
    } else {
        value
    };
    data_field_with_info(
        132u8,
        "avg_vertical_ratio",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stance_time_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 133u8, value)?
    } else {
        value
    };
    data_field_with_info(
        133u8,
        "avg_stance_time_balance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 134u8, value)?
    } else {
        value
    };
    data_field_with_info(
        134u8,
        "avg_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_anaerobic_training_effect_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 137u8, value)?
    } else {
        value
    };
    data_field_with_info(
        137u8,
        "total_anaerobic_training_effect",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_vam_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 139u8, value)?
    } else {
        value
    };
    data_field_with_info(
        139u8,
        "avg_vam",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 140u8, value)?
    } else {
        value
    };
    data_field_with_info(
        140u8,
        "avg_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 141u8, value)?
    } else {
        value
    };
    data_field_with_info(
        141u8,
        "max_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_surface_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 142u8, value)?
    } else {
        value
    };
    data_field_with_info(
        142u8,
        "surface_interval",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_cns_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 143u8, value)?
    } else {
        value
    };
    data_field_with_info(
        143u8,
        "start_cns",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_end_cns_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 144u8, value)?
    } else {
        value
    };
    data_field_with_info(
        144u8,
        "end_cns",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_start_n2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 145u8, value)?
    } else {
        value
    };
    data_field_with_info(
        145u8,
        "start_n2",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_end_n2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 146u8, value)?
    } else {
        value
    };
    data_field_with_info(
        146u8,
        "end_n2",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 147u8, value)?
    } else {
        value
    };
    data_field_with_info(
        147u8,
        "avg_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 148u8, value)?
    } else {
        value
    };
    data_field_with_info(
        148u8,
        "max_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 149u8, value)?
    } else {
        value
    };
    data_field_with_info(
        149u8,
        "min_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 150u8, value)?
    } else {
        value
    };
    data_field_with_info(
        150u8,
        "min_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_o2_toxicity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 155u8, value)?
    } else {
        value
    };
    data_field_with_info(
        155u8,
        "o2_toxicity",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_dive_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 156u8, value)?
    } else {
        value
    };
    data_field_with_info(
        156u8,
        "dive_number",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_training_load_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 168u8, value)?
    } else {
        value
    };
    data_field_with_info(
        168u8,
        "training_load_peak",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 169u8, value)?
    } else {
        value
    };
    data_field_with_info(
        169u8,
        "enhanced_avg_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 170u8, value)?
    } else {
        value
    };
    data_field_with_info(
        170u8,
        "enhanced_max_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_enhanced_min_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 180u8, value)?
    } else {
        value
    };
    data_field_with_info(
        180u8,
        "enhanced_min_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 181u8, value)?
    } else {
        value
    };
    data_field_with_info(
        181u8,
        "total_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 182u8, value)?
    } else {
        value
    };
    data_field_with_info(
        182u8,
        "total_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_jump_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 183u8, value)?
    } else {
        value
    };
    data_field_with_info(
        183u8,
        "jump_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 186u8, value)?
    } else {
        value
    };
    data_field_with_info(
        186u8,
        "avg_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 187u8, value)?
    } else {
        value
    };
    data_field_with_info(
        187u8,
        "avg_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_spo2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 194u8, value)?
    } else {
        value
    };
    data_field_with_info(
        194u8,
        "avg_spo2",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_stress_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 195u8, value)?
    } else {
        value
    };
    data_field_with_info(
        195u8,
        "avg_stress",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_sdrr_hrv_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 197u8, value)?
    } else {
        value
    };
    data_field_with_info(
        197u8,
        "sdrr_hrv",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_rmssd_hrv_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 198u8, value)?
    } else {
        value
    };
    data_field_with_info(
        198u8,
        "rmssd_hrv",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fractional_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 199u8, value)?
    } else {
        value
    };
    data_field_with_info(
        199u8,
        "total_fractional_ascent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_total_fractional_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 200u8, value)?
    } else {
        value
    };
    data_field_with_info(
        200u8,
        "total_fractional_descent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_avg_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 208u8, value)?
    } else {
        value
    };
    data_field_with_info(
        208u8,
        "avg_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_min_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 209u8, value)?
    } else {
        value
    };
    data_field_with_info(
        209u8,
        "min_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_max_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 210u8, value)?
    } else {
        value
    };
    data_field_with_info(
        210u8,
        "max_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn session_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(lap_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(lap_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(lap_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(lap_message_start_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            4u8 => {
                fields.push(lap_message_start_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            5u8 => {
                fields.push(lap_message_end_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            6u8 => {
                fields.push(lap_message_end_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            7u8 => {
                fields.push(lap_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            8u8 => {
                fields.push(lap_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            9u8 => {
                fields.push(lap_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            10u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides",
                        value,
                    )?);
                } else if Sport::Walking.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strides_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides",
                        value,
                    )?);
                } else if Sport::Cycling.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Swimming.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::Rowing.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if Sport::StandUpPaddleboarding.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(lap_message_total_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "cycles",
                        value,
                    )?);
                }
            }
            11u8 => {
                fields.push(lap_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            12u8 => {
                fields.push(lap_message_total_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            13u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_avg_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(110u8, enhanced_avg_speed.clone());
                fields.push(lap_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_avg_speed,
                )?);
            }
            14u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_max_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(111u8, enhanced_max_speed.clone());
                fields.push(lap_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_max_speed,
                )?);
            }
            15u8 => {
                fields.push(lap_message_avg_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            16u8 => {
                fields.push(lap_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            17u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_avg_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(lap_message_avg_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                }
            }
            18u8 => {
                if Sport::Running.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(lap_message_max_running_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strides/min",
                        value,
                    )?);
                } else {
                    fields.push(lap_message_max_cadence_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                }
            }
            19u8 => {
                fields.push(lap_message_avg_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            20u8 => {
                fields.push(lap_message_max_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            21u8 => {
                fields.push(lap_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            22u8 => {
                fields.push(lap_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            23u8 => {
                fields.push(lap_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            24u8 => {
                fields.push(lap_message_lap_trigger_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            25u8 => {
                fields.push(lap_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            26u8 => {
                fields.push(lap_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            32u8 => {
                fields.push(lap_message_num_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "lengths",
                    value,
                )?);
            }
            33u8 => {
                fields.push(lap_message_normalized_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            34u8 => {
                fields.push(lap_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            35u8 => {
                fields.push(lap_message_first_length_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            37u8 => {
                fields.push(lap_message_avg_stroke_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            38u8 => {
                fields.push(lap_message_swim_stroke_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            39u8 => {
                fields.push(lap_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            40u8 => {
                fields.push(lap_message_num_active_lengths_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "lengths",
                    value,
                )?);
            }
            41u8 => {
                fields.push(lap_message_total_work_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "J",
                    value,
                )?);
            }
            42u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_avg_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(112u8, enhanced_avg_altitude.clone());
                fields.push(lap_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_avg_altitude,
                )?);
            }
            43u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_max_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(114u8, enhanced_max_altitude.clone());
                fields.push(lap_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_max_altitude,
                )?);
            }
            44u8 => {
                fields.push(lap_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            45u8 => {
                fields.push(lap_message_avg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            46u8 => {
                fields.push(lap_message_avg_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            47u8 => {
                fields.push(lap_message_avg_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            48u8 => {
                fields.push(lap_message_max_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            49u8 => {
                fields.push(lap_message_max_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            50u8 => {
                fields.push(lap_message_avg_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            51u8 => {
                fields.push(lap_message_max_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            52u8 => {
                fields.push(lap_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            53u8 => {
                fields.push(lap_message_avg_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            54u8 => {
                fields.push(lap_message_avg_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            55u8 => {
                fields.push(lap_message_max_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            56u8 => {
                fields.push(lap_message_max_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            57u8 => {
                fields.push(lap_message_time_in_hr_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            58u8 => {
                fields.push(lap_message_time_in_speed_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            59u8 => {
                fields.push(lap_message_time_in_cadence_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            60u8 => {
                fields.push(lap_message_time_in_power_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            61u8 => {
                fields.push(lap_message_repetition_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            62u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_min_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_min_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(113u8, enhanced_min_altitude.clone());
                fields.push(lap_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_min_altitude,
                )?);
            }
            63u8 => {
                fields.push(lap_message_min_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            71u8 => {
                fields.push(lap_message_wkt_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            74u8 => {
                fields.push(lap_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            75u8 => {
                fields.push(lap_message_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            76u8 => {
                fields.push(lap_message_zone_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            77u8 => {
                fields.push(lap_message_avg_vertical_oscillation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            78u8 => {
                fields.push(lap_message_avg_stance_time_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            79u8 => {
                fields.push(lap_message_avg_stance_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            80u8 => {
                fields.push(lap_message_avg_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            81u8 => {
                fields.push(lap_message_max_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            82u8 => {
                fields.push(lap_message_total_fractional_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "cycles",
                    value,
                )?);
            }
            83u8 => {
                fields.push(lap_message_player_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            84u8 => {
                fields.push(lap_message_avg_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            85u8 => {
                fields.push(lap_message_min_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            86u8 => {
                fields.push(lap_message_max_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            87u8 => {
                fields.push(lap_message_avg_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            88u8 => {
                fields.push(lap_message_min_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            89u8 => {
                fields.push(lap_message_max_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            91u8 => {
                fields.push(lap_message_avg_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            92u8 => {
                fields.push(lap_message_avg_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            93u8 => {
                fields.push(lap_message_avg_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            94u8 => {
                fields.push(lap_message_avg_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            95u8 => {
                fields.push(lap_message_avg_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            98u8 => {
                fields.push(lap_message_time_standing_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            99u8 => {
                fields.push(lap_message_stand_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            100u8 => {
                fields.push(lap_message_avg_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            101u8 => {
                fields.push(lap_message_avg_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            102u8 => {
                fields.push(lap_message_avg_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            103u8 => {
                fields.push(lap_message_avg_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            104u8 => {
                fields.push(lap_message_avg_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            105u8 => {
                fields.push(lap_message_avg_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            106u8 => {
                fields.push(lap_message_avg_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            107u8 => {
                fields.push(lap_message_max_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            108u8 => {
                fields.push(lap_message_avg_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            109u8 => {
                fields.push(lap_message_max_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            110u8 => {
                fields.push(lap_message_enhanced_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            111u8 => {
                fields.push(lap_message_enhanced_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            112u8 => {
                fields.push(lap_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            113u8 => {
                fields.push(lap_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            114u8 => {
                fields.push(lap_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            115u8 => {
                fields.push(lap_message_avg_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            116u8 => {
                fields.push(lap_message_max_lev_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            117u8 => {
                fields.push(lap_message_lev_battery_consumption_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            118u8 => {
                fields.push(lap_message_avg_vertical_ratio_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            119u8 => {
                fields.push(lap_message_avg_stance_time_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            120u8 => {
                fields.push(lap_message_avg_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            121u8 => {
                fields.push(lap_message_avg_vam_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            122u8 => {
                fields.push(lap_message_avg_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            123u8 => {
                fields.push(lap_message_max_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            124u8 => {
                fields.push(lap_message_min_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            136u8 => {
                fields.push(lap_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            137u8 => {
                fields.push(lap_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            147u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_avg_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(136u8, enhanced_avg_respiration_rate.clone());
                fields.push(lap_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_avg_respiration_rate,
                )?);
            }
            148u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(lap_message_max_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(137u8, enhanced_max_respiration_rate.clone());
                fields.push(lap_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_max_respiration_rate,
                )?);
            }
            149u8 => {
                fields.push(lap_message_total_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            150u8 => {
                fields.push(lap_message_total_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            151u8 => {
                fields.push(lap_message_jump_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            153u8 => {
                fields.push(lap_message_avg_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            154u8 => {
                fields.push(lap_message_avg_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            156u8 => {
                fields.push(lap_message_total_fractional_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            157u8 => {
                fields.push(lap_message_total_fractional_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            158u8 => {
                fields.push(lap_message_avg_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            159u8 => {
                fields.push(lap_message_min_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            160u8 => {
                fields.push(lap_message_max_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            253u8 => {
                fields.push(lap_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(lap_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn lap_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_start_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "start_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_start_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "start_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_end_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "end_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_end_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "end_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_strides_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strides"
    };
    data_field_with_info(
        10u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strokes"
    };
    data_field_with_info(
        10u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "total_fat_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "max_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "avg_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        "avg_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "avg_cadence"
    } else {
        "avg_running_cadence"
    };
    data_field_with_info(
        17u8,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        "max_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_running_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "max_cadence"
    } else {
        "max_running_cadence"
    };
    data_field_with_info(
        18u8,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        "avg_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        "max_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        "intensity",
        FieldDataType::Intensity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_lap_trigger_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        "lap_trigger",
        FieldDataType::LapTrigger,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_num_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        "num_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_normalized_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33u8, value)?
    } else {
        value
    };
    data_field_with_info(
        33u8,
        "normalized_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34u8, value)?
    } else {
        value
    };
    data_field_with_info(
        34u8,
        "left_right_balance",
        FieldDataType::LeftRightBalance100,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_first_length_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 35u8, value)?
    } else {
        value
    };
    data_field_with_info(
        35u8,
        "first_length_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stroke_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37u8, value)?
    } else {
        value
    };
    data_field_with_info(
        37u8,
        "avg_stroke_distance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_swim_stroke_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 38u8, value)?
    } else {
        value
    };
    data_field_with_info(
        38u8,
        "swim_stroke",
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_num_active_lengths_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40u8, value)?
    } else {
        value
    };
    data_field_with_info(
        40u8,
        "num_active_lengths",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_work_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41u8, value)?
    } else {
        value
    };
    data_field_with_info(
        41u8,
        "total_work",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42u8, value)?
    } else {
        value
    };
    data_field_with_info(
        42u8,
        "avg_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43u8, value)?
    } else {
        value
    };
    data_field_with_info(
        43u8,
        "max_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44u8, value)?
    } else {
        value
    };
    data_field_with_info(
        44u8,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45u8, value)?
    } else {
        value
    };
    data_field_with_info(
        45u8,
        "avg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46u8, value)?
    } else {
        value
    };
    data_field_with_info(
        46u8,
        "avg_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        "avg_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48u8, value)?
    } else {
        value
    };
    data_field_with_info(
        48u8,
        "max_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49u8, value)?
    } else {
        value
    };
    data_field_with_info(
        49u8,
        "max_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50u8, value)?
    } else {
        value
    };
    data_field_with_info(
        50u8,
        "avg_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51u8, value)?
    } else {
        value
    };
    data_field_with_info(
        51u8,
        "max_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52u8, value)?
    } else {
        value
    };
    data_field_with_info(
        52u8,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53u8, value)?
    } else {
        value
    };
    data_field_with_info(
        53u8,
        "avg_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54u8, value)?
    } else {
        value
    };
    data_field_with_info(
        54u8,
        "avg_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55u8, value)?
    } else {
        value
    };
    data_field_with_info(
        55u8,
        "max_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56u8, value)?
    } else {
        value
    };
    data_field_with_info(
        56u8,
        "max_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57u8, value)?
    } else {
        value
    };
    data_field_with_info(
        57u8,
        "time_in_hr_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58u8, value)?
    } else {
        value
    };
    data_field_with_info(
        58u8,
        "time_in_speed_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59u8, value)?
    } else {
        value
    };
    data_field_with_info(
        59u8,
        "time_in_cadence_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_in_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 60u8, value)?
    } else {
        value
    };
    data_field_with_info(
        60u8,
        "time_in_power_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_repetition_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 61u8, value)?
    } else {
        value
    };
    data_field_with_info(
        61u8,
        "repetition_num",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62u8, value)?
    } else {
        value
    };
    data_field_with_info(
        62u8,
        "min_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 63u8, value)?
    } else {
        value
    };
    data_field_with_info(
        63u8,
        "min_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_wkt_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71u8, value)?
    } else {
        value
    };
    data_field_with_info(
        71u8,
        "wkt_step_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 74u8, value)?
    } else {
        value
    };
    data_field_with_info(
        74u8,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 75u8, value)?
    } else {
        value
    };
    data_field_with_info(
        75u8,
        "stroke_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_zone_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 76u8, value)?
    } else {
        value
    };
    data_field_with_info(
        76u8,
        "zone_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_vertical_oscillation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 77u8, value)?
    } else {
        value
    };
    data_field_with_info(
        77u8,
        "avg_vertical_oscillation",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stance_time_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 78u8, value)?
    } else {
        value
    };
    data_field_with_info(
        78u8,
        "avg_stance_time_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stance_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 79u8, value)?
    } else {
        value
    };
    data_field_with_info(
        79u8,
        "avg_stance_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 80u8, value)?
    } else {
        value
    };
    data_field_with_info(
        80u8,
        "avg_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 81u8, value)?
    } else {
        value
    };
    data_field_with_info(
        81u8,
        "max_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fractional_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82u8, value)?
    } else {
        value
    };
    data_field_with_info(
        82u8,
        "total_fractional_cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_player_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83u8, value)?
    } else {
        value
    };
    data_field_with_info(
        83u8,
        "player_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84u8, value)?
    } else {
        value
    };
    data_field_with_info(
        84u8,
        "avg_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85u8, value)?
    } else {
        value
    };
    data_field_with_info(
        85u8,
        "min_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86u8, value)?
    } else {
        value
    };
    data_field_with_info(
        86u8,
        "max_total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 87u8, value)?
    } else {
        value
    };
    data_field_with_info(
        87u8,
        "avg_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 88u8, value)?
    } else {
        value
    };
    data_field_with_info(
        88u8,
        "min_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89u8, value)?
    } else {
        value
    };
    data_field_with_info(
        89u8,
        "max_saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 91u8, value)?
    } else {
        value
    };
    data_field_with_info(
        91u8,
        "avg_left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 92u8, value)?
    } else {
        value
    };
    data_field_with_info(
        92u8,
        "avg_right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 93u8, value)?
    } else {
        value
    };
    data_field_with_info(
        93u8,
        "avg_left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94u8, value)?
    } else {
        value
    };
    data_field_with_info(
        94u8,
        "avg_right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95u8, value)?
    } else {
        value
    };
    data_field_with_info(
        95u8,
        "avg_combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_time_standing_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 98u8, value)?
    } else {
        value
    };
    data_field_with_info(
        98u8,
        "time_standing",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_stand_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 99u8, value)?
    } else {
        value
    };
    data_field_with_info(
        99u8,
        "stand_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 100u8, value)?
    } else {
        value
    };
    data_field_with_info(
        100u8,
        "avg_left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 101u8, value)?
    } else {
        value
    };
    data_field_with_info(
        101u8,
        "avg_right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 102u8, value)?
    } else {
        value
    };
    data_field_with_info(
        102u8,
        "avg_left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 103u8, value)?
    } else {
        value
    };
    data_field_with_info(
        103u8,
        "avg_left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 104u8, value)?
    } else {
        value
    };
    data_field_with_info(
        104u8,
        "avg_right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 105u8, value)?
    } else {
        value
    };
    data_field_with_info(
        105u8,
        "avg_right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 106u8, value)?
    } else {
        value
    };
    data_field_with_info(
        106u8,
        "avg_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 107u8, value)?
    } else {
        value
    };
    data_field_with_info(
        107u8,
        "max_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 108u8, value)?
    } else {
        value
    };
    data_field_with_info(
        108u8,
        "avg_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 109u8, value)?
    } else {
        value
    };
    data_field_with_info(
        109u8,
        "max_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 110u8, value)?
    } else {
        value
    };
    data_field_with_info(
        110u8,
        "enhanced_avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 111u8, value)?
    } else {
        value
    };
    data_field_with_info(
        111u8,
        "enhanced_max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 112u8, value)?
    } else {
        value
    };
    data_field_with_info(
        112u8,
        "enhanced_avg_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 113u8, value)?
    } else {
        value
    };
    data_field_with_info(
        113u8,
        "enhanced_min_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 114u8, value)?
    } else {
        value
    };
    data_field_with_info(
        114u8,
        "enhanced_max_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 115u8, value)?
    } else {
        value
    };
    data_field_with_info(
        115u8,
        "avg_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_lev_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 116u8, value)?
    } else {
        value
    };
    data_field_with_info(
        116u8,
        "max_lev_motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_lev_battery_consumption_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 117u8, value)?
    } else {
        value
    };
    data_field_with_info(
        117u8,
        "lev_battery_consumption",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_vertical_ratio_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 118u8, value)?
    } else {
        value
    };
    data_field_with_info(
        118u8,
        "avg_vertical_ratio",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_stance_time_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 119u8, value)?
    } else {
        value
    };
    data_field_with_info(
        119u8,
        "avg_stance_time_balance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 120u8, value)?
    } else {
        value
    };
    data_field_with_info(
        120u8,
        "avg_step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_vam_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 121u8, value)?
    } else {
        value
    };
    data_field_with_info(
        121u8,
        "avg_vam",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 122u8, value)?
    } else {
        value
    };
    data_field_with_info(
        122u8,
        "avg_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 123u8, value)?
    } else {
        value
    };
    data_field_with_info(
        123u8,
        "max_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 124u8, value)?
    } else {
        value
    };
    data_field_with_info(
        124u8,
        "min_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 136u8, value)?
    } else {
        value
    };
    data_field_with_info(
        136u8,
        "enhanced_avg_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_enhanced_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 137u8, value)?
    } else {
        value
    };
    data_field_with_info(
        137u8,
        "enhanced_max_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 147u8, value)?
    } else {
        value
    };
    data_field_with_info(
        147u8,
        "avg_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 148u8, value)?
    } else {
        value
    };
    data_field_with_info(
        148u8,
        "max_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 149u8, value)?
    } else {
        value
    };
    data_field_with_info(
        149u8,
        "total_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 150u8, value)?
    } else {
        value
    };
    data_field_with_info(
        150u8,
        "total_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_jump_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 151u8, value)?
    } else {
        value
    };
    data_field_with_info(
        151u8,
        "jump_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 153u8, value)?
    } else {
        value
    };
    data_field_with_info(
        153u8,
        "avg_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 154u8, value)?
    } else {
        value
    };
    data_field_with_info(
        154u8,
        "avg_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fractional_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 156u8, value)?
    } else {
        value
    };
    data_field_with_info(
        156u8,
        "total_fractional_ascent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_total_fractional_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 157u8, value)?
    } else {
        value
    };
    data_field_with_info(
        157u8,
        "total_fractional_descent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_avg_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 158u8, value)?
    } else {
        value
    };
    data_field_with_info(
        158u8,
        "avg_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_min_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 159u8, value)?
    } else {
        value
    };
    data_field_with_info(
        159u8,
        "min_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_max_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 160u8, value)?
    } else {
        value
    };
    data_field_with_info(
        160u8,
        "max_core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn lap_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(length_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(length_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(length_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(length_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(length_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(length_message_total_strokes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "strokes",
                    value,
                )?);
            }
            6u8 => {
                fields.push(length_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            7u8 => {
                fields.push(length_message_swim_stroke_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "swim_stroke",
                    value,
                )?);
            }
            9u8 => {
                fields.push(length_message_avg_swimming_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "strokes/min",
                    value,
                )?);
            }
            10u8 => {
                fields.push(length_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(length_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            12u8 => {
                fields.push(length_message_length_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            18u8 => {
                fields.push(length_message_player_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            19u8 => {
                fields.push(length_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            20u8 => {
                fields.push(length_message_stroke_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            21u8 => {
                fields.push(length_message_zone_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            22u8 => {
                fields.push(length_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            23u8 => {
                fields.push(length_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            24u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(length_message_avg_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(22u8, enhanced_avg_respiration_rate.clone());
                fields.push(length_message_enhanced_avg_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_avg_respiration_rate,
                )?);
            }
            25u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(length_message_max_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(23u8, enhanced_max_respiration_rate.clone());
                fields.push(length_message_enhanced_max_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    enhanced_max_respiration_rate,
                )?);
            }
            253u8 => {
                fields.push(length_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(length_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn length_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "total_strokes",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_swim_stroke_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "swim_stroke",
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_avg_swimming_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "avg_swimming_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_length_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "length_type",
        FieldDataType::LengthType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_player_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        "player_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_stroke_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        "stroke_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_zone_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "zone_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_enhanced_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "enhanced_avg_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_enhanced_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        "enhanced_max_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_avg_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        "avg_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_max_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        "max_respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn length_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(record_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            1u8 => {
                fields.push(record_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            2u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_altitude) = extract_component(&input, 0usize, 16);
                data_map.insert(78u8, enhanced_altitude.clone());
                fields.push(record_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_altitude,
                )?);
            }
            3u8 => {
                fields.push(record_message_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            4u8 => {
                fields.push(record_message_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            5u8 => {
                fields.push(record_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            6u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(73u8, enhanced_speed.clone());
                fields.push(record_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_speed,
                )?);
            }
            7u8 => {
                fields.push(record_message_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            8u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_compressed_speed_distance_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "m/s,m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), speed) = extract_component(&input, 0usize, 12);
                let ((input, offset), distance) = extract_component(input, offset, 12);
                data_map.insert(6u8, speed.clone());
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100f64,
                        0f64,
                        "m/s",
                        speed.clone(),
                    )?);
                }
                let input = speed.to_ne_bytes();
                let ((input, offset), enhanced_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(73u8, enhanced_speed.clone());
                fields.push(record_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s",
                    enhanced_speed,
                )?);
                data_map.insert(5u8, distance.clone());
                fields.push(record_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    16f64,
                    0f64,
                    "m",
                    distance,
                )?);
            }
            9u8 => {
                fields.push(record_message_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            10u8 => {
                fields.push(record_message_resistance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(record_message_time_from_course_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            12u8 => {
                fields.push(record_message_cycle_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            13u8 => {
                fields.push(record_message_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            17u8 => {
                fields.push(record_message_speed_1s_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    16f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            18u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        true,
                        1f64,
                        0f64,
                        "cycles",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), total_cycles) = extract_component(&input, 0usize, 8);
                data_map.insert(19u8, total_cycles.clone());
                fields.push(record_message_total_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    1f64,
                    0f64,
                    "cycles",
                    total_cycles,
                )?);
            }
            19u8 => {
                fields.push(record_message_total_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "cycles",
                    value,
                )?);
            }
            28u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_compressed_accumulated_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        true,
                        1f64,
                        0f64,
                        "watts",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), accumulated_power) = extract_component(&input, 0usize, 16);
                data_map.insert(29u8, accumulated_power.clone());
                fields.push(record_message_accumulated_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    1f64,
                    0f64,
                    "watts",
                    accumulated_power,
                )?);
            }
            29u8 => {
                fields.push(record_message_accumulated_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            30u8 => {
                fields.push(record_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            31u8 => {
                fields.push(record_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            32u8 => {
                fields.push(record_message_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            33u8 => {
                fields.push(record_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            39u8 => {
                fields.push(record_message_vertical_oscillation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            40u8 => {
                fields.push(record_message_stance_time_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            41u8 => {
                fields.push(record_message_stance_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            42u8 => {
                fields.push(record_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            43u8 => {
                fields.push(record_message_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            44u8 => {
                fields.push(record_message_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            45u8 => {
                fields.push(record_message_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            46u8 => {
                fields.push(record_message_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            47u8 => {
                fields.push(record_message_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            48u8 => {
                fields.push(record_message_time128_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            49u8 => {
                fields.push(record_message_stroke_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            50u8 => {
                fields.push(record_message_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            51u8 => {
                fields.push(record_message_ball_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            52u8 => {
                fields.push(record_message_cadence256_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            53u8 => {
                fields.push(record_message_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            54u8 => {
                fields.push(record_message_total_hemoglobin_conc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            55u8 => {
                fields.push(record_message_total_hemoglobin_conc_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            56u8 => {
                fields.push(record_message_total_hemoglobin_conc_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "g/dL",
                    value,
                )?);
            }
            57u8 => {
                fields.push(record_message_saturated_hemoglobin_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            58u8 => {
                fields.push(record_message_saturated_hemoglobin_percent_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            59u8 => {
                fields.push(record_message_saturated_hemoglobin_percent_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            62u8 => {
                fields.push(record_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            67u8 => {
                fields.push(record_message_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            68u8 => {
                fields.push(record_message_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            69u8 => {
                fields.push(record_message_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            70u8 => {
                fields.push(record_message_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            71u8 => {
                fields.push(record_message_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            72u8 => {
                fields.push(record_message_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            73u8 => {
                fields.push(record_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            78u8 => {
                fields.push(record_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            81u8 => {
                fields.push(record_message_battery_soc_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            82u8 => {
                fields.push(record_message_motor_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            83u8 => {
                fields.push(record_message_vertical_ratio_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            84u8 => {
                fields.push(record_message_stance_time_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            85u8 => {
                fields.push(record_message_step_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            87u8 => {
                fields.push(record_message_cycle_length16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            91u8 => {
                fields.push(record_message_absolute_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Pa",
                    value,
                )?);
            }
            92u8 => {
                fields.push(record_message_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            93u8 => {
                fields.push(record_message_next_stop_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            94u8 => {
                fields.push(record_message_next_stop_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            95u8 => {
                fields.push(record_message_time_to_surface_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            96u8 => {
                fields.push(record_message_ndl_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            97u8 => {
                fields.push(record_message_cns_load_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            98u8 => {
                fields.push(record_message_n2_load_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            99u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(record_message_respiration_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_respiration_rate) =
                    extract_component(&input, 0usize, 8);
                data_map.insert(108u8, enhanced_respiration_rate.clone());
                fields.push(record_message_enhanced_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    enhanced_respiration_rate,
                )?);
            }
            108u8 => {
                fields.push(record_message_enhanced_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "Breaths/min",
                    value,
                )?);
            }
            114u8 => {
                fields.push(record_message_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            115u8 => {
                fields.push(record_message_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            116u8 => {
                fields.push(record_message_current_stress_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            117u8 => {
                fields.push(record_message_ebike_travel_range_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "km",
                    value,
                )?);
            }
            118u8 => {
                fields.push(record_message_ebike_battery_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            119u8 => {
                fields.push(record_message_ebike_assist_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "depends on sensor",
                    value,
                )?);
            }
            120u8 => {
                fields.push(record_message_ebike_assist_level_percent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            123u8 => {
                fields.push(record_message_air_time_remaining_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            124u8 => {
                fields.push(record_message_pressure_sac_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "bar/min",
                    value,
                )?);
            }
            125u8 => {
                fields.push(record_message_volume_sac_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "L/min",
                    value,
                )?);
            }
            126u8 => {
                fields.push(record_message_rmv_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "L/min",
                    value,
                )?);
            }
            127u8 => {
                fields.push(record_message_ascent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            129u8 => {
                fields.push(record_message_po2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            139u8 => {
                fields.push(record_message_core_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            253u8 => {
                fields.push(record_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn record_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_compressed_speed_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "compressed_speed_distance",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_resistance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "resistance",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_time_from_course_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "time_from_course",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cycle_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "cycle_length",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_speed_1s_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        "speed_1s",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        "cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_compressed_accumulated_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        "compressed_accumulated_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_accumulated_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        "accumulated_power",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        "left_right_balance",
        FieldDataType::LeftRightBalance,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31u8, value)?
    } else {
        value
    };
    data_field_with_info(
        31u8,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        "vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33u8, value)?
    } else {
        value
    };
    data_field_with_info(
        33u8,
        "calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_vertical_oscillation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        "vertical_oscillation",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stance_time_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40u8, value)?
    } else {
        value
    };
    data_field_with_info(
        40u8,
        "stance_time_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stance_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41u8, value)?
    } else {
        value
    };
    data_field_with_info(
        41u8,
        "stance_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_activity_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42u8, value)?
    } else {
        value
    };
    data_field_with_info(
        42u8,
        "activity_type",
        FieldDataType::ActivityType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43u8, value)?
    } else {
        value
    };
    data_field_with_info(
        43u8,
        "left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44u8, value)?
    } else {
        value
    };
    data_field_with_info(
        44u8,
        "right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45u8, value)?
    } else {
        value
    };
    data_field_with_info(
        45u8,
        "left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46u8, value)?
    } else {
        value
    };
    data_field_with_info(
        46u8,
        "right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        "combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_time128_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48u8, value)?
    } else {
        value
    };
    data_field_with_info(
        48u8,
        "time128",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stroke_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49u8, value)?
    } else {
        value
    };
    data_field_with_info(
        49u8,
        "stroke_type",
        FieldDataType::StrokeType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50u8, value)?
    } else {
        value
    };
    data_field_with_info(
        50u8,
        "zone",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ball_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51u8, value)?
    } else {
        value
    };
    data_field_with_info(
        51u8,
        "ball_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cadence256_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52u8, value)?
    } else {
        value
    };
    data_field_with_info(
        52u8,
        "cadence256",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53u8, value)?
    } else {
        value
    };
    data_field_with_info(
        53u8,
        "fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_hemoglobin_conc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54u8, value)?
    } else {
        value
    };
    data_field_with_info(
        54u8,
        "total_hemoglobin_conc",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_hemoglobin_conc_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55u8, value)?
    } else {
        value
    };
    data_field_with_info(
        55u8,
        "total_hemoglobin_conc_min",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_total_hemoglobin_conc_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56u8, value)?
    } else {
        value
    };
    data_field_with_info(
        56u8,
        "total_hemoglobin_conc_max",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_saturated_hemoglobin_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57u8, value)?
    } else {
        value
    };
    data_field_with_info(
        57u8,
        "saturated_hemoglobin_percent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_saturated_hemoglobin_percent_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58u8, value)?
    } else {
        value
    };
    data_field_with_info(
        58u8,
        "saturated_hemoglobin_percent_min",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_saturated_hemoglobin_percent_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59u8, value)?
    } else {
        value
    };
    data_field_with_info(
        59u8,
        "saturated_hemoglobin_percent_max",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62u8, value)?
    } else {
        value
    };
    data_field_with_info(
        62u8,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 67u8, value)?
    } else {
        value
    };
    data_field_with_info(
        67u8,
        "left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 68u8, value)?
    } else {
        value
    };
    data_field_with_info(
        68u8,
        "right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 69u8, value)?
    } else {
        value
    };
    data_field_with_info(
        69u8,
        "left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 70u8, value)?
    } else {
        value
    };
    data_field_with_info(
        70u8,
        "left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71u8, value)?
    } else {
        value
    };
    data_field_with_info(
        71u8,
        "right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 72u8, value)?
    } else {
        value
    };
    data_field_with_info(
        72u8,
        "right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_enhanced_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 73u8, value)?
    } else {
        value
    };
    data_field_with_info(
        73u8,
        "enhanced_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_enhanced_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 78u8, value)?
    } else {
        value
    };
    data_field_with_info(
        78u8,
        "enhanced_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_battery_soc_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 81u8, value)?
    } else {
        value
    };
    data_field_with_info(
        81u8,
        "battery_soc",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_motor_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82u8, value)?
    } else {
        value
    };
    data_field_with_info(
        82u8,
        "motor_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_vertical_ratio_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83u8, value)?
    } else {
        value
    };
    data_field_with_info(
        83u8,
        "vertical_ratio",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_stance_time_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84u8, value)?
    } else {
        value
    };
    data_field_with_info(
        84u8,
        "stance_time_balance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_step_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85u8, value)?
    } else {
        value
    };
    data_field_with_info(
        85u8,
        "step_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cycle_length16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 87u8, value)?
    } else {
        value
    };
    data_field_with_info(
        87u8,
        "cycle_length16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_absolute_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 91u8, value)?
    } else {
        value
    };
    data_field_with_info(
        91u8,
        "absolute_pressure",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 92u8, value)?
    } else {
        value
    };
    data_field_with_info(
        92u8,
        "depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_next_stop_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 93u8, value)?
    } else {
        value
    };
    data_field_with_info(
        93u8,
        "next_stop_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_next_stop_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 94u8, value)?
    } else {
        value
    };
    data_field_with_info(
        94u8,
        "next_stop_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_time_to_surface_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 95u8, value)?
    } else {
        value
    };
    data_field_with_info(
        95u8,
        "time_to_surface",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ndl_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 96u8, value)?
    } else {
        value
    };
    data_field_with_info(
        96u8,
        "ndl_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_cns_load_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 97u8, value)?
    } else {
        value
    };
    data_field_with_info(
        97u8,
        "cns_load",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_n2_load_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 98u8, value)?
    } else {
        value
    };
    data_field_with_info(
        98u8,
        "n2_load",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 99u8, value)?
    } else {
        value
    };
    data_field_with_info(
        99u8,
        "respiration_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_enhanced_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 108u8, value)?
    } else {
        value
    };
    data_field_with_info(
        108u8,
        "enhanced_respiration_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 114u8, value)?
    } else {
        value
    };
    data_field_with_info(
        114u8,
        "grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 115u8, value)?
    } else {
        value
    };
    data_field_with_info(
        115u8,
        "flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_current_stress_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 116u8, value)?
    } else {
        value
    };
    data_field_with_info(
        116u8,
        "current_stress",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_travel_range_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 117u8, value)?
    } else {
        value
    };
    data_field_with_info(
        117u8,
        "ebike_travel_range",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_battery_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 118u8, value)?
    } else {
        value
    };
    data_field_with_info(
        118u8,
        "ebike_battery_level",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_assist_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 119u8, value)?
    } else {
        value
    };
    data_field_with_info(
        119u8,
        "ebike_assist_mode",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ebike_assist_level_percent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 120u8, value)?
    } else {
        value
    };
    data_field_with_info(
        120u8,
        "ebike_assist_level_percent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_air_time_remaining_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 123u8, value)?
    } else {
        value
    };
    data_field_with_info(
        123u8,
        "air_time_remaining",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_pressure_sac_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 124u8, value)?
    } else {
        value
    };
    data_field_with_info(
        124u8,
        "pressure_sac",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_volume_sac_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 125u8, value)?
    } else {
        value
    };
    data_field_with_info(
        125u8,
        "volume_sac",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_rmv_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 126u8, value)?
    } else {
        value
    };
    data_field_with_info(
        126u8,
        "rmv",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_ascent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 127u8, value)?
    } else {
        value
    };
    data_field_with_info(
        127u8,
        "ascent_rate",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_po2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 129u8, value)?
    } else {
        value
    };
    data_field_with_info(
        129u8,
        "po2",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_core_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 139u8, value)?
    } else {
        value
    };
    data_field_with_info(
        139u8,
        "core_temperature",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn record_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(event_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(event_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(event_message_data16_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), data) = extract_component(&input, 0usize, 16);
                data_map.insert(3u8, data.clone());
                if Event::Timer.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_timer_trigger_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::CoursePoint.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_course_point_index_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::Battery.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_battery_level_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "V",
                        data,
                    )?);
                } else if Event::VirtualPartnerPace.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_virtual_partner_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        data,
                    )?);
                } else if Event::HrHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "bpm",
                        data,
                    )?);
                } else if Event::HrLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "bpm",
                        data,
                    )?);
                } else if Event::SpeedHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        data,
                    )?);
                } else if Event::SpeedLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        data,
                    )?);
                } else if Event::CadHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        data,
                    )?);
                } else if Event::CadLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        data,
                    )?);
                } else if Event::PowerHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "watts",
                        data,
                    )?);
                } else if Event::PowerLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "watts",
                        data,
                    )?);
                } else if Event::TimeDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_time_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "s",
                        data,
                    )?);
                } else if Event::DistanceDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_distance_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100f64,
                        0f64,
                        "m",
                        data,
                    )?);
                } else if Event::CalorieDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_calorie_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "calories",
                        data,
                    )?);
                } else if Event::FitnessEquipment.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_fitness_equipment_state_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::SportPoint.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_sport_point_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::FrontGearChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::RearGearChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::RiderPositionChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_rider_position_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::CommTimeout.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_comm_timeout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::DiveAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_dive_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else if Event::AutoActivityDetect.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_auto_activity_detect_duration_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "min",
                        data,
                    )?);
                } else if Event::RadarThreatAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_radar_threat_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                } else {
                    fields.push(event_message_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        data,
                    )?);
                }
            }
            3u8 => {
                if Event::Timer.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_timer_trigger_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::CoursePoint.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_course_point_index_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::Battery.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_battery_level_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "V",
                        value,
                    )?);
                } else if Event::VirtualPartnerPace.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_virtual_partner_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value,
                    )?);
                } else if Event::HrHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "bpm",
                        value,
                    )?);
                } else if Event::HrLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_hr_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "bpm",
                        value,
                    )?);
                } else if Event::SpeedHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value,
                    )?);
                } else if Event::SpeedLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_speed_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value,
                    )?);
                } else if Event::CadHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                } else if Event::CadLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_cad_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                } else if Event::PowerHighAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_high_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "watts",
                        value,
                    )?);
                } else if Event::PowerLowAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_power_low_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "watts",
                        value,
                    )?);
                } else if Event::TimeDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_time_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "s",
                        value,
                    )?);
                } else if Event::DistanceDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_distance_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100f64,
                        0f64,
                        "m",
                        value,
                    )?);
                } else if Event::CalorieDurationAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_calorie_duration_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "calories",
                        value,
                    )?);
                } else if Event::FitnessEquipment.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_fitness_equipment_state_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::SportPoint.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_sport_point_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::FrontGearChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::RearGearChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_gear_change_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::RiderPositionChange.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_rider_position_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::CommTimeout.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_comm_timeout_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::DiveAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_dive_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Event::AutoActivityDetect.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_auto_activity_detect_duration_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "min",
                        value,
                    )?);
                } else if Event::RadarThreatAlert.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_radar_threat_alert_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(event_message_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            4u8 => {
                fields.push(event_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(event_message_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(event_message_opponent_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(event_message_front_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(event_message_front_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(event_message_rear_gear_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(event_message_rear_gear_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(event_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(event_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                if Event::AutoActivityDetect.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(event_message_auto_activity_detect_start_timestamp_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "s",
                        value,
                    )?);
                } else {
                    fields.push(event_message_start_timestamp_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "s",
                        value,
                    )?);
                }
            }
            21u8 => {
                fields.push(event_message_radar_threat_level_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            22u8 => {
                fields.push(event_message_radar_threat_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            23u8 => {
                fields.push(event_message_radar_threat_avg_approach_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            24u8 => {
                fields.push(event_message_radar_threat_max_approach_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(event_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn event_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_data16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "data16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "data",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_timer_trigger_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "timer_trigger"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::TimerTrigger,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_course_point_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "course_point_index"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_battery_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "battery_level"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_virtual_partner_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "virtual_partner_speed"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_hr_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "hr_high_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_hr_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "hr_low_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_speed_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "speed_high_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_speed_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "speed_low_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_cad_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "cad_high_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_cad_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "cad_low_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_power_high_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "power_high_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_power_low_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "power_low_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_time_duration_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "time_duration_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_distance_duration_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "distance_duration_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_calorie_duration_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "calorie_duration_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_fitness_equipment_state_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "fitness_equipment_state"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::FitnessEquipmentState,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_sport_point_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "sport_point"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_gear_change_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "gear_change_data"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_rider_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "rider_position"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::RiderPositionType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_comm_timeout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "comm_timeout"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::CommTimeoutType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_dive_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "dive_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::DiveAlert,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_auto_activity_detect_duration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "auto_activity_detect_duration"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_alert_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "data"
    } else {
        "radar_threat_alert"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_opponent_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "opponent_score",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_front_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "front_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_front_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "front_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_rear_gear_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "rear_gear_num",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_rear_gear_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "rear_gear",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_activity_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "activity_type",
        FieldDataType::ActivityType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_start_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "start_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_auto_activity_detect_start_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "start_timestamp"
    } else {
        "auto_activity_detect_start_timestamp"
    };
    data_field_with_info(
        15u8,
        name,
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_level_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "radar_threat_level_max",
        FieldDataType::RadarThreatLevelType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "radar_threat_count",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_avg_approach_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        "radar_threat_avg_approach_speed",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_radar_threat_max_approach_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        "radar_threat_max_approach_speed",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn event_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(device_info_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if SourceType::BluetoothLowEnergy.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_ble_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if SourceType::Antplus.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_antplus_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if SourceType::Ant.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_ant_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if SourceType::Local.as_i64()
                    == data_map
                        .get(&25u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_local_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(device_info_message_device_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            2u8 => {
                fields.push(device_info_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(device_info_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&2u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&2u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&2u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&2u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&2u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(device_info_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(device_info_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            5u8 => {
                fields.push(device_info_message_software_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(device_info_message_hardware_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(device_info_message_cum_operating_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            10u8 => {
                fields.push(device_info_message_battery_voltage_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256f64,
                    0f64,
                    "V",
                    value,
                )?);
            }
            11u8 => {
                fields.push(device_info_message_battery_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            18u8 => {
                fields.push(device_info_message_sensor_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            19u8 => {
                fields.push(device_info_message_descriptor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            20u8 => {
                fields.push(device_info_message_ant_transmission_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            21u8 => {
                fields.push(device_info_message_ant_device_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            22u8 => {
                fields.push(device_info_message_ant_network_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            25u8 => {
                fields.push(device_info_message_source_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            27u8 => {
                fields.push(device_info_message_product_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            32u8 => {
                fields.push(device_info_message_battery_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            253u8 => {
                fields.push(device_info_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn device_info_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "device_type",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ble_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "device_type"
    } else {
        "ble_device_type"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::BleDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_antplus_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "device_type"
    } else {
        "antplus_device_type"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::AntplusDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "device_type"
    } else {
        "ant_device_type"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_local_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "device_type"
    } else {
        "local_device_type"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::LocalDeviceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_software_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "software_version",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_hardware_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "hardware_version",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_cum_operating_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "cum_operating_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_battery_voltage_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "battery_voltage",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_battery_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "battery_status",
        FieldDataType::BatteryStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_sensor_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        "sensor_position",
        FieldDataType::BodyLocation,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_descriptor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        "descriptor",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_transmission_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        "ant_transmission_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_device_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "ant_device_number",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_ant_network_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "ant_network",
        FieldDataType::AntNetwork,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_source_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        "source_type",
        FieldDataType::SourceType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_product_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        "product_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_battery_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        "battery_level",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_info_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(device_aux_battery_info_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(device_aux_battery_info_message_battery_voltage_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256f64,
                    0f64,
                    "V",
                    value,
                )?);
            }
            2u8 => {
                fields.push(device_aux_battery_info_message_battery_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(device_aux_battery_info_message_battery_identifier_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(device_aux_battery_info_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn device_aux_battery_info_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_battery_voltage_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "battery_voltage",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_battery_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "battery_status",
        FieldDataType::BatteryStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_battery_identifier_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "battery_identifier",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn device_aux_battery_info_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Corresponds to file_id of workout or course."]
fn training_file_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(training_file_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(training_file_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(training_file_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(training_file_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            3u8 => {
                fields.push(training_file_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(training_file_message_time_created_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(training_file_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn training_file_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "type",
        FieldDataType::File,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        2u8,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        2u8,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_time_created_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "time_created",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn training_file_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(weather_conditions_message_weather_report_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(weather_conditions_message_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            2u8 => {
                fields.push(weather_conditions_message_condition_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(weather_conditions_message_wind_direction_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            4u8 => {
                fields.push(weather_conditions_message_wind_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(weather_conditions_message_precipitation_probability_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(weather_conditions_message_temperature_feels_like_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            7u8 => {
                fields.push(weather_conditions_message_relative_humidity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(weather_conditions_message_location_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(weather_conditions_message_observed_at_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(weather_conditions_message_observed_location_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            11u8 => {
                fields.push(weather_conditions_message_observed_location_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            12u8 => {
                fields.push(weather_conditions_message_day_of_week_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(weather_conditions_message_high_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            14u8 => {
                fields.push(weather_conditions_message_low_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            253u8 => {
                fields.push(weather_conditions_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn weather_conditions_message_weather_report_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "weather_report",
        FieldDataType::WeatherReport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_condition_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "condition",
        FieldDataType::WeatherStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_wind_direction_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "wind_direction",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_wind_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "wind_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_precipitation_probability_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "precipitation_probability",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_temperature_feels_like_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "temperature_feels_like",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_relative_humidity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "relative_humidity",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_location_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "location",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_observed_at_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "observed_at_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_observed_location_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "observed_location_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_observed_location_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "observed_location_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_day_of_week_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "day_of_week",
        FieldDataType::DayOfWeek,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_high_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "high_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_low_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "low_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_conditions_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(weather_alert_message_report_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(weather_alert_message_issue_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(weather_alert_message_expire_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(weather_alert_message_severity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(weather_alert_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(weather_alert_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn weather_alert_message_report_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "report_id",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_issue_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "issue_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_expire_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "expire_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_severity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "severity",
        FieldDataType::WeatherSeverity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "type",
        FieldDataType::WeatherSevereType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weather_alert_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(gps_metadata_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(gps_metadata_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            2u8 => {
                fields.push(gps_metadata_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            3u8 => {
                fields.push(gps_metadata_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(gps_metadata_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(gps_metadata_message_heading_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            6u8 => {
                fields.push(gps_metadata_message_utc_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            7u8 => {
                fields.push(gps_metadata_message_velocity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(gps_metadata_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn gps_metadata_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_enhanced_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "enhanced_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_enhanced_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "enhanced_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_heading_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "heading",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_utc_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "utc_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_velocity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "velocity",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gps_metadata_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(camera_event_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(camera_event_message_camera_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(camera_event_message_camera_file_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(camera_event_message_camera_orientation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(camera_event_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn camera_event_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_camera_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "camera_event_type",
        FieldDataType::CameraEventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_camera_file_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "camera_file_uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_camera_orientation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "camera_orientation",
        FieldDataType::CameraOrientationType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn camera_event_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(gyroscope_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(gyroscope_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(gyroscope_data_message_gyro_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            3u8 => {
                fields.push(gyroscope_data_message_gyro_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            4u8 => {
                fields.push(gyroscope_data_message_gyro_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            5u8 => {
                fields.push(gyroscope_data_message_calibrated_gyro_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            6u8 => {
                fields.push(gyroscope_data_message_calibrated_gyro_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            7u8 => {
                fields.push(gyroscope_data_message_calibrated_gyro_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(gyroscope_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn gyroscope_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_gyro_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "gyro_x",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_gyro_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "gyro_y",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_gyro_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "gyro_z",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_calibrated_gyro_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "calibrated_gyro_x",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_calibrated_gyro_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "calibrated_gyro_y",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_calibrated_gyro_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "calibrated_gyro_z",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn gyroscope_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(accelerometer_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(accelerometer_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(accelerometer_data_message_accel_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            3u8 => {
                fields.push(accelerometer_data_message_accel_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            4u8 => {
                fields.push(accelerometer_data_message_accel_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            5u8 => {
                fields.push(accelerometer_data_message_calibrated_accel_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "g",
                    value,
                )?);
            }
            6u8 => {
                fields.push(accelerometer_data_message_calibrated_accel_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "g",
                    value,
                )?);
            }
            7u8 => {
                fields.push(accelerometer_data_message_calibrated_accel_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "g",
                    value,
                )?);
            }
            8u8 => {
                fields.push(
                    accelerometer_data_message_compressed_calibrated_accel_x_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "mG",
                        value,
                    )?,
                );
            }
            9u8 => {
                fields.push(
                    accelerometer_data_message_compressed_calibrated_accel_y_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "mG",
                        value,
                    )?,
                );
            }
            10u8 => {
                fields.push(
                    accelerometer_data_message_compressed_calibrated_accel_z_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "mG",
                        value,
                    )?,
                );
            }
            253u8 => {
                fields.push(accelerometer_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn accelerometer_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_accel_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "accel_x",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_accel_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "accel_y",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_accel_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "accel_z",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_calibrated_accel_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "calibrated_accel_x",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_calibrated_accel_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "calibrated_accel_y",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_calibrated_accel_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "calibrated_accel_z",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_compressed_calibrated_accel_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "compressed_calibrated_accel_x",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_compressed_calibrated_accel_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "compressed_calibrated_accel_y",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_compressed_calibrated_accel_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "compressed_calibrated_accel_z",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn accelerometer_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(magnetometer_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(magnetometer_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(magnetometer_data_message_mag_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            3u8 => {
                fields.push(magnetometer_data_message_mag_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            4u8 => {
                fields.push(magnetometer_data_message_mag_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            5u8 => {
                fields.push(magnetometer_data_message_calibrated_mag_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "G",
                    value,
                )?);
            }
            6u8 => {
                fields.push(magnetometer_data_message_calibrated_mag_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "G",
                    value,
                )?);
            }
            7u8 => {
                fields.push(magnetometer_data_message_calibrated_mag_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "G",
                    value,
                )?);
            }
            253u8 => {
                fields.push(magnetometer_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn magnetometer_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_mag_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "mag_x",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_mag_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "mag_y",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_mag_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "mag_z",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_calibrated_mag_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "calibrated_mag_x",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_calibrated_mag_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "calibrated_mag_y",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_calibrated_mag_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "calibrated_mag_z",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn magnetometer_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn barometer_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(barometer_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(barometer_data_message_sample_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(barometer_data_message_baro_pres_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Pa",
                    value,
                )?);
            }
            253u8 => {
                fields.push(barometer_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn barometer_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn barometer_data_message_sample_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sample_time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn barometer_data_message_baro_pres_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "baro_pres",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn barometer_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(three_d_sensor_calibration_message_sensor_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if SensorType::Accelerometer.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(three_d_sensor_calibration_message_accel_cal_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "g",
                        value,
                    )?);
                } else if SensorType::Gyroscope.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(three_d_sensor_calibration_message_gyro_cal_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "deg/s",
                        value,
                    )?);
                } else {
                    fields.push(three_d_sensor_calibration_message_calibration_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            2u8 => {
                fields.push(
                    three_d_sensor_calibration_message_calibration_divisor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "counts",
                        value,
                    )?,
                );
            }
            3u8 => {
                fields.push(three_d_sensor_calibration_message_level_shift_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(three_d_sensor_calibration_message_offset_cal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(three_d_sensor_calibration_message_orientation_matrix_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    65535f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(three_d_sensor_calibration_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn three_d_sensor_calibration_message_sensor_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "sensor_type",
        FieldDataType::SensorType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_calibration_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "calibration_factor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_accel_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "calibration_factor"
    } else {
        "accel_cal_factor"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_gyro_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "calibration_factor"
    } else {
        "gyro_cal_factor"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_calibration_divisor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "calibration_divisor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_level_shift_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "level_shift",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_offset_cal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "offset_cal",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_orientation_matrix_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "orientation_matrix",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn three_d_sensor_calibration_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(one_d_sensor_calibration_message_sensor_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if SensorType::Barometer.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(one_d_sensor_calibration_message_baro_cal_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "Pa",
                        value,
                    )?);
                } else {
                    fields.push(one_d_sensor_calibration_message_calibration_factor_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            2u8 => {
                fields.push(one_d_sensor_calibration_message_calibration_divisor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "counts",
                    value,
                )?);
            }
            3u8 => {
                fields.push(one_d_sensor_calibration_message_level_shift_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(one_d_sensor_calibration_message_offset_cal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(one_d_sensor_calibration_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn one_d_sensor_calibration_message_sensor_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "sensor_type",
        FieldDataType::SensorType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_calibration_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "calibration_factor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_baro_cal_factor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "calibration_factor"
    } else {
        "baro_cal_factor"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_calibration_divisor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "calibration_divisor",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_level_shift_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "level_shift",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_offset_cal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "offset_cal",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn one_d_sensor_calibration_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_frame_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(video_frame_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(video_frame_message_frame_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(video_frame_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_frame_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_frame_message_frame_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "frame_number",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_frame_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(obdii_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(obdii_data_message_time_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(obdii_data_message_pid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(obdii_data_message_raw_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(obdii_data_message_pid_data_size_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(obdii_data_message_system_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(obdii_data_message_start_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(obdii_data_message_start_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            253u8 => {
                fields.push(obdii_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn obdii_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_time_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "time_offset",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_pid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "pid",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_raw_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "raw_data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_pid_data_size_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "pid_data_size",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_system_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "system_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_start_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "start_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_start_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "start_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn obdii_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn nmea_sentence_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(nmea_sentence_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(nmea_sentence_message_sentence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(nmea_sentence_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn nmea_sentence_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn nmea_sentence_message_sentence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sentence",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn nmea_sentence_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(aviation_attitude_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(aviation_attitude_message_system_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(aviation_attitude_message_pitch_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10430.38f64,
                    0f64,
                    "radians",
                    value,
                )?);
            }
            3u8 => {
                fields.push(aviation_attitude_message_roll_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10430.38f64,
                    0f64,
                    "radians",
                    value,
                )?);
            }
            4u8 => {
                fields.push(aviation_attitude_message_accel_lateral_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s^2",
                    value,
                )?);
            }
            5u8 => {
                fields.push(aviation_attitude_message_accel_normal_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m/s^2",
                    value,
                )?);
            }
            6u8 => {
                fields.push(aviation_attitude_message_turn_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1024f64,
                    0f64,
                    "radians/second",
                    value,
                )?);
            }
            7u8 => {
                fields.push(aviation_attitude_message_stage_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(aviation_attitude_message_attitude_stage_complete_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            9u8 => {
                fields.push(aviation_attitude_message_track_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10430.38f64,
                    0f64,
                    "radians",
                    value,
                )?);
            }
            10u8 => {
                fields.push(aviation_attitude_message_validity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(aviation_attitude_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn aviation_attitude_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_system_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "system_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_pitch_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "pitch",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_roll_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "roll",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_accel_lateral_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "accel_lateral",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_accel_normal_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "accel_normal",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_turn_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "turn_rate",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_stage_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "stage",
        FieldDataType::AttitudeStage,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_attitude_stage_complete_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "attitude_stage_complete",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_track_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "track",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_validity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "validity",
        FieldDataType::AttitudeValidity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aviation_attitude_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(video_message_url_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(video_message_hosting_provider_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(video_message_duration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_message_url_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "url",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_message_hosting_provider_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "hosting_provider",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_message_duration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "duration",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_title_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(video_title_message_message_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(video_title_message_text_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(video_title_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_title_message_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "message_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_title_message_text_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "text",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_title_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_description_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(video_description_message_message_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(video_description_message_text_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(video_description_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_description_message_message_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "message_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_description_message_text_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "text",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_description_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(video_clip_message_clip_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(video_clip_message_start_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(video_clip_message_start_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(video_clip_message_end_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(video_clip_message_end_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(video_clip_message_clip_start_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            7u8 => {
                fields.push(video_clip_message_clip_end_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn video_clip_message_clip_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "clip_number",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_start_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "start_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_start_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "start_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_end_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "end_timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_end_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "end_timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_clip_start_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "clip_start",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn video_clip_message_clip_end_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "clip_end",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(set_message_duration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            3u8 => {
                fields.push(set_message_repetitions_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(set_message_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    16f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            5u8 => {
                fields.push(set_message_set_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(set_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(set_message_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(set_message_category_subtype_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(set_message_weight_display_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(set_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(set_message_wkt_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(set_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn set_message_duration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "duration",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_repetitions_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "repetitions",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_set_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "set_type",
        FieldDataType::SetType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "category",
        FieldDataType::ExerciseCategory,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_category_subtype_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "category_subtype",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_weight_display_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "weight_display_unit",
        FieldDataType::FitBaseUnit,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_wkt_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "wkt_step_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn set_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(jump_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            1u8 => {
                fields.push(jump_message_height_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            2u8 => {
                fields.push(jump_message_rotations_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(jump_message_hang_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(jump_message_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(jump_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            6u8 => {
                fields.push(jump_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            7u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(jump_message_speed_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_speed) = extract_component(&input, 0usize, 16);
                data_map.insert(8u8, enhanced_speed.clone());
                fields.push(jump_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    enhanced_speed,
                )?);
            }
            8u8 => {
                fields.push(jump_message_enhanced_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(jump_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn jump_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "distance",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_height_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "height",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_rotations_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "rotations",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_hang_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "hang_time",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "score",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_enhanced_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "enhanced_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn jump_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(split_message_split_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(split_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(split_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            3u8 => {
                fields.push(split_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(split_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            9u8 => {
                fields.push(split_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(split_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            14u8 => {
                fields.push(split_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            21u8 => {
                fields.push(split_message_start_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            22u8 => {
                fields.push(split_message_start_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            23u8 => {
                fields.push(split_message_end_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            24u8 => {
                fields.push(split_message_end_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            25u8 => {
                fields.push(split_message_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            26u8 => {
                fields.push(split_message_avg_vert_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            27u8 => {
                fields.push(split_message_end_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            28u8 => {
                fields.push(split_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            74u8 => {
                fields.push(split_message_start_elevation_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            110u8 => {
                fields.push(split_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(split_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn split_message_split_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "split_type",
        FieldDataType::SplitType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_start_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "start_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_start_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "start_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_end_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        "end_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_end_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        "end_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        "max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_avg_vert_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        "avg_vert_speed",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_end_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        "end_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        "total_calories",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_start_elevation_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 74u8, value)?
    } else {
        value
    };
    data_field_with_info(
        74u8,
        "start_elevation",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 110u8, value)?
    } else {
        value
    };
    data_field_with_info(
        110u8,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(split_summary_message_split_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(split_summary_message_num_splits_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(split_summary_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(split_summary_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            6u8 => {
                fields.push(split_summary_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            7u8 => {
                fields.push(split_summary_message_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            8u8 => {
                fields.push(split_summary_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            9u8 => {
                fields.push(split_summary_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            10u8 => {
                fields.push(split_summary_message_avg_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            11u8 => {
                fields.push(split_summary_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            12u8 => {
                fields.push(split_summary_message_avg_vert_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            13u8 => {
                fields.push(split_summary_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            77u8 => {
                fields.push(split_summary_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(split_summary_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn split_summary_message_split_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "split_type",
        FieldDataType::SplitType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_num_splits_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "num_splits",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_avg_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "avg_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_avg_vert_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "avg_vert_speed",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "total_calories",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 77u8, value)?
    } else {
        value
    };
    data_field_with_info(
        77u8,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn split_summary_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(climb_pro_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            1u8 => {
                fields.push(climb_pro_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            2u8 => {
                fields.push(climb_pro_message_climb_pro_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(climb_pro_message_climb_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(climb_pro_message_climb_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(climb_pro_message_current_dist_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            253u8 => {
                fields.push(climb_pro_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn climb_pro_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_climb_pro_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "climb_pro_event",
        FieldDataType::ClimbProEvent,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_climb_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "climb_number",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_climb_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "climb_category",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_current_dist_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "current_dist",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn climb_pro_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Must be logged before developer field is used"]
fn field_description_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(field_description_message_developer_data_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(field_description_message_field_definition_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(field_description_message_fit_base_type_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(field_description_message_field_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(field_description_message_array_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(field_description_message_components_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(field_description_message_scale_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(field_description_message_offset_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(field_description_message_units_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(field_description_message_bits_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(field_description_message_accumulate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(field_description_message_fit_base_unit_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(field_description_message_native_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                fields.push(field_description_message_native_field_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn field_description_message_developer_data_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "developer_data_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_field_definition_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "field_definition_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_fit_base_type_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "fit_base_type_id",
        FieldDataType::FitBaseType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_field_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "field_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_array_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "array",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_components_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "components",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_scale_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "scale",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_offset_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "offset",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_units_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "units",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_bits_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "bits",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_accumulate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "accumulate",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_fit_base_unit_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "fit_base_unit_id",
        FieldDataType::FitBaseUnit,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_native_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "native_mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn field_description_message_native_field_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "native_field_num",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Must be logged before field description"]
fn developer_data_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(developer_data_id_message_developer_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(developer_data_id_message_application_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(developer_data_id_message_manufacturer_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(developer_data_id_message_developer_data_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(developer_data_id_message_application_version_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn developer_data_id_message_developer_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "developer_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_application_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "application_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_manufacturer_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "manufacturer_id",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_developer_data_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "developer_data_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn developer_data_id_message_application_version_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "application_version",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            4u8 => {
                fields.push(course_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(course_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(course_message_capabilities_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(course_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn course_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_message_capabilities_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "capabilities",
        FieldDataType::CourseCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1u8 => {
                fields.push(course_point_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(course_point_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            3u8 => {
                fields.push(course_point_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            4u8 => {
                fields.push(course_point_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            5u8 => {
                fields.push(course_point_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(course_point_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(course_point_message_favorite_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(course_point_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn course_point_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "type",
        FieldDataType::CoursePoint,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_favorite_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "favorite",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn course_point_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Unique Identification data for a segment file"]
fn segment_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(segment_id_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(segment_id_message_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(segment_id_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(segment_id_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(segment_id_message_user_profile_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(segment_id_message_device_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(segment_id_message_default_race_leader_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(segment_id_message_delete_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(segment_id_message_selection_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_id_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_user_profile_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "user_profile_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_device_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "device_id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_default_race_leader_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "default_race_leader",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_delete_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "delete_status",
        FieldDataType::SegmentDeleteStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_id_message_selection_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "selection_type",
        FieldDataType::SegmentSelectionType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Unique Identification data for an individual segment leader within a segment file"]
fn segment_leaderboard_entry_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(segment_leaderboard_entry_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(segment_leaderboard_entry_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(segment_leaderboard_entry_message_group_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(segment_leaderboard_entry_message_activity_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(segment_leaderboard_entry_message_segment_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(segment_leaderboard_entry_message_activity_id_string_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(segment_leaderboard_entry_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_leaderboard_entry_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "type",
        FieldDataType::SegmentLeaderboardType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_group_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "group_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_activity_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "activity_id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_segment_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "segment_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_activity_id_string_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "activity_id_string",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_leaderboard_entry_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Navigation and race evaluation point for a segment decribing a point along the segment path and time it took each segment leader to reach that point"]
fn segment_point_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1u8 => {
                fields.push(segment_point_message_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            2u8 => {
                fields.push(segment_point_message_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            3u8 => {
                fields.push(segment_point_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(segment_point_message_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_altitude) = extract_component(&input, 0usize, 16);
                data_map.insert(6u8, enhanced_altitude.clone());
                fields.push(segment_point_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_altitude,
                )?);
            }
            5u8 => {
                fields.push(segment_point_message_leader_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            6u8 => {
                fields.push(segment_point_message_enhanced_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            254u8 => {
                fields.push(segment_point_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_point_message_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_leader_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "leader_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_enhanced_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "enhanced_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_point_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(segment_lap_message_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(segment_lap_message_event_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(segment_lap_message_start_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(segment_lap_message_start_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            4u8 => {
                fields.push(segment_lap_message_start_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            5u8 => {
                fields.push(segment_lap_message_end_position_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            6u8 => {
                fields.push(segment_lap_message_end_position_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            7u8 => {
                fields.push(segment_lap_message_total_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            8u8 => {
                fields.push(segment_lap_message_total_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            9u8 => {
                fields.push(segment_lap_message_total_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            10u8 => {
                if Sport::Cycling.as_i64()
                    == data_map
                        .get(&23u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(segment_lap_message_total_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(segment_lap_message_total_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "cycles",
                        value,
                    )?);
                }
            }
            11u8 => {
                fields.push(segment_lap_message_total_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            12u8 => {
                fields.push(segment_lap_message_total_fat_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            13u8 => {
                fields.push(segment_lap_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            14u8 => {
                fields.push(segment_lap_message_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            15u8 => {
                fields.push(segment_lap_message_avg_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            16u8 => {
                fields.push(segment_lap_message_max_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            17u8 => {
                fields.push(segment_lap_message_avg_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            18u8 => {
                fields.push(segment_lap_message_max_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            19u8 => {
                fields.push(segment_lap_message_avg_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            20u8 => {
                fields.push(segment_lap_message_max_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            21u8 => {
                fields.push(segment_lap_message_total_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            22u8 => {
                fields.push(segment_lap_message_total_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            23u8 => {
                fields.push(segment_lap_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            24u8 => {
                fields.push(segment_lap_message_event_group_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            25u8 => {
                fields.push(segment_lap_message_nec_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            26u8 => {
                fields.push(segment_lap_message_nec_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            27u8 => {
                fields.push(segment_lap_message_swc_lat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            28u8 => {
                fields.push(segment_lap_message_swc_long_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "semicircles",
                    value,
                )?);
            }
            29u8 => {
                fields.push(segment_lap_message_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            30u8 => {
                fields.push(segment_lap_message_normalized_power_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            31u8 => {
                fields.push(segment_lap_message_left_right_balance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            32u8 => {
                fields.push(segment_lap_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            33u8 => {
                fields.push(segment_lap_message_total_work_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "J",
                    value,
                )?);
            }
            34u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(segment_lap_message_avg_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_avg_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(91u8, enhanced_avg_altitude.clone());
                fields.push(segment_lap_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_avg_altitude,
                )?);
            }
            35u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(segment_lap_message_max_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_max_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(92u8, enhanced_max_altitude.clone());
                fields.push(segment_lap_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_max_altitude,
                )?);
            }
            36u8 => {
                fields.push(segment_lap_message_gps_accuracy_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            37u8 => {
                fields.push(segment_lap_message_avg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            38u8 => {
                fields.push(segment_lap_message_avg_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            39u8 => {
                fields.push(segment_lap_message_avg_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            40u8 => {
                fields.push(segment_lap_message_max_pos_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            41u8 => {
                fields.push(segment_lap_message_max_neg_grade_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            42u8 => {
                fields.push(segment_lap_message_avg_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            43u8 => {
                fields.push(segment_lap_message_max_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            44u8 => {
                fields.push(segment_lap_message_total_moving_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            45u8 => {
                fields.push(segment_lap_message_avg_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            46u8 => {
                fields.push(segment_lap_message_avg_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            47u8 => {
                fields.push(segment_lap_message_max_pos_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            48u8 => {
                fields.push(segment_lap_message_max_neg_vertical_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            49u8 => {
                fields.push(segment_lap_message_time_in_hr_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            50u8 => {
                fields.push(segment_lap_message_time_in_speed_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            51u8 => {
                fields.push(segment_lap_message_time_in_cadence_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            52u8 => {
                fields.push(segment_lap_message_time_in_power_zone_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            53u8 => {
                fields.push(segment_lap_message_repetition_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            54u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(segment_lap_message_min_altitude_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        5f64,
                        500f64,
                        "m",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), enhanced_min_altitude) =
                    extract_component(&input, 0usize, 16);
                data_map.insert(93u8, enhanced_min_altitude.clone());
                fields.push(segment_lap_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    enhanced_min_altitude,
                )?);
            }
            55u8 => {
                fields.push(segment_lap_message_min_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            56u8 => {
                fields.push(segment_lap_message_active_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            57u8 => {
                fields.push(segment_lap_message_wkt_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            58u8 => {
                fields.push(segment_lap_message_sport_event_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            59u8 => {
                fields.push(segment_lap_message_avg_left_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            60u8 => {
                fields.push(segment_lap_message_avg_right_torque_effectiveness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            61u8 => {
                fields.push(segment_lap_message_avg_left_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            62u8 => {
                fields.push(segment_lap_message_avg_right_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            63u8 => {
                fields.push(segment_lap_message_avg_combined_pedal_smoothness_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    2f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            64u8 => {
                fields.push(segment_lap_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            65u8 => {
                fields.push(segment_lap_message_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            66u8 => {
                fields.push(segment_lap_message_avg_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            67u8 => {
                fields.push(segment_lap_message_max_fractional_cadence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            68u8 => {
                fields.push(segment_lap_message_total_fractional_cycles_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "cycles",
                    value,
                )?);
            }
            69u8 => {
                fields.push(segment_lap_message_front_gear_shift_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            70u8 => {
                fields.push(segment_lap_message_rear_gear_shift_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            71u8 => {
                fields.push(segment_lap_message_time_standing_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            72u8 => {
                fields.push(segment_lap_message_stand_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            73u8 => {
                fields.push(segment_lap_message_avg_left_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            74u8 => {
                fields.push(segment_lap_message_avg_right_pco_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mm",
                    value,
                )?);
            }
            75u8 => {
                fields.push(segment_lap_message_avg_left_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            76u8 => {
                fields.push(segment_lap_message_avg_left_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            77u8 => {
                fields.push(segment_lap_message_avg_right_power_phase_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            78u8 => {
                fields.push(segment_lap_message_avg_right_power_phase_peak_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    0.7111111f64,
                    0f64,
                    "degrees",
                    value,
                )?);
            }
            79u8 => {
                fields.push(segment_lap_message_avg_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            80u8 => {
                fields.push(segment_lap_message_max_power_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "watts",
                    value,
                )?);
            }
            81u8 => {
                fields.push(segment_lap_message_avg_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            82u8 => {
                fields.push(segment_lap_message_max_cadence_position_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "rpm",
                    value,
                )?);
            }
            83u8 => {
                fields.push(segment_lap_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            84u8 => {
                fields.push(segment_lap_message_total_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            85u8 => {
                fields.push(segment_lap_message_total_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            86u8 => {
                fields.push(segment_lap_message_avg_grit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kGrit",
                    value,
                )?);
            }
            87u8 => {
                fields.push(segment_lap_message_avg_flow_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "Flow",
                    value,
                )?);
            }
            89u8 => {
                fields.push(segment_lap_message_total_fractional_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            90u8 => {
                fields.push(segment_lap_message_total_fractional_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            91u8 => {
                fields.push(segment_lap_message_enhanced_avg_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            92u8 => {
                fields.push(segment_lap_message_enhanced_max_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            93u8 => {
                fields.push(segment_lap_message_enhanced_min_altitude_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5f64,
                    500f64,
                    "m",
                    value,
                )?);
            }
            253u8 => {
                fields.push(segment_lap_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(segment_lap_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_lap_message_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "event",
        FieldDataType::Event,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_event_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "event_type",
        FieldDataType::EventType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_start_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "start_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_start_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "start_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_start_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "start_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_end_position_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "end_position_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_end_position_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "end_position_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "total_elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "total_timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "total_distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "total_cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "total_cycles"
    } else {
        "total_strokes"
    };
    data_field_with_info(
        10u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "total_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "total_fat_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "avg_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "max_speed",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "avg_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        "max_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        "avg_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 18u8, value)?
    } else {
        value
    };
    data_field_with_info(
        18u8,
        "max_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        "avg_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        "max_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "total_ascent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "total_descent",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_event_group_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        "event_group",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_nec_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        "nec_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_nec_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        "nec_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_swc_lat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        "swc_lat",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_swc_long_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        "swc_long",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        "name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_normalized_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        "normalized_power",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_left_right_balance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31u8, value)?
    } else {
        value
    };
    data_field_with_info(
        31u8,
        "left_right_balance",
        FieldDataType::LeftRightBalance100,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_work_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33u8, value)?
    } else {
        value
    };
    data_field_with_info(
        33u8,
        "total_work",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34u8, value)?
    } else {
        value
    };
    data_field_with_info(
        34u8,
        "avg_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 35u8, value)?
    } else {
        value
    };
    data_field_with_info(
        35u8,
        "max_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_gps_accuracy_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 36u8, value)?
    } else {
        value
    };
    data_field_with_info(
        36u8,
        "gps_accuracy",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 37u8, value)?
    } else {
        value
    };
    data_field_with_info(
        37u8,
        "avg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 38u8, value)?
    } else {
        value
    };
    data_field_with_info(
        38u8,
        "avg_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 39u8, value)?
    } else {
        value
    };
    data_field_with_info(
        39u8,
        "avg_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_pos_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 40u8, value)?
    } else {
        value
    };
    data_field_with_info(
        40u8,
        "max_pos_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_neg_grade_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 41u8, value)?
    } else {
        value
    };
    data_field_with_info(
        41u8,
        "max_neg_grade",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 42u8, value)?
    } else {
        value
    };
    data_field_with_info(
        42u8,
        "avg_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 43u8, value)?
    } else {
        value
    };
    data_field_with_info(
        43u8,
        "max_temperature",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_moving_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 44u8, value)?
    } else {
        value
    };
    data_field_with_info(
        44u8,
        "total_moving_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 45u8, value)?
    } else {
        value
    };
    data_field_with_info(
        45u8,
        "avg_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 46u8, value)?
    } else {
        value
    };
    data_field_with_info(
        46u8,
        "avg_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_pos_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 47u8, value)?
    } else {
        value
    };
    data_field_with_info(
        47u8,
        "max_pos_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_neg_vertical_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 48u8, value)?
    } else {
        value
    };
    data_field_with_info(
        48u8,
        "max_neg_vertical_speed",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 49u8, value)?
    } else {
        value
    };
    data_field_with_info(
        49u8,
        "time_in_hr_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 50u8, value)?
    } else {
        value
    };
    data_field_with_info(
        50u8,
        "time_in_speed_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 51u8, value)?
    } else {
        value
    };
    data_field_with_info(
        51u8,
        "time_in_cadence_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_in_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 52u8, value)?
    } else {
        value
    };
    data_field_with_info(
        52u8,
        "time_in_power_zone",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_repetition_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 53u8, value)?
    } else {
        value
    };
    data_field_with_info(
        53u8,
        "repetition_num",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 54u8, value)?
    } else {
        value
    };
    data_field_with_info(
        54u8,
        "min_altitude",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_min_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 55u8, value)?
    } else {
        value
    };
    data_field_with_info(
        55u8,
        "min_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_active_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 56u8, value)?
    } else {
        value
    };
    data_field_with_info(
        56u8,
        "active_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_wkt_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 57u8, value)?
    } else {
        value
    };
    data_field_with_info(
        57u8,
        "wkt_step_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_sport_event_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 58u8, value)?
    } else {
        value
    };
    data_field_with_info(
        58u8,
        "sport_event",
        FieldDataType::SportEvent,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 59u8, value)?
    } else {
        value
    };
    data_field_with_info(
        59u8,
        "avg_left_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_torque_effectiveness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 60u8, value)?
    } else {
        value
    };
    data_field_with_info(
        60u8,
        "avg_right_torque_effectiveness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 61u8, value)?
    } else {
        value
    };
    data_field_with_info(
        61u8,
        "avg_left_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 62u8, value)?
    } else {
        value
    };
    data_field_with_info(
        62u8,
        "avg_right_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_combined_pedal_smoothness_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 63u8, value)?
    } else {
        value
    };
    data_field_with_info(
        63u8,
        "avg_combined_pedal_smoothness",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 64u8, value)?
    } else {
        value
    };
    data_field_with_info(
        64u8,
        "status",
        FieldDataType::SegmentLapStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 65u8, value)?
    } else {
        value
    };
    data_field_with_info(
        65u8,
        "uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 66u8, value)?
    } else {
        value
    };
    data_field_with_info(
        66u8,
        "avg_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_fractional_cadence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 67u8, value)?
    } else {
        value
    };
    data_field_with_info(
        67u8,
        "max_fractional_cadence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fractional_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 68u8, value)?
    } else {
        value
    };
    data_field_with_info(
        68u8,
        "total_fractional_cycles",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_front_gear_shift_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 69u8, value)?
    } else {
        value
    };
    data_field_with_info(
        69u8,
        "front_gear_shift_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_rear_gear_shift_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 70u8, value)?
    } else {
        value
    };
    data_field_with_info(
        70u8,
        "rear_gear_shift_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_time_standing_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 71u8, value)?
    } else {
        value
    };
    data_field_with_info(
        71u8,
        "time_standing",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_stand_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 72u8, value)?
    } else {
        value
    };
    data_field_with_info(
        72u8,
        "stand_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 73u8, value)?
    } else {
        value
    };
    data_field_with_info(
        73u8,
        "avg_left_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_pco_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 74u8, value)?
    } else {
        value
    };
    data_field_with_info(
        74u8,
        "avg_right_pco",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 75u8, value)?
    } else {
        value
    };
    data_field_with_info(
        75u8,
        "avg_left_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_left_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 76u8, value)?
    } else {
        value
    };
    data_field_with_info(
        76u8,
        "avg_left_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_power_phase_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 77u8, value)?
    } else {
        value
    };
    data_field_with_info(
        77u8,
        "avg_right_power_phase",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_right_power_phase_peak_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 78u8, value)?
    } else {
        value
    };
    data_field_with_info(
        78u8,
        "avg_right_power_phase_peak",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 79u8, value)?
    } else {
        value
    };
    data_field_with_info(
        79u8,
        "avg_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_power_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 80u8, value)?
    } else {
        value
    };
    data_field_with_info(
        80u8,
        "max_power_position",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 81u8, value)?
    } else {
        value
    };
    data_field_with_info(
        81u8,
        "avg_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_max_cadence_position_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 82u8, value)?
    } else {
        value
    };
    data_field_with_info(
        82u8,
        "max_cadence_position",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 83u8, value)?
    } else {
        value
    };
    data_field_with_info(
        83u8,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 84u8, value)?
    } else {
        value
    };
    data_field_with_info(
        84u8,
        "total_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 85u8, value)?
    } else {
        value
    };
    data_field_with_info(
        85u8,
        "total_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_grit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 86u8, value)?
    } else {
        value
    };
    data_field_with_info(
        86u8,
        "avg_grit",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_avg_flow_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 87u8, value)?
    } else {
        value
    };
    data_field_with_info(
        87u8,
        "avg_flow",
        FieldDataType::Float32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fractional_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 89u8, value)?
    } else {
        value
    };
    data_field_with_info(
        89u8,
        "total_fractional_ascent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_total_fractional_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 90u8, value)?
    } else {
        value
    };
    data_field_with_info(
        90u8,
        "total_fractional_descent",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_enhanced_avg_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 91u8, value)?
    } else {
        value
    };
    data_field_with_info(
        91u8,
        "enhanced_avg_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_enhanced_max_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 92u8, value)?
    } else {
        value
    };
    data_field_with_info(
        92u8,
        "enhanced_max_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_enhanced_min_altitude_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 93u8, value)?
    } else {
        value
    };
    data_field_with_info(
        93u8,
        "enhanced_min_altitude",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_lap_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Summary of the unique segment and leaderboard information associated with a segment file. This message is used to compile a segment list file describing all segment files on a device. The segment list file is used when refreshing the contents of a segment file with the latest available leaderboard information."]
fn segment_file_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            1u8 => {
                fields.push(segment_file_message_file_uuid_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(segment_file_message_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(segment_file_message_user_profile_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(segment_file_message_leader_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(segment_file_message_leader_group_primary_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(segment_file_message_leader_activity_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(segment_file_message_leader_activity_id_string_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(segment_file_message_default_race_leader_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(segment_file_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn segment_file_message_file_uuid_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "file_uuid",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_user_profile_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "user_profile_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "leader_type",
        FieldDataType::SegmentLeaderboardType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_group_primary_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "leader_group_primary_key",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_activity_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "leader_activity_id",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_leader_activity_id_string_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "leader_activity_id_string",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_default_race_leader_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "default_race_leader",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn segment_file_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            4u8 => {
                fields.push(workout_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(workout_message_capabilities_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(workout_message_num_valid_steps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(workout_message_wkt_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(workout_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(workout_message_pool_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            15u8 => {
                fields.push(workout_message_pool_length_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(workout_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn workout_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_capabilities_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "capabilities",
        FieldDataType::WorkoutCapabilities,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_num_valid_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "num_valid_steps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_wkt_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "wkt_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_pool_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "pool_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_pool_length_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "pool_length_unit",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(workout_session_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(workout_session_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(workout_session_message_num_valid_steps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(workout_session_message_first_step_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(workout_session_message_pool_length_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            5u8 => {
                fields.push(workout_session_message_pool_length_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(workout_session_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn workout_session_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_num_valid_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "num_valid_steps",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_first_step_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "first_step_index",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_pool_length_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "pool_length",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_pool_length_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "pool_length_unit",
        FieldDataType::DisplayMeasure,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_session_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(workout_step_message_wkt_step_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(workout_step_message_duration_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if WktStepDuration::Time.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_time_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "s",
                        value,
                    )?);
                } else if WktStepDuration::RepetitionTime.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_time_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "s",
                        value,
                    )?);
                } else if WktStepDuration::Distance.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_distance_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100f64,
                        0f64,
                        "m",
                        value,
                    )?);
                } else if WktStepDuration::HrLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::HrGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::Calories.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_calories_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "calories",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilStepsCmplt.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilTime.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilDistance.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilCalories.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_step_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::PowerLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepDuration::PowerGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepDuration::Reps.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_duration_reps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_duration_value_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            3u8 => {
                fields.push(workout_step_message_target_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_speed_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_hr_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_cadence_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_power_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilStepsCmplt.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_steps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilTime.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_time_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "s",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilDistance.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_distance_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        100f64,
                        0f64,
                        "m",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilCalories.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_calories_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "calories",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilHrGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_hr_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerLessThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepDuration::RepeatUntilPowerGreaterThan.as_i64()
                    == data_map
                        .get(&1u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_repeat_power_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else if WktStepTarget::SwimStroke.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_target_stroke_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_target_value_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            5u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_speed_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_heart_rate_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_cadence_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_power_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_custom_target_value_low_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            6u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_speed_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1000f64,
                        0f64,
                        "m/s",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_heart_rate_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or bpm",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_cadence_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "rpm",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&3u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_custom_target_power_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "% or watts",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_custom_target_value_high_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            7u8 => {
                fields.push(workout_step_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(workout_step_message_notes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(workout_step_message_equipment_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(workout_step_message_exercise_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(workout_step_message_exercise_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(workout_step_message_exercise_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            13u8 => {
                fields.push(workout_step_message_weight_display_unit_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            19u8 => {
                fields.push(workout_step_message_secondary_target_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            20u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_speed_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_hr_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_cadence_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_power_zone_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if WktStepTarget::SwimStroke.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(workout_step_message_secondary_target_stroke_type_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(workout_step_message_secondary_target_value_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            21u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_speed_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1000f64,
                            0f64,
                            "m/s",
                            value,
                        )?,
                    );
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_heart_rate_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "% or bpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_cadence_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "rpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_power_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "% or watts",
                            value,
                        )?,
                    );
                } else {
                    fields.push(
                        workout_step_message_secondary_custom_target_value_low_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "",
                            value,
                        )?,
                    );
                }
            }
            22u8 => {
                if WktStepTarget::Speed.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_speed_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1000f64,
                            0f64,
                            "m/s",
                            value,
                        )?,
                    );
                } else if WktStepTarget::HeartRate.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_heart_rate_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "% or bpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Cadence.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_cadence_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "rpm",
                            value,
                        )?,
                    );
                } else if WktStepTarget::Power.as_i64()
                    == data_map
                        .get(&19u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(
                        workout_step_message_secondary_custom_target_power_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "% or watts",
                            value,
                        )?,
                    );
                } else {
                    fields.push(
                        workout_step_message_secondary_custom_target_value_high_field(
                            mesg_num,
                            accumlators,
                            options,
                            data_map,
                            false,
                            1f64,
                            0f64,
                            "",
                            value,
                        )?,
                    );
                }
            }
            254u8 => {
                fields.push(workout_step_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn workout_step_message_wkt_step_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "wkt_step_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "duration_type",
        FieldDataType::WktStepDuration,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "duration_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_time"
    };
    data_field_with_info(
        2u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_distance"
    };
    data_field_with_info(
        2u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_hr_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_hr"
    };
    data_field_with_info(
        2u8,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_calories"
    };
    data_field_with_info(
        2u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_step_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_step"
    };
    data_field_with_info(
        2u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_power"
    };
    data_field_with_info(
        2u8,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_duration_reps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "duration_value"
    } else {
        "duration_reps"
    };
    data_field_with_info(
        2u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "target_type",
        FieldDataType::WktStepTarget,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "target_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_speed_zone"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_hr_zone"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_cadence_zone"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_power_zone"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_steps"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_time"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_distance"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_calories"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_hr_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_hr"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_repeat_power_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "repeat_power"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_target_stroke_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "target_value"
    } else {
        "target_stroke_type"
    };
    data_field_with_info(
        4u8,
        name,
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_value_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "custom_target_value_low",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_speed_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_speed_low"
    };
    data_field_with_info(
        5u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_heart_rate_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_heart_rate_low"
    };
    data_field_with_info(
        5u8,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_cadence_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_cadence_low"
    };
    data_field_with_info(
        5u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_power_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_low"
    } else {
        "custom_target_power_low"
    };
    data_field_with_info(
        5u8,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_value_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "custom_target_value_high",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_speed_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_speed_high"
    };
    data_field_with_info(
        6u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_heart_rate_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_heart_rate_high"
    };
    data_field_with_info(
        6u8,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_cadence_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_cadence_high"
    };
    data_field_with_info(
        6u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_custom_target_power_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "custom_target_value_high"
    } else {
        "custom_target_power_high"
    };
    data_field_with_info(
        6u8,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "intensity",
        FieldDataType::Intensity,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_notes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "notes",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_equipment_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "equipment",
        FieldDataType::WorkoutEquipment,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_exercise_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "exercise_category",
        FieldDataType::ExerciseCategory,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_exercise_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "exercise_name",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_exercise_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "exercise_weight",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_weight_display_unit_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "weight_display_unit",
        FieldDataType::FitBaseUnit,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        "secondary_target_type",
        FieldDataType::WktStepTarget,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    data_field_with_info(
        20u8,
        "secondary_target_value",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_speed_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_speed_zone"
    };
    data_field_with_info(
        20u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_hr_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_hr_zone"
    };
    data_field_with_info(
        20u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_cadence_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_cadence_zone"
    };
    data_field_with_info(
        20u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_power_zone_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_power_zone"
    };
    data_field_with_info(
        20u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_target_stroke_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 20u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_target_value"
    } else {
        "secondary_target_stroke_type"
    };
    data_field_with_info(
        20u8,
        name,
        FieldDataType::SwimStroke,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_value_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    data_field_with_info(
        21u8,
        "secondary_custom_target_value_low",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_speed_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_speed_low"
    };
    data_field_with_info(
        21u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_heart_rate_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_heart_rate_low"
    };
    data_field_with_info(
        21u8,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_cadence_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_cadence_low"
    };
    data_field_with_info(
        21u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_power_low_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 21u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_low"
    } else {
        "secondary_custom_target_power_low"
    };
    data_field_with_info(
        21u8,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_value_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "secondary_custom_target_value_high",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_speed_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_speed_high"
    };
    data_field_with_info(
        22u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_heart_rate_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_heart_rate_high"
    };
    data_field_with_info(
        22u8,
        name,
        FieldDataType::WorkoutHr,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_cadence_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_cadence_high"
    };
    data_field_with_info(
        22u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_secondary_custom_target_power_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "secondary_custom_target_value_high"
    } else {
        "secondary_custom_target_power_high"
    };
    data_field_with_info(
        22u8,
        name,
        FieldDataType::WorkoutPower,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn workout_step_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exercise_title_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(exercise_title_message_exercise_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(exercise_title_message_exercise_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(exercise_title_message_wkt_step_name_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            254u8 => {
                fields.push(exercise_title_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exercise_title_message_exercise_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "exercise_category",
        FieldDataType::ExerciseCategory,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exercise_title_message_exercise_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "exercise_name",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exercise_title_message_wkt_step_name_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "wkt_step_name",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exercise_title_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(schedule_message_manufacturer_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if Manufacturer::FaveroElectronics.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_favero_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Garmin.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Dynastream.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::DynastreamOem.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else if Manufacturer::Tacx.as_i64()
                    == data_map
                        .get(&0u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(schedule_message_garmin_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                } else {
                    fields.push(schedule_message_product_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value,
                    )?);
                }
            }
            2u8 => {
                fields.push(schedule_message_serial_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(schedule_message_time_created_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(schedule_message_completed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(schedule_message_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(schedule_message_scheduled_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn schedule_message_manufacturer_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "manufacturer",
        FieldDataType::Manufacturer,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "product",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_favero_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "favero_product"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::FaveroProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_garmin_product_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "product"
    } else {
        "garmin_product"
    };
    data_field_with_info(
        1u8,
        name,
        FieldDataType::GarminProduct,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_serial_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "serial_number",
        FieldDataType::UInt32z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_time_created_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "time_created",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_completed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "completed",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "type",
        FieldDataType::Schedule,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn schedule_message_scheduled_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "scheduled_time",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(totals_message_timer_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(totals_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            2u8 => {
                fields.push(totals_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            3u8 => {
                fields.push(totals_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(totals_message_elapsed_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(totals_message_sessions_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(totals_message_active_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            9u8 => {
                fields.push(totals_message_sport_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(totals_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            254u8 => {
                fields.push(totals_message_message_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn totals_message_timer_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timer_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "calories",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_elapsed_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "elapsed_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_sessions_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "sessions",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_active_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "active_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_sport_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "sport_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn totals_message_message_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 254u8, value)?
    } else {
        value
    };
    data_field_with_info(
        254u8,
        "message_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(weight_scale_message_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            1u8 => {
                fields.push(weight_scale_message_percent_fat_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            2u8 => {
                fields.push(weight_scale_message_percent_hydration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "%",
                    value,
                )?);
            }
            3u8 => {
                fields.push(weight_scale_message_visceral_fat_mass_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            4u8 => {
                fields.push(weight_scale_message_bone_mass_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            5u8 => {
                fields.push(weight_scale_message_muscle_mass_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "kg",
                    value,
                )?);
            }
            7u8 => {
                fields.push(weight_scale_message_basal_met_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    4f64,
                    0f64,
                    "kcal/day",
                    value,
                )?);
            }
            8u8 => {
                fields.push(weight_scale_message_physique_rating_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(weight_scale_message_active_met_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    4f64,
                    0f64,
                    "kcal/day",
                    value,
                )?);
            }
            10u8 => {
                fields.push(weight_scale_message_metabolic_age_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "years",
                    value,
                )?);
            }
            11u8 => {
                fields.push(weight_scale_message_visceral_fat_rating_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(weight_scale_message_user_profile_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(weight_scale_message_bmi_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "kg/m^2",
                    value,
                )?);
            }
            253u8 => {
                fields.push(weight_scale_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn weight_scale_message_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "weight",
        FieldDataType::Weight,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_percent_fat_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "percent_fat",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_percent_hydration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "percent_hydration",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_visceral_fat_mass_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "visceral_fat_mass",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_bone_mass_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "bone_mass",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_muscle_mass_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "muscle_mass",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_basal_met_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "basal_met",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_physique_rating_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "physique_rating",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_active_met_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "active_met",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_metabolic_age_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "metabolic_age",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_visceral_fat_rating_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "visceral_fat_rating",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_user_profile_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "user_profile_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_bmi_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "bmi",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn weight_scale_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(blood_pressure_message_systolic_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            1u8 => {
                fields.push(blood_pressure_message_diastolic_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            2u8 => {
                fields.push(blood_pressure_message_mean_arterial_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            3u8 => {
                fields.push(blood_pressure_message_map_3_sample_mean_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            4u8 => {
                fields.push(blood_pressure_message_map_morning_values_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            5u8 => {
                fields.push(blood_pressure_message_map_evening_values_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "mmHg",
                    value,
                )?);
            }
            6u8 => {
                fields.push(blood_pressure_message_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            7u8 => {
                fields.push(blood_pressure_message_heart_rate_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(blood_pressure_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(blood_pressure_message_user_profile_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(blood_pressure_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn blood_pressure_message_systolic_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "systolic_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_diastolic_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "diastolic_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_mean_arterial_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "mean_arterial_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_map_3_sample_mean_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "map_3_sample_mean",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_map_morning_values_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "map_morning_values",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_map_evening_values_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "map_evening_values",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_heart_rate_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "heart_rate_type",
        FieldDataType::HrType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "status",
        FieldDataType::BpStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_user_profile_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "user_profile_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn blood_pressure_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(monitoring_info_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(monitoring_info_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(monitoring_info_message_cycles_to_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5000f64,
                    0f64,
                    "m/cycle",
                    value,
                )?);
            }
            4u8 => {
                fields.push(monitoring_info_message_cycles_to_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    5000f64,
                    0f64,
                    "kcal/cycle",
                    value,
                )?);
            }
            5u8 => {
                fields.push(monitoring_info_message_resting_metabolic_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal / day",
                    value,
                )?);
            }
            253u8 => {
                fields.push(monitoring_info_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn monitoring_info_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_activity_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "activity_type",
        FieldDataType::ActivityType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_cycles_to_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "cycles_to_distance",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_cycles_to_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "cycles_to_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_resting_metabolic_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "resting_metabolic_rate",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_info_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(monitoring_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(monitoring_message_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            2u8 => {
                fields.push(monitoring_message_distance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            3u8 => {
                if ActivityType::Walking.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_steps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "steps",
                        value,
                    )?);
                } else if ActivityType::Running.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_steps_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "steps",
                        value,
                    )?);
                } else if ActivityType::Cycling.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        2f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else if ActivityType::Swimming.as_i64()
                    == data_map
                        .get(&5u8)
                        .map(|v| v.try_into().ok())
                        .flatten()
                        .unwrap_or(-1i64)
                {
                    fields.push(monitoring_message_strokes_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        2f64,
                        0f64,
                        "strokes",
                        value,
                    )?);
                } else {
                    fields.push(monitoring_message_cycles_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        2f64,
                        0f64,
                        "cycles",
                        value,
                    )?);
                }
            }
            4u8 => {
                fields.push(monitoring_message_active_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(monitoring_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(monitoring_message_activity_subtype_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(monitoring_message_activity_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(monitoring_message_distance_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "100 * m",
                    value,
                )?);
            }
            9u8 => {
                fields.push(monitoring_message_cycles_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "2 * cycles (steps)",
                    value,
                )?);
            }
            10u8 => {
                fields.push(monitoring_message_active_time_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            11u8 => {
                fields.push(monitoring_message_local_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(monitoring_message_temperature_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            14u8 => {
                fields.push(monitoring_message_temperature_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            15u8 => {
                fields.push(monitoring_message_temperature_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "C",
                    value,
                )?);
            }
            16u8 => {
                fields.push(monitoring_message_activity_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "minutes",
                    value,
                )?);
            }
            19u8 => {
                fields.push(monitoring_message_active_calories_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "kcal",
                    value,
                )?);
            }
            24u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(monitoring_message_current_activity_type_intensity_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), activity_type) = extract_component(&input, 0usize, 5);
                let ((input, offset), intensity) = extract_component(input, offset, 3);
                data_map.insert(5u8, activity_type.clone());
                fields.push(monitoring_message_activity_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    activity_type,
                )?);
                data_map.insert(28u8, intensity.clone());
                fields.push(monitoring_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    intensity,
                )?);
            }
            25u8 => {
                fields.push(monitoring_message_timestamp_min_8_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "min",
                    value,
                )?);
            }
            26u8 => {
                fields.push(monitoring_message_timestamp_16_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            27u8 => {
                fields.push(monitoring_message_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            28u8 => {
                fields.push(monitoring_message_intensity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            29u8 => {
                fields.push(monitoring_message_duration_min_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "min",
                    value,
                )?);
            }
            30u8 => {
                fields.push(monitoring_message_duration_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            31u8 => {
                fields.push(monitoring_message_ascent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            32u8 => {
                fields.push(monitoring_message_descent_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            33u8 => {
                fields.push(monitoring_message_moderate_activity_minutes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "minutes",
                    value,
                )?);
            }
            34u8 => {
                fields.push(monitoring_message_vigorous_activity_minutes_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "minutes",
                    value,
                )?);
            }
            253u8 => {
                fields.push(monitoring_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn monitoring_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_distance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "distance",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_cycles_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "cycles",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "cycles"
    } else {
        "steps"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_strokes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    let name = if options.contains(&DecodeOption::UseGenericSubFieldName) {
        "cycles"
    } else {
        "strokes"
    };
    data_field_with_info(
        3u8,
        name,
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_active_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "active_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "activity_type",
        FieldDataType::ActivityType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_subtype_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "activity_subtype",
        FieldDataType::ActivitySubtype,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "activity_level",
        FieldDataType::ActivityLevel,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_distance_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "distance_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_cycles_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "cycles_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_active_time_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "active_time_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_local_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "local_timestamp",
        FieldDataType::LocalDateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_temperature_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "temperature",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_temperature_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "temperature_min",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_temperature_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "temperature_max",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_activity_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        "activity_time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_active_calories_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 19u8, value)?
    } else {
        value
    };
    data_field_with_info(
        19u8,
        "active_calories",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_current_activity_type_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        "current_activity_type_intensity",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_timestamp_min_8_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        "timestamp_min_8",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_timestamp_16_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 26u8, value)?
    } else {
        value
    };
    data_field_with_info(
        26u8,
        "timestamp_16",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 27u8, value)?
    } else {
        value
    };
    data_field_with_info(
        27u8,
        "heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_intensity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 28u8, value)?
    } else {
        value
    };
    data_field_with_info(
        28u8,
        "intensity",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_duration_min_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 29u8, value)?
    } else {
        value
    };
    data_field_with_info(
        29u8,
        "duration_min",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_duration_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 30u8, value)?
    } else {
        value
    };
    data_field_with_info(
        30u8,
        "duration",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_ascent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 31u8, value)?
    } else {
        value
    };
    data_field_with_info(
        31u8,
        "ascent",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_descent_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 32u8, value)?
    } else {
        value
    };
    data_field_with_info(
        32u8,
        "descent",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_moderate_activity_minutes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 33u8, value)?
    } else {
        value
    };
    data_field_with_info(
        33u8,
        "moderate_activity_minutes",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_vigorous_activity_minutes_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 34u8, value)?
    } else {
        value
    };
    data_field_with_info(
        34u8,
        "vigorous_activity_minutes",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_hr_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(monitoring_hr_data_message_resting_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            1u8 => {
                fields.push(
                    monitoring_hr_data_message_current_day_resting_heart_rate_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "bpm",
                        value,
                    )?,
                );
            }
            253u8 => {
                fields.push(monitoring_hr_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn monitoring_hr_data_message_resting_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "resting_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_hr_data_message_current_day_resting_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "current_day_resting_heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn monitoring_hr_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn spo2_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(spo2_data_message_reading_spo2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            1u8 => {
                fields.push(spo2_data_message_reading_confidence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(spo2_data_message_mode_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(spo2_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn spo2_data_message_reading_spo2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "reading_spo2",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn spo2_data_message_reading_confidence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "reading_confidence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn spo2_data_message_mode_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "mode",
        FieldDataType::Spo2MeasurementType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn spo2_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hr_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(hr_message_time256_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        256f64,
                        0f64,
                        "s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), fractional_timestamp) = extract_component(&input, 0usize, 8);
                data_map.insert(0u8, fractional_timestamp.clone());
                fields.push(hr_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    256f64,
                    0f64,
                    "s",
                    fractional_timestamp,
                )?);
            }
            6u8 => {
                fields.push(hr_message_filtered_bpm_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            9u8 => {
                fields.push(hr_message_event_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1024f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            10u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(hr_message_event_timestamp_12_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "s",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), event_timestamp_1) = extract_component(&input, 0usize, 12);
                let ((input, offset), event_timestamp_2) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_3) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_4) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_5) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_6) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_7) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_8) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_9) = extract_component(input, offset, 12);
                let ((input, offset), event_timestamp_10) = extract_component(input, offset, 12);
                let event_timestamp = Value::Array(vec![
                    event_timestamp_1,
                    event_timestamp_2,
                    event_timestamp_3,
                    event_timestamp_4,
                    event_timestamp_5,
                    event_timestamp_6,
                    event_timestamp_7,
                    event_timestamp_8,
                    event_timestamp_9,
                    event_timestamp_10,
                ]);
                data_map.insert(9u8, event_timestamp.clone());
                fields.push(hr_message_event_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    true,
                    1024f64,
                    0f64,
                    "s",
                    event_timestamp,
                )?);
            }
            253u8 => {
                fields.push(hr_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hr_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_time256_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "time256",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_filtered_bpm_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "filtered_bpm",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_event_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "event_timestamp",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_event_timestamp_12_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "event_timestamp_12",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hr_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Value from 1 to 100 calculated by FirstBeat"]
fn stress_level_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(stress_level_message_stress_level_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(stress_level_message_stress_level_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn stress_level_message_stress_level_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "stress_level_value",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn stress_level_message_stress_level_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "stress_level_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(max_met_data_message_update_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(max_met_data_message_vo2_max_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "mL/kg/min",
                    value,
                )?);
            }
            5u8 => {
                fields.push(max_met_data_message_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(max_met_data_message_sub_sport_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(max_met_data_message_max_met_category_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(max_met_data_message_calibrated_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            12u8 => {
                fields.push(max_met_data_message_hr_source_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            13u8 => {
                fields.push(max_met_data_message_speed_source_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn max_met_data_message_update_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "update_time",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_vo2_max_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "vo2_max",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "sport",
        FieldDataType::Sport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_sub_sport_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "sub_sport",
        FieldDataType::SubSport,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_max_met_category_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "max_met_category",
        FieldDataType::MaxMetCategory,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_calibrated_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "calibrated_data",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_hr_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "hr_source",
        FieldDataType::MaxMetHeartRateSource,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn max_met_data_message_speed_source_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "speed_source",
        FieldDataType::MaxMetSpeedSource,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Body battery data used for HSA custom data logging"]
fn hsa_body_battery_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hsa_body_battery_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_body_battery_data_message_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hsa_body_battery_data_message_charged_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(hsa_body_battery_data_message_uncharged_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_body_battery_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_body_battery_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_body_battery_data_message_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "level",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_body_battery_data_message_charged_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "charged",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_body_battery_data_message_uncharged_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "uncharged",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_body_battery_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "HSA events"]
fn hsa_event_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hsa_event_message_event_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_event_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_event_message_event_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "event_id",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_event_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Raw accelerometer data used for HSA custom data logging"]
fn hsa_accelerometer_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hsa_accelerometer_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_accelerometer_data_message_sampling_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hsa_accelerometer_data_message_accel_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.024f64,
                    0f64,
                    "mG",
                    value,
                )?);
            }
            3u8 => {
                fields.push(hsa_accelerometer_data_message_accel_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.024f64,
                    0f64,
                    "mG",
                    value,
                )?);
            }
            4u8 => {
                fields.push(hsa_accelerometer_data_message_accel_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1.024f64,
                    0f64,
                    "mG",
                    value,
                )?);
            }
            5u8 => {
                fields.push(hsa_accelerometer_data_message_timestamp_32k_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_accelerometer_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_accelerometer_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_sampling_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sampling_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_accel_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "accel_x",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_accel_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "accel_y",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_accel_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "accel_z",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_timestamp_32k_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "timestamp_32k",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_accelerometer_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hsa_gyroscope_data_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_gyroscope_data_message_sampling_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "1/32768 s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hsa_gyroscope_data_message_gyro_x_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    28.57143f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            3u8 => {
                fields.push(hsa_gyroscope_data_message_gyro_y_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    28.57143f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            4u8 => {
                fields.push(hsa_gyroscope_data_message_gyro_z_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    28.57143f64,
                    0f64,
                    "deg/s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(hsa_gyroscope_data_message_timestamp_32k_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "1/32768 s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_gyroscope_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_gyroscope_data_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_sampling_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "sampling_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_gyro_x_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "gyro_x",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_gyro_y_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "gyro_y",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_gyro_z_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "gyro_z",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_timestamp_32k_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "timestamp_32k",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_gyroscope_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "User's current daily step data used for HSA custom data logging"]
fn hsa_step_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hsa_step_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_step_data_message_steps_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "steps",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_step_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_step_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_step_data_message_steps_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "steps",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_step_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "User's current SpO2 data used for HSA custom data logging"]
fn hsa_spo2_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hsa_spo2_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_spo2_data_message_reading_spo2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hsa_spo2_data_message_confidence_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_spo2_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_spo2_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_spo2_data_message_reading_spo2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "reading_spo2",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_spo2_data_message_confidence_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "confidence",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_spo2_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "User's current stress data used for HSA custom data logging"]
fn hsa_stress_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hsa_stress_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_stress_data_message_stress_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_stress_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_stress_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_stress_data_message_stress_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "stress_level",
        FieldDataType::SInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_stress_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "User's current respiration data used for HSA custom data logging"]
fn hsa_respiration_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hsa_respiration_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_respiration_data_message_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "breaths/min",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_respiration_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_respiration_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_respiration_data_message_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "respiration_rate",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_respiration_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "User's current heart rate data used for HSA custom data logging"]
fn hsa_heart_rate_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hsa_heart_rate_data_message_processing_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_heart_rate_data_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hsa_heart_rate_data_message_heart_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "bpm",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_heart_rate_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_heart_rate_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_heart_rate_data_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "status",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_heart_rate_data_message_heart_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "heart_rate",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_heart_rate_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Configuration data for HSA custom data logging"]
fn hsa_configuration_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hsa_configuration_data_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hsa_configuration_data_message_data_size_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_configuration_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_configuration_data_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_configuration_data_message_data_size_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "data_size",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_configuration_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Wrist temperature data used for HSA custom data logging"]
fn hsa_wrist_temperature_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(
                    hsa_wrist_temperature_data_message_processing_interval_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "s",
                        value,
                    )?,
                );
            }
            1u8 => {
                fields.push(hsa_wrist_temperature_data_message_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "degC",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hsa_wrist_temperature_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hsa_wrist_temperature_data_message_processing_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "processing_interval",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_wrist_temperature_data_message_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hsa_wrist_temperature_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(memo_glob_message_memo_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(memo_glob_message_mesg_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(memo_glob_message_parent_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(memo_glob_message_field_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(memo_glob_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            250u8 => {
                fields.push(memo_glob_message_part_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn memo_glob_message_memo_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "memo",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_mesg_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "mesg_num",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_parent_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "parent_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_field_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "field_num",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "data",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn memo_glob_message_part_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 250u8, value)?
    } else {
        value
    };
    data_field_with_info(
        250u8,
        "part_index",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_level_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(sleep_level_message_sleep_level_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(sleep_level_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn sleep_level_message_sleep_level_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "sleep_level",
        FieldDataType::SleepLevel,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_level_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(ant_channel_id_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(ant_channel_id_message_device_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(ant_channel_id_message_device_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(ant_channel_id_message_transmission_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(ant_channel_id_message_device_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ant_channel_id_message_channel_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "channel_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_device_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "device_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_device_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "device_number",
        FieldDataType::UInt16z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_transmission_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "transmission_type",
        FieldDataType::UInt8z,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_channel_id_message_device_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "device_index",
        FieldDataType::DeviceIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(ant_rx_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(ant_rx_message_mesg_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(ant_rx_message_mesg_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), channel_number) = extract_component(&input, 0usize, 8);
                let ((input, offset), data_1) = extract_component(input, offset, 8);
                let ((input, offset), data_2) = extract_component(input, offset, 8);
                let ((input, offset), data_3) = extract_component(input, offset, 8);
                let ((input, offset), data_4) = extract_component(input, offset, 8);
                let ((input, offset), data_5) = extract_component(input, offset, 8);
                let ((input, offset), data_6) = extract_component(input, offset, 8);
                let ((input, offset), data_7) = extract_component(input, offset, 8);
                let ((input, offset), data_8) = extract_component(input, offset, 8);
                data_map.insert(3u8, channel_number.clone());
                fields.push(ant_rx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    channel_number,
                )?);
                let data = Value::Array(vec![
                    data_1, data_2, data_3, data_4, data_5, data_6, data_7, data_8,
                ]);
                data_map.insert(4u8, data.clone());
                fields.push(ant_rx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    data,
                )?);
            }
            3u8 => {
                fields.push(ant_rx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(ant_rx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(ant_rx_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ant_rx_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_mesg_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "mesg_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_mesg_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "mesg_data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_channel_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "channel_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_rx_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(ant_tx_message_fractional_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    32768f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(ant_tx_message_mesg_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(ant_tx_message_mesg_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), channel_number) = extract_component(&input, 0usize, 8);
                let ((input, offset), data_1) = extract_component(input, offset, 8);
                let ((input, offset), data_2) = extract_component(input, offset, 8);
                let ((input, offset), data_3) = extract_component(input, offset, 8);
                let ((input, offset), data_4) = extract_component(input, offset, 8);
                let ((input, offset), data_5) = extract_component(input, offset, 8);
                let ((input, offset), data_6) = extract_component(input, offset, 8);
                let ((input, offset), data_7) = extract_component(input, offset, 8);
                let ((input, offset), data_8) = extract_component(input, offset, 8);
                data_map.insert(3u8, channel_number.clone());
                fields.push(ant_tx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    channel_number,
                )?);
                let data = Value::Array(vec![
                    data_1, data_2, data_3, data_4, data_5, data_6, data_7, data_8,
                ]);
                data_map.insert(4u8, data.clone());
                fields.push(ant_tx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    data,
                )?);
            }
            3u8 => {
                fields.push(ant_tx_message_channel_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(ant_tx_message_data_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(ant_tx_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn ant_tx_message_fractional_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "fractional_timestamp",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_mesg_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "mesg_id",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_mesg_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "mesg_data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_channel_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "channel_number",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "data",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn ant_tx_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_screen_configuration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(exd_screen_configuration_message_screen_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(exd_screen_configuration_message_field_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(exd_screen_configuration_message_layout_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(exd_screen_configuration_message_screen_enabled_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exd_screen_configuration_message_screen_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "screen_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_screen_configuration_message_field_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "field_count",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_screen_configuration_message_layout_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "layout",
        FieldDataType::ExdLayout,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_screen_configuration_message_screen_enabled_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "screen_enabled",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(exd_data_field_configuration_message_screen_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(exd_data_field_configuration_message_concept_field_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), field_id) = extract_component(&input, 0usize, 4);
                let ((input, offset), concept_count) = extract_component(input, offset, 4);
                data_map.insert(2u8, field_id.clone());
                fields.push(exd_data_field_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    field_id,
                )?);
                data_map.insert(3u8, concept_count.clone());
                fields.push(exd_data_field_configuration_message_concept_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    concept_count,
                )?);
            }
            2u8 => {
                fields.push(exd_data_field_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(exd_data_field_configuration_message_concept_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(exd_data_field_configuration_message_display_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(exd_data_field_configuration_message_title_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exd_data_field_configuration_message_screen_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "screen_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_concept_field_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "concept_field",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_field_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "field_id",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_concept_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "concept_count",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_display_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "display_type",
        FieldDataType::ExdDisplayType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_field_configuration_message_title_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "title",
        FieldDataType::String,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(exd_data_concept_configuration_message_screen_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(exd_data_concept_configuration_message_concept_field_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), field_id) = extract_component(&input, 0usize, 4);
                let ((input, offset), concept_index) = extract_component(input, offset, 4);
                data_map.insert(2u8, field_id.clone());
                fields.push(exd_data_concept_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    field_id,
                )?);
                data_map.insert(3u8, concept_index.clone());
                fields.push(exd_data_concept_configuration_message_concept_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    concept_index,
                )?);
            }
            2u8 => {
                fields.push(exd_data_concept_configuration_message_field_id_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(exd_data_concept_configuration_message_concept_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(exd_data_concept_configuration_message_data_page_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(exd_data_concept_configuration_message_concept_key_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(exd_data_concept_configuration_message_scaling_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(exd_data_concept_configuration_message_data_units_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(exd_data_concept_configuration_message_qualifier_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(exd_data_concept_configuration_message_descriptor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(exd_data_concept_configuration_message_is_signed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn exd_data_concept_configuration_message_screen_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "screen_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_concept_field_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "concept_field",
        FieldDataType::Byte,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_field_id_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "field_id",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_concept_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "concept_index",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_data_page_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "data_page",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_concept_key_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "concept_key",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_scaling_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "scaling",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_data_units_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "data_units",
        FieldDataType::ExdDataUnits,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_qualifier_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "qualifier",
        FieldDataType::ExdQualifiers,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_descriptor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "descriptor",
        FieldDataType::ExdDescriptors,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn exd_data_concept_configuration_message_is_signed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "is_signed",
        FieldDataType::Bool,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(dive_summary_message_reference_mesg_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(dive_summary_message_reference_index_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(dive_summary_message_avg_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            3u8 => {
                fields.push(dive_summary_message_max_depth_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m",
                    value,
                )?);
            }
            4u8 => {
                fields.push(dive_summary_message_surface_interval_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            5u8 => {
                fields.push(dive_summary_message_start_cns_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            6u8 => {
                fields.push(dive_summary_message_end_cns_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            7u8 => {
                fields.push(dive_summary_message_start_n2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            8u8 => {
                fields.push(dive_summary_message_end_n2_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "percent",
                    value,
                )?);
            }
            9u8 => {
                fields.push(dive_summary_message_o2_toxicity_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "OTUs",
                    value,
                )?);
            }
            10u8 => {
                fields.push(dive_summary_message_dive_number_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(dive_summary_message_bottom_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            12u8 => {
                fields.push(dive_summary_message_avg_pressure_sac_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "bar/min",
                    value,
                )?);
            }
            13u8 => {
                fields.push(dive_summary_message_avg_volume_sac_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "L/min",
                    value,
                )?);
            }
            14u8 => {
                fields.push(dive_summary_message_avg_rmv_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "L/min",
                    value,
                )?);
            }
            15u8 => {
                fields.push(dive_summary_message_descent_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            16u8 => {
                fields.push(dive_summary_message_ascent_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            17u8 => {
                fields.push(dive_summary_message_avg_ascent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            22u8 => {
                fields.push(dive_summary_message_avg_descent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            23u8 => {
                fields.push(dive_summary_message_max_ascent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            24u8 => {
                fields.push(dive_summary_message_max_descent_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            25u8 => {
                fields.push(dive_summary_message_hang_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(dive_summary_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn dive_summary_message_reference_mesg_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "reference_mesg",
        FieldDataType::MesgNum,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_reference_index_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "reference_index",
        FieldDataType::MessageIndex,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "avg_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_max_depth_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "max_depth",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_surface_interval_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "surface_interval",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_start_cns_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "start_cns",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_end_cns_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "end_cns",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_start_n2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "start_n2",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_end_n2_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "end_n2",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_o2_toxicity_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "o2_toxicity",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_dive_number_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "dive_number",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_bottom_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "bottom_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_pressure_sac_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 12u8, value)?
    } else {
        value
    };
    data_field_with_info(
        12u8,
        "avg_pressure_sac",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_volume_sac_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 13u8, value)?
    } else {
        value
    };
    data_field_with_info(
        13u8,
        "avg_volume_sac",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_rmv_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "avg_rmv",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_descent_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "descent_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_ascent_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 16u8, value)?
    } else {
        value
    };
    data_field_with_info(
        16u8,
        "ascent_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_ascent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 17u8, value)?
    } else {
        value
    };
    data_field_with_info(
        17u8,
        "avg_ascent_rate",
        FieldDataType::SInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_avg_descent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 22u8, value)?
    } else {
        value
    };
    data_field_with_info(
        22u8,
        "avg_descent_rate",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_max_ascent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 23u8, value)?
    } else {
        value
    };
    data_field_with_info(
        23u8,
        "max_ascent_rate",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_max_descent_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 24u8, value)?
    } else {
        value
    };
    data_field_with_info(
        24u8,
        "max_descent_rate",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_hang_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 25u8, value)?
    } else {
        value
    };
    data_field_with_info(
        25u8,
        "hang_time",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn dive_summary_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Number of acclerometer zero crossings summed over the specified time interval"]
fn aad_accel_features_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(aad_accel_features_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(aad_accel_features_message_energy_total_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(aad_accel_features_message_zero_cross_cnt_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(aad_accel_features_message_instance_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(aad_accel_features_message_time_above_threshold_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    25f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            253u8 => {
                fields.push(aad_accel_features_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn aad_accel_features_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aad_accel_features_message_energy_total_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "energy_total",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aad_accel_features_message_zero_cross_cnt_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "zero_cross_cnt",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aad_accel_features_message_instance_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "instance",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aad_accel_features_message_time_above_threshold_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "time_above_threshold",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn aad_accel_features_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Heart rate variability"]
fn hrv_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hrv_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hrv_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Array of heart beat intervals"]
fn beat_intervals_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(beat_intervals_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(beat_intervals_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            253u8 => {
                fields.push(beat_intervals_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn beat_intervals_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn beat_intervals_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn beat_intervals_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hrv_status_summary_message_weekly_average_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                fields.push(hrv_status_summary_message_last_night_average_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            2u8 => {
                fields.push(hrv_status_summary_message_last_night_5_min_high_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            3u8 => {
                fields.push(hrv_status_summary_message_baseline_low_upper_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            4u8 => {
                fields.push(hrv_status_summary_message_baseline_balanced_lower_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            5u8 => {
                fields.push(hrv_status_summary_message_baseline_balanced_upper_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            6u8 => {
                fields.push(hrv_status_summary_message_status_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hrv_status_summary_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hrv_status_summary_message_weekly_average_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "weekly_average",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_last_night_average_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "last_night_average",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_last_night_5_min_high_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "last_night_5_min_high",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_baseline_low_upper_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "baseline_low_upper",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_baseline_balanced_lower_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "baseline_balanced_lower",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_baseline_balanced_upper_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "baseline_balanced_upper",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_status_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "status",
        FieldDataType::HrvStatus,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_status_summary_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_value_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(hrv_value_message_value_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    128f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            253u8 => {
                fields.push(hrv_value_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn hrv_value_message_value_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "value",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn hrv_value_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Raw Beat-to-Beat Interval values"]
fn raw_bbi_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(raw_bbi_message_timestamp_ms_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            1u8 => {
                if options.contains(&DecodeOption::KeepCompositeFields) {
                    fields.push(raw_bbi_message_data_field(
                        mesg_num,
                        accumlators,
                        options,
                        data_map,
                        false,
                        1f64,
                        0f64,
                        "",
                        value.clone(),
                    )?);
                }
                let input = value.to_ne_bytes();
                let ((input, offset), time_1) = extract_component(&input, 0usize, 14);
                let ((input, offset), quality_1) = extract_component(input, offset, 1);
                let ((input, offset), gap_1) = extract_component(input, offset, 1);
                let ((input, offset), time_2) = extract_component(input, offset, 14);
                let ((input, offset), quality_2) = extract_component(input, offset, 1);
                let ((input, offset), gap_2) = extract_component(input, offset, 1);
                let ((input, offset), time_3) = extract_component(input, offset, 14);
                let ((input, offset), quality_3) = extract_component(input, offset, 1);
                let ((input, offset), gap_3) = extract_component(input, offset, 1);
                let ((input, offset), time_4) = extract_component(input, offset, 14);
                let ((input, offset), quality_4) = extract_component(input, offset, 1);
                let ((input, offset), gap_4) = extract_component(input, offset, 1);
                let ((input, offset), time_5) = extract_component(input, offset, 14);
                let ((input, offset), quality_5) = extract_component(input, offset, 1);
                let ((input, offset), gap_5) = extract_component(input, offset, 1);
                let ((input, offset), time_6) = extract_component(input, offset, 14);
                let ((input, offset), quality_6) = extract_component(input, offset, 1);
                let ((input, offset), gap_6) = extract_component(input, offset, 1);
                let ((input, offset), time_7) = extract_component(input, offset, 14);
                let ((input, offset), quality_7) = extract_component(input, offset, 1);
                let ((input, offset), gap_7) = extract_component(input, offset, 1);
                let ((input, offset), time_8) = extract_component(input, offset, 14);
                let ((input, offset), quality_8) = extract_component(input, offset, 1);
                let ((input, offset), gap_8) = extract_component(input, offset, 1);
                let ((input, offset), time_9) = extract_component(input, offset, 14);
                let ((input, offset), quality_9) = extract_component(input, offset, 1);
                let ((input, offset), gap_9) = extract_component(input, offset, 1);
                let ((input, offset), time_10) = extract_component(input, offset, 14);
                let ((input, offset), quality_10) = extract_component(input, offset, 1);
                let ((input, offset), gap_10) = extract_component(input, offset, 1);
                let ((input, offset), time_11) = extract_component(input, offset, 14);
                let ((input, offset), quality_11) = extract_component(input, offset, 1);
                let ((input, offset), gap_11) = extract_component(input, offset, 1);
                let ((input, offset), time_12) = extract_component(input, offset, 14);
                let ((input, offset), quality_12) = extract_component(input, offset, 1);
                let ((input, offset), gap_12) = extract_component(input, offset, 1);
                let ((input, offset), time_13) = extract_component(input, offset, 14);
                let ((input, offset), quality_13) = extract_component(input, offset, 1);
                let ((input, offset), gap_13) = extract_component(input, offset, 1);
                let ((input, offset), time_14) = extract_component(input, offset, 14);
                let ((input, offset), quality_14) = extract_component(input, offset, 1);
                let ((input, offset), gap_14) = extract_component(input, offset, 1);
                let ((input, offset), time_15) = extract_component(input, offset, 14);
                let ((input, offset), quality_15) = extract_component(input, offset, 1);
                let ((input, offset), gap_15) = extract_component(input, offset, 1);
                let time = Value::Array(vec![
                    time_1, time_2, time_3, time_4, time_5, time_6, time_7, time_8, time_9,
                    time_10, time_11, time_12, time_13, time_14, time_15,
                ]);
                data_map.insert(2u8, time.clone());
                fields.push(raw_bbi_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    time,
                )?);
                let quality = Value::Array(vec![
                    quality_1, quality_2, quality_3, quality_4, quality_5, quality_6, quality_7,
                    quality_8, quality_9, quality_10, quality_11, quality_12, quality_13,
                    quality_14, quality_15,
                ]);
                data_map.insert(3u8, quality.clone());
                fields.push(raw_bbi_message_quality_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    quality,
                )?);
                let gap = Value::Array(vec![
                    gap_1, gap_2, gap_3, gap_4, gap_5, gap_6, gap_7, gap_8, gap_9, gap_10, gap_11,
                    gap_12, gap_13, gap_14, gap_15,
                ]);
                data_map.insert(4u8, gap.clone());
                fields.push(raw_bbi_message_gap_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    gap,
                )?);
            }
            2u8 => {
                fields.push(raw_bbi_message_time_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "ms",
                    value,
                )?);
            }
            3u8 => {
                fields.push(raw_bbi_message_quality_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(raw_bbi_message_gap_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(raw_bbi_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn raw_bbi_message_timestamp_ms_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "timestamp_ms",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn raw_bbi_message_data_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "data",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn raw_bbi_message_time_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "time",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn raw_bbi_message_quality_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "quality",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn raw_bbi_message_gap_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "gap",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn raw_bbi_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn respiration_rate_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(respiration_rate_message_respiration_rate_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "breaths/min",
                    value,
                )?);
            }
            253u8 => {
                fields.push(respiration_rate_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn respiration_rate_message_respiration_rate_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "respiration_rate",
        FieldDataType::SInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn respiration_rate_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Specifically used for XERO products."]
fn chrono_shot_session_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(chrono_shot_session_message_min_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(chrono_shot_session_message_max_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            2u8 => {
                fields.push(chrono_shot_session_message_avg_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            3u8 => {
                fields.push(chrono_shot_session_message_shot_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(chrono_shot_session_message_projectile_type_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(chrono_shot_session_message_grain_weight_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    10f64,
                    0f64,
                    "gr",
                    value,
                )?);
            }
            253u8 => {
                fields.push(chrono_shot_session_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn chrono_shot_session_message_min_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "min_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_max_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "max_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_avg_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "avg_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_shot_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "shot_count",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_projectile_type_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "projectile_type",
        FieldDataType::ProjectileType,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_grain_weight_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "grain_weight",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_session_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
#[doc = "Specifically used for XERO products."]
fn chrono_shot_data_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(chrono_shot_data_message_shot_speed_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1000f64,
                    0f64,
                    "m/s",
                    value,
                )?);
            }
            1u8 => {
                fields.push(chrono_shot_data_message_shot_num_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            253u8 => {
                fields.push(chrono_shot_data_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn chrono_shot_data_message_shot_speed_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "shot_speed",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_data_message_shot_num_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "shot_num",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn chrono_shot_data_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_update_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(tank_update_message_sensor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(tank_update_message_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "bar",
                    value,
                )?);
            }
            253u8 => {
                fields.push(tank_update_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn tank_update_message_sensor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "sensor",
        FieldDataType::AntChannelId,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_update_message_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_update_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_summary_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(tank_summary_message_sensor_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(tank_summary_message_start_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "bar",
                    value,
                )?);
            }
            2u8 => {
                fields.push(tank_summary_message_end_pressure_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "bar",
                    value,
                )?);
            }
            3u8 => {
                fields.push(tank_summary_message_volume_used_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "L",
                    value,
                )?);
            }
            253u8 => {
                fields.push(tank_summary_message_timestamp_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "s",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn tank_summary_message_sensor_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "sensor",
        FieldDataType::AntChannelId,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_summary_message_start_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "start_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_summary_message_end_pressure_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "end_pressure",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_summary_message_volume_used_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "volume_used",
        FieldDataType::UInt32,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn tank_summary_message_timestamp_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 253u8, value)?
    } else {
        value
    };
    data_field_with_info(
        253u8,
        "timestamp",
        FieldDataType::DateTime,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message(
    mesg_num: MesgNum,
    data_map: &mut HashMap<u8, Value>,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    let mut fields = Vec::new();
    let mut entries: VecDeque<(u8, Value)> =
        data_map.iter().map(|(k, v)| (*k, v.clone())).collect();
    while let Some((def_num, value)) = entries.pop_front() {
        match def_num {
            0u8 => {
                fields.push(sleep_assessment_message_combined_awake_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            1u8 => {
                fields.push(sleep_assessment_message_awake_time_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            2u8 => {
                fields.push(sleep_assessment_message_awakenings_count_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            3u8 => {
                fields.push(sleep_assessment_message_deep_sleep_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            4u8 => {
                fields.push(sleep_assessment_message_sleep_duration_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            5u8 => {
                fields.push(sleep_assessment_message_light_sleep_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            6u8 => {
                fields.push(sleep_assessment_message_overall_sleep_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            7u8 => {
                fields.push(sleep_assessment_message_sleep_quality_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            8u8 => {
                fields.push(sleep_assessment_message_sleep_recovery_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            9u8 => {
                fields.push(sleep_assessment_message_rem_sleep_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            10u8 => {
                fields.push(sleep_assessment_message_sleep_restlessness_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            11u8 => {
                fields.push(sleep_assessment_message_awakenings_count_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            14u8 => {
                fields.push(sleep_assessment_message_interruptions_score_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    1f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            15u8 => {
                fields.push(sleep_assessment_message_average_stress_during_sleep_field(
                    mesg_num,
                    accumlators,
                    options,
                    data_map,
                    false,
                    100f64,
                    0f64,
                    "",
                    value,
                )?);
            }
            _ => {
                if !options.contains(&DecodeOption::DropUnknownFields) {
                    fields.push(unknown_field(def_num, value));
                }
            }
        }
    }
    Ok(fields)
}
fn sleep_assessment_message_combined_awake_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 0u8, value)?
    } else {
        value
    };
    data_field_with_info(
        0u8,
        "combined_awake_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_awake_time_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 1u8, value)?
    } else {
        value
    };
    data_field_with_info(
        1u8,
        "awake_time_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_awakenings_count_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 2u8, value)?
    } else {
        value
    };
    data_field_with_info(
        2u8,
        "awakenings_count_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_deep_sleep_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 3u8, value)?
    } else {
        value
    };
    data_field_with_info(
        3u8,
        "deep_sleep_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_sleep_duration_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 4u8, value)?
    } else {
        value
    };
    data_field_with_info(
        4u8,
        "sleep_duration_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_light_sleep_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 5u8, value)?
    } else {
        value
    };
    data_field_with_info(
        5u8,
        "light_sleep_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_overall_sleep_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 6u8, value)?
    } else {
        value
    };
    data_field_with_info(
        6u8,
        "overall_sleep_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_sleep_quality_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 7u8, value)?
    } else {
        value
    };
    data_field_with_info(
        7u8,
        "sleep_quality_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_sleep_recovery_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 8u8, value)?
    } else {
        value
    };
    data_field_with_info(
        8u8,
        "sleep_recovery_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_rem_sleep_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 9u8, value)?
    } else {
        value
    };
    data_field_with_info(
        9u8,
        "rem_sleep_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_sleep_restlessness_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 10u8, value)?
    } else {
        value
    };
    data_field_with_info(
        10u8,
        "sleep_restlessness_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_awakenings_count_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 11u8, value)?
    } else {
        value
    };
    data_field_with_info(
        11u8,
        "awakenings_count",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_interruptions_score_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 14u8, value)?
    } else {
        value
    };
    data_field_with_info(
        14u8,
        "interruptions_score",
        FieldDataType::UInt8,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn sleep_assessment_message_average_stress_during_sleep_field(
    mesg_num: MesgNum,
    accumlators: &mut HashMap<u32, Value>,
    options: &HashSet<DecodeOption>,
    data_map: &HashMap<u8, Value>,
    accumulate: bool,
    scale: f64,
    offset: f64,
    units: &'static str,
    value: Value,
) -> Result<FitDataField> {
    let value = if accumulate {
        calculate_cumulative_value(accumlators, mesg_num.as_u16(), 15u8, value)?
    } else {
        value
    };
    data_field_with_info(
        15u8,
        "average_stress_during_sleep",
        FieldDataType::UInt16,
        scale,
        offset,
        units,
        value,
        options,
    )
}
fn unknown_message(
    data_map: &HashMap<u8, Value>,
    options: &HashSet<DecodeOption>,
) -> Result<Vec<FitDataField>> {
    if options.contains(&DecodeOption::DropUnknownFields) {
        return Ok(Vec::new());
    }
    let fields = data_map
        .iter()
        .map(|(k, v)| unknown_field(*k, v.clone()))
        .collect();
    Ok(fields)
}
impl MesgNum {
    #[doc = r" Decode the raw values from a FitDataMessage based on the Global Message Number"]
    pub fn decode_message(
        self,
        data_map: &mut HashMap<u8, Value>,
        accumlators: &mut HashMap<u32, Value>,
        options: &HashSet<DecodeOption>,
    ) -> Result<Vec<FitDataField>> {
        match self {
            MesgNum::FileId => file_id_message(self, data_map, accumlators, options),
            MesgNum::FileCreator => file_creator_message(self, data_map, accumlators, options),
            MesgNum::TimestampCorrelation => {
                timestamp_correlation_message(self, data_map, accumlators, options)
            }
            MesgNum::Software => software_message(self, data_map, accumlators, options),
            MesgNum::SlaveDevice => slave_device_message(self, data_map, accumlators, options),
            MesgNum::Capabilities => capabilities_message(self, data_map, accumlators, options),
            MesgNum::FileCapabilities => {
                file_capabilities_message(self, data_map, accumlators, options)
            }
            MesgNum::MesgCapabilities => {
                mesg_capabilities_message(self, data_map, accumlators, options)
            }
            MesgNum::FieldCapabilities => {
                field_capabilities_message(self, data_map, accumlators, options)
            }
            MesgNum::DeviceSettings => {
                device_settings_message(self, data_map, accumlators, options)
            }
            MesgNum::UserProfile => user_profile_message(self, data_map, accumlators, options),
            MesgNum::HrmProfile => hrm_profile_message(self, data_map, accumlators, options),
            MesgNum::SdmProfile => sdm_profile_message(self, data_map, accumlators, options),
            MesgNum::BikeProfile => bike_profile_message(self, data_map, accumlators, options),
            MesgNum::Connectivity => connectivity_message(self, data_map, accumlators, options),
            MesgNum::WatchfaceSettings => {
                watchface_settings_message(self, data_map, accumlators, options)
            }
            MesgNum::OhrSettings => ohr_settings_message(self, data_map, accumlators, options),
            MesgNum::TimeInZone => time_in_zone_message(self, data_map, accumlators, options),
            MesgNum::ZonesTarget => zones_target_message(self, data_map, accumlators, options),
            MesgNum::Sport => sport_message(self, data_map, accumlators, options),
            MesgNum::HrZone => hr_zone_message(self, data_map, accumlators, options),
            MesgNum::SpeedZone => speed_zone_message(self, data_map, accumlators, options),
            MesgNum::CadenceZone => cadence_zone_message(self, data_map, accumlators, options),
            MesgNum::PowerZone => power_zone_message(self, data_map, accumlators, options),
            MesgNum::MetZone => met_zone_message(self, data_map, accumlators, options),
            MesgNum::DiveSettings => dive_settings_message(self, data_map, accumlators, options),
            MesgNum::DiveAlarm => dive_alarm_message(self, data_map, accumlators, options),
            MesgNum::DiveApneaAlarm => {
                dive_apnea_alarm_message(self, data_map, accumlators, options)
            }
            MesgNum::DiveGas => dive_gas_message(self, data_map, accumlators, options),
            MesgNum::Goal => goal_message(self, data_map, accumlators, options),
            MesgNum::Activity => activity_message(self, data_map, accumlators, options),
            MesgNum::Session => session_message(self, data_map, accumlators, options),
            MesgNum::Lap => lap_message(self, data_map, accumlators, options),
            MesgNum::Length => length_message(self, data_map, accumlators, options),
            MesgNum::Record => record_message(self, data_map, accumlators, options),
            MesgNum::Event => event_message(self, data_map, accumlators, options),
            MesgNum::DeviceInfo => device_info_message(self, data_map, accumlators, options),
            MesgNum::DeviceAuxBatteryInfo => {
                device_aux_battery_info_message(self, data_map, accumlators, options)
            }
            MesgNum::TrainingFile => training_file_message(self, data_map, accumlators, options),
            MesgNum::WeatherConditions => {
                weather_conditions_message(self, data_map, accumlators, options)
            }
            MesgNum::WeatherAlert => weather_alert_message(self, data_map, accumlators, options),
            MesgNum::GpsMetadata => gps_metadata_message(self, data_map, accumlators, options),
            MesgNum::CameraEvent => camera_event_message(self, data_map, accumlators, options),
            MesgNum::GyroscopeData => gyroscope_data_message(self, data_map, accumlators, options),
            MesgNum::AccelerometerData => {
                accelerometer_data_message(self, data_map, accumlators, options)
            }
            MesgNum::MagnetometerData => {
                magnetometer_data_message(self, data_map, accumlators, options)
            }
            MesgNum::BarometerData => barometer_data_message(self, data_map, accumlators, options),
            MesgNum::ThreeDSensorCalibration => {
                three_d_sensor_calibration_message(self, data_map, accumlators, options)
            }
            MesgNum::OneDSensorCalibration => {
                one_d_sensor_calibration_message(self, data_map, accumlators, options)
            }
            MesgNum::VideoFrame => video_frame_message(self, data_map, accumlators, options),
            MesgNum::ObdiiData => obdii_data_message(self, data_map, accumlators, options),
            MesgNum::NmeaSentence => nmea_sentence_message(self, data_map, accumlators, options),
            MesgNum::AviationAttitude => {
                aviation_attitude_message(self, data_map, accumlators, options)
            }
            MesgNum::Video => video_message(self, data_map, accumlators, options),
            MesgNum::VideoTitle => video_title_message(self, data_map, accumlators, options),
            MesgNum::VideoDescription => {
                video_description_message(self, data_map, accumlators, options)
            }
            MesgNum::VideoClip => video_clip_message(self, data_map, accumlators, options),
            MesgNum::Set => set_message(self, data_map, accumlators, options),
            MesgNum::Jump => jump_message(self, data_map, accumlators, options),
            MesgNum::Split => split_message(self, data_map, accumlators, options),
            MesgNum::SplitSummary => split_summary_message(self, data_map, accumlators, options),
            MesgNum::ClimbPro => climb_pro_message(self, data_map, accumlators, options),
            MesgNum::FieldDescription => {
                field_description_message(self, data_map, accumlators, options)
            }
            MesgNum::DeveloperDataId => {
                developer_data_id_message(self, data_map, accumlators, options)
            }
            MesgNum::Course => course_message(self, data_map, accumlators, options),
            MesgNum::CoursePoint => course_point_message(self, data_map, accumlators, options),
            MesgNum::SegmentId => segment_id_message(self, data_map, accumlators, options),
            MesgNum::SegmentLeaderboardEntry => {
                segment_leaderboard_entry_message(self, data_map, accumlators, options)
            }
            MesgNum::SegmentPoint => segment_point_message(self, data_map, accumlators, options),
            MesgNum::SegmentLap => segment_lap_message(self, data_map, accumlators, options),
            MesgNum::SegmentFile => segment_file_message(self, data_map, accumlators, options),
            MesgNum::Workout => workout_message(self, data_map, accumlators, options),
            MesgNum::WorkoutSession => {
                workout_session_message(self, data_map, accumlators, options)
            }
            MesgNum::WorkoutStep => workout_step_message(self, data_map, accumlators, options),
            MesgNum::ExerciseTitle => exercise_title_message(self, data_map, accumlators, options),
            MesgNum::Schedule => schedule_message(self, data_map, accumlators, options),
            MesgNum::Totals => totals_message(self, data_map, accumlators, options),
            MesgNum::WeightScale => weight_scale_message(self, data_map, accumlators, options),
            MesgNum::BloodPressure => blood_pressure_message(self, data_map, accumlators, options),
            MesgNum::MonitoringInfo => {
                monitoring_info_message(self, data_map, accumlators, options)
            }
            MesgNum::Monitoring => monitoring_message(self, data_map, accumlators, options),
            MesgNum::MonitoringHrData => {
                monitoring_hr_data_message(self, data_map, accumlators, options)
            }
            MesgNum::Spo2Data => spo2_data_message(self, data_map, accumlators, options),
            MesgNum::Hr => hr_message(self, data_map, accumlators, options),
            MesgNum::StressLevel => stress_level_message(self, data_map, accumlators, options),
            MesgNum::MaxMetData => max_met_data_message(self, data_map, accumlators, options),
            MesgNum::HsaBodyBatteryData => {
                hsa_body_battery_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaEvent => hsa_event_message(self, data_map, accumlators, options),
            MesgNum::HsaAccelerometerData => {
                hsa_accelerometer_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaGyroscopeData => {
                hsa_gyroscope_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaStepData => hsa_step_data_message(self, data_map, accumlators, options),
            MesgNum::HsaSpo2Data => hsa_spo2_data_message(self, data_map, accumlators, options),
            MesgNum::HsaStressData => hsa_stress_data_message(self, data_map, accumlators, options),
            MesgNum::HsaRespirationData => {
                hsa_respiration_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaHeartRateData => {
                hsa_heart_rate_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaConfigurationData => {
                hsa_configuration_data_message(self, data_map, accumlators, options)
            }
            MesgNum::HsaWristTemperatureData => {
                hsa_wrist_temperature_data_message(self, data_map, accumlators, options)
            }
            MesgNum::MemoGlob => memo_glob_message(self, data_map, accumlators, options),
            MesgNum::SleepLevel => sleep_level_message(self, data_map, accumlators, options),
            MesgNum::AntChannelId => ant_channel_id_message(self, data_map, accumlators, options),
            MesgNum::AntRx => ant_rx_message(self, data_map, accumlators, options),
            MesgNum::AntTx => ant_tx_message(self, data_map, accumlators, options),
            MesgNum::ExdScreenConfiguration => {
                exd_screen_configuration_message(self, data_map, accumlators, options)
            }
            MesgNum::ExdDataFieldConfiguration => {
                exd_data_field_configuration_message(self, data_map, accumlators, options)
            }
            MesgNum::ExdDataConceptConfiguration => {
                exd_data_concept_configuration_message(self, data_map, accumlators, options)
            }
            MesgNum::DiveSummary => dive_summary_message(self, data_map, accumlators, options),
            MesgNum::AadAccelFeatures => {
                aad_accel_features_message(self, data_map, accumlators, options)
            }
            MesgNum::Hrv => hrv_message(self, data_map, accumlators, options),
            MesgNum::BeatIntervals => beat_intervals_message(self, data_map, accumlators, options),
            MesgNum::HrvStatusSummary => {
                hrv_status_summary_message(self, data_map, accumlators, options)
            }
            MesgNum::HrvValue => hrv_value_message(self, data_map, accumlators, options),
            MesgNum::RawBbi => raw_bbi_message(self, data_map, accumlators, options),
            MesgNum::RespirationRate => {
                respiration_rate_message(self, data_map, accumlators, options)
            }
            MesgNum::ChronoShotSession => {
                chrono_shot_session_message(self, data_map, accumlators, options)
            }
            MesgNum::ChronoShotData => {
                chrono_shot_data_message(self, data_map, accumlators, options)
            }
            MesgNum::TankUpdate => tank_update_message(self, data_map, accumlators, options),
            MesgNum::TankSummary => tank_summary_message(self, data_map, accumlators, options),
            MesgNum::SleepAssessment => {
                sleep_assessment_message(self, data_map, accumlators, options)
            }
            _ => unknown_message(data_map, options),
        }
    }
}
